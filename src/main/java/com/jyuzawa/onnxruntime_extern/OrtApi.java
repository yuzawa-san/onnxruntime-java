/*
 * Copyright (c) 2024 James Yuzawa (https://www.jyuzawa.com/)
 * SPDX-License-Identifier: MIT
 */
package com.jyuzawa.onnxruntime_extern;

import static java.lang.foreign.MemoryLayout.PathElement.*;
import static java.lang.foreign.ValueLayout.*;

import java.lang.foreign.*;
import java.lang.invoke.*;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

/**
 * {@snippet lang=c :
 * struct OrtApi {
 *     OrtStatus *(*CreateStatus)(OrtErrorCode, const char *);
 *     OrtErrorCode (*GetErrorCode)(const OrtStatus *);
 *     const char *(*GetErrorMessage)(const OrtStatus *);
 *     OrtStatusPtr (*CreateEnv)(OrtLoggingLevel, const char *, OrtEnv **);
 *     OrtStatusPtr (*CreateEnvWithCustomLogger)(OrtLoggingFunction, void *, OrtLoggingLevel, const char *, OrtEnv **);
 *     OrtStatusPtr (*EnableTelemetryEvents)(const OrtEnv *);
 *     OrtStatusPtr (*DisableTelemetryEvents)(const OrtEnv *);
 *     OrtStatusPtr (*CreateSession)(const OrtEnv *, const char *, const OrtSessionOptions *, OrtSession **);
 *     OrtStatusPtr (*CreateSessionFromArray)(const OrtEnv *, const void *, size_t, const OrtSessionOptions *, OrtSession **);
 *     OrtStatusPtr (*Run)(OrtSession *, const OrtRunOptions *, const char *const *, const OrtValue *const *, size_t, const char *const *, size_t, OrtValue **);
 *     OrtStatusPtr (*CreateSessionOptions)(OrtSessionOptions **);
 *     OrtStatusPtr (*SetOptimizedModelFilePath)(OrtSessionOptions *, const char *);
 *     OrtStatusPtr (*CloneSessionOptions)(const OrtSessionOptions *, OrtSessionOptions **);
 *     OrtStatusPtr (*SetSessionExecutionMode)(OrtSessionOptions *, ExecutionMode);
 *     OrtStatusPtr (*EnableProfiling)(OrtSessionOptions *, const char *);
 *     OrtStatusPtr (*DisableProfiling)(OrtSessionOptions *);
 *     OrtStatusPtr (*EnableMemPattern)(OrtSessionOptions *);
 *     OrtStatusPtr (*DisableMemPattern)(OrtSessionOptions *);
 *     OrtStatusPtr (*EnableCpuMemArena)(OrtSessionOptions *);
 *     OrtStatusPtr (*DisableCpuMemArena)(OrtSessionOptions *);
 *     OrtStatusPtr (*SetSessionLogId)(OrtSessionOptions *, const char *);
 *     OrtStatusPtr (*SetSessionLogVerbosityLevel)(OrtSessionOptions *, int);
 *     OrtStatusPtr (*SetSessionLogSeverityLevel)(OrtSessionOptions *, int);
 *     OrtStatusPtr (*SetSessionGraphOptimizationLevel)(OrtSessionOptions *, GraphOptimizationLevel);
 *     OrtStatusPtr (*SetIntraOpNumThreads)(OrtSessionOptions *, int);
 *     OrtStatusPtr (*SetInterOpNumThreads)(OrtSessionOptions *, int);
 *     OrtStatusPtr (*CreateCustomOpDomain)(const char *, OrtCustomOpDomain **);
 *     OrtStatusPtr (*CustomOpDomain_Add)(OrtCustomOpDomain *, const OrtCustomOp *);
 *     OrtStatusPtr (*AddCustomOpDomain)(OrtSessionOptions *, OrtCustomOpDomain *);
 *     OrtStatusPtr (*RegisterCustomOpsLibrary)(OrtSessionOptions *, const char *, void **);
 *     OrtStatusPtr (*SessionGetInputCount)(const OrtSession *, size_t *);
 *     OrtStatusPtr (*SessionGetOutputCount)(const OrtSession *, size_t *);
 *     OrtStatusPtr (*SessionGetOverridableInitializerCount)(const OrtSession *, size_t *);
 *     OrtStatusPtr (*SessionGetInputTypeInfo)(const OrtSession *, size_t, OrtTypeInfo **);
 *     OrtStatusPtr (*SessionGetOutputTypeInfo)(const OrtSession *, size_t, OrtTypeInfo **);
 *     OrtStatusPtr (*SessionGetOverridableInitializerTypeInfo)(const OrtSession *, size_t, OrtTypeInfo **);
 *     OrtStatusPtr (*SessionGetInputName)(const OrtSession *, size_t, OrtAllocator *, char **);
 *     OrtStatusPtr (*SessionGetOutputName)(const OrtSession *, size_t, OrtAllocator *, char **);
 *     OrtStatusPtr (*SessionGetOverridableInitializerName)(const OrtSession *, size_t, OrtAllocator *, char **);
 *     OrtStatusPtr (*CreateRunOptions)(OrtRunOptions **);
 *     OrtStatusPtr (*RunOptionsSetRunLogVerbosityLevel)(OrtRunOptions *, int);
 *     OrtStatusPtr (*RunOptionsSetRunLogSeverityLevel)(OrtRunOptions *, int);
 *     OrtStatusPtr (*RunOptionsSetRunTag)(OrtRunOptions *, const char *);
 *     OrtStatusPtr (*RunOptionsGetRunLogVerbosityLevel)(const OrtRunOptions *, int *);
 *     OrtStatusPtr (*RunOptionsGetRunLogSeverityLevel)(const OrtRunOptions *, int *);
 *     OrtStatusPtr (*RunOptionsGetRunTag)(const OrtRunOptions *, const char **);
 *     OrtStatusPtr (*RunOptionsSetTerminate)(OrtRunOptions *);
 *     OrtStatusPtr (*RunOptionsUnsetTerminate)(OrtRunOptions *);
 *     OrtStatusPtr (*CreateTensorAsOrtValue)(OrtAllocator *, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **);
 *     OrtStatusPtr (*CreateTensorWithDataAsOrtValue)(const OrtMemoryInfo *, void *, size_t, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **);
 *     OrtStatusPtr (*IsTensor)(const OrtValue *, int *);
 *     OrtStatusPtr (*GetTensorMutableData)(OrtValue *, void **);
 *     OrtStatusPtr (*FillStringTensor)(OrtValue *, const char *const *, size_t);
 *     OrtStatusPtr (*GetStringTensorDataLength)(const OrtValue *, size_t *);
 *     OrtStatusPtr (*GetStringTensorContent)(const OrtValue *, void *, size_t, size_t *, size_t);
 *     OrtStatusPtr (*CastTypeInfoToTensorInfo)(const OrtTypeInfo *, const OrtTensorTypeAndShapeInfo **);
 *     OrtStatusPtr (*GetOnnxTypeFromTypeInfo)(const OrtTypeInfo *, enum ONNXType *);
 *     OrtStatusPtr (*CreateTensorTypeAndShapeInfo)(OrtTensorTypeAndShapeInfo **);
 *     OrtStatusPtr (*SetTensorElementType)(OrtTensorTypeAndShapeInfo *, enum ONNXTensorElementDataType);
 *     OrtStatusPtr (*SetDimensions)(OrtTensorTypeAndShapeInfo *, const int64_t *, size_t);
 *     OrtStatusPtr (*GetTensorElementType)(const OrtTensorTypeAndShapeInfo *, enum ONNXTensorElementDataType *);
 *     OrtStatusPtr (*GetDimensionsCount)(const OrtTensorTypeAndShapeInfo *, size_t *);
 *     OrtStatusPtr (*GetDimensions)(const OrtTensorTypeAndShapeInfo *, int64_t *, size_t);
 *     OrtStatusPtr (*GetSymbolicDimensions)(const OrtTensorTypeAndShapeInfo *, const char **, size_t);
 *     OrtStatusPtr (*GetTensorShapeElementCount)(const OrtTensorTypeAndShapeInfo *, size_t *);
 *     OrtStatusPtr (*GetTensorTypeAndShape)(const OrtValue *, OrtTensorTypeAndShapeInfo **);
 *     OrtStatusPtr (*GetTypeInfo)(const OrtValue *, OrtTypeInfo **);
 *     OrtStatusPtr (*GetValueType)(const OrtValue *, enum ONNXType *);
 *     OrtStatusPtr (*CreateMemoryInfo)(const char *, enum OrtAllocatorType, int, enum OrtMemType, OrtMemoryInfo **);
 *     OrtStatusPtr (*CreateCpuMemoryInfo)(enum OrtAllocatorType, enum OrtMemType, OrtMemoryInfo **);
 *     OrtStatusPtr (*CompareMemoryInfo)(const OrtMemoryInfo *, const OrtMemoryInfo *, int *);
 *     OrtStatusPtr (*MemoryInfoGetName)(const OrtMemoryInfo *, const char **);
 *     OrtStatusPtr (*MemoryInfoGetId)(const OrtMemoryInfo *, int *);
 *     OrtStatusPtr (*MemoryInfoGetMemType)(const OrtMemoryInfo *, OrtMemType *);
 *     OrtStatusPtr (*MemoryInfoGetType)(const OrtMemoryInfo *, OrtAllocatorType *);
 *     OrtStatusPtr (*AllocatorAlloc)(OrtAllocator *, size_t, void **);
 *     OrtStatusPtr (*AllocatorFree)(OrtAllocator *, void *);
 *     OrtStatusPtr (*AllocatorGetInfo)(const OrtAllocator *, const struct OrtMemoryInfo **);
 *     OrtStatusPtr (*GetAllocatorWithDefaultOptions)(OrtAllocator **);
 *     OrtStatusPtr (*AddFreeDimensionOverride)(OrtSessionOptions *, const char *, int64_t);
 *     OrtStatusPtr (*GetValue)(const OrtValue *, int, OrtAllocator *, OrtValue **);
 *     OrtStatusPtr (*GetValueCount)(const OrtValue *, size_t *);
 *     OrtStatusPtr (*CreateValue)(const OrtValue *const *, size_t, enum ONNXType, OrtValue **);
 *     OrtStatusPtr (*CreateOpaqueValue)(const char *, const char *, const void *, size_t, OrtValue **);
 *     OrtStatusPtr (*GetOpaqueValue)(const char *, const char *, const OrtValue *, void *, size_t);
 *     OrtStatusPtr (*KernelInfoGetAttribute_float)(const OrtKernelInfo *, const char *, float *);
 *     OrtStatusPtr (*KernelInfoGetAttribute_int64)(const OrtKernelInfo *, const char *, int64_t *);
 *     OrtStatusPtr (*KernelInfoGetAttribute_string)(const OrtKernelInfo *, const char *, char *, size_t *);
 *     OrtStatusPtr (*KernelContext_GetInputCount)(const OrtKernelContext *, size_t *);
 *     OrtStatusPtr (*KernelContext_GetOutputCount)(const OrtKernelContext *, size_t *);
 *     OrtStatusPtr (*KernelContext_GetInput)(const OrtKernelContext *, size_t, const OrtValue **);
 *     OrtStatusPtr (*KernelContext_GetOutput)(OrtKernelContext *, size_t, const int64_t *, size_t, OrtValue **);
 *     void (*ReleaseEnv)(OrtEnv *);
 *     void (*ReleaseStatus)(OrtStatus *);
 *     void (*ReleaseMemoryInfo)(OrtMemoryInfo *);
 *     void (*ReleaseSession)(OrtSession *);
 *     void (*ReleaseValue)(OrtValue *);
 *     void (*ReleaseRunOptions)(OrtRunOptions *);
 *     void (*ReleaseTypeInfo)(OrtTypeInfo *);
 *     void (*ReleaseTensorTypeAndShapeInfo)(OrtTensorTypeAndShapeInfo *);
 *     void (*ReleaseSessionOptions)(OrtSessionOptions *);
 *     void (*ReleaseCustomOpDomain)(OrtCustomOpDomain *);
 *     OrtStatusPtr (*GetDenotationFromTypeInfo)(const OrtTypeInfo *, const char **const, size_t *);
 *     OrtStatusPtr (*CastTypeInfoToMapTypeInfo)(const OrtTypeInfo *, const OrtMapTypeInfo **);
 *     OrtStatusPtr (*CastTypeInfoToSequenceTypeInfo)(const OrtTypeInfo *, const OrtSequenceTypeInfo **);
 *     OrtStatusPtr (*GetMapKeyType)(const OrtMapTypeInfo *, enum ONNXTensorElementDataType *);
 *     OrtStatusPtr (*GetMapValueType)(const OrtMapTypeInfo *, OrtTypeInfo **);
 *     OrtStatusPtr (*GetSequenceElementType)(const OrtSequenceTypeInfo *, OrtTypeInfo **);
 *     void (*ReleaseMapTypeInfo)(OrtMapTypeInfo *);
 *     void (*ReleaseSequenceTypeInfo)(OrtSequenceTypeInfo *);
 *     OrtStatusPtr (*SessionEndProfiling)(OrtSession *, OrtAllocator *, char **);
 *     OrtStatusPtr (*SessionGetModelMetadata)(const OrtSession *, OrtModelMetadata **);
 *     OrtStatusPtr (*ModelMetadataGetProducerName)(const OrtModelMetadata *, OrtAllocator *, char **);
 *     OrtStatusPtr (*ModelMetadataGetGraphName)(const OrtModelMetadata *, OrtAllocator *, char **);
 *     OrtStatusPtr (*ModelMetadataGetDomain)(const OrtModelMetadata *, OrtAllocator *, char **);
 *     OrtStatusPtr (*ModelMetadataGetDescription)(const OrtModelMetadata *, OrtAllocator *, char **);
 *     OrtStatusPtr (*ModelMetadataLookupCustomMetadataMap)(const OrtModelMetadata *, OrtAllocator *, const char *, char **);
 *     OrtStatusPtr (*ModelMetadataGetVersion)(const OrtModelMetadata *, int64_t *);
 *     void (*ReleaseModelMetadata)(OrtModelMetadata *);
 *     OrtStatusPtr (*CreateEnvWithGlobalThreadPools)(OrtLoggingLevel, const char *, const OrtThreadingOptions *, OrtEnv **);
 *     OrtStatusPtr (*DisablePerSessionThreads)(OrtSessionOptions *);
 *     OrtStatusPtr (*CreateThreadingOptions)(OrtThreadingOptions **);
 *     void (*ReleaseThreadingOptions)(OrtThreadingOptions *);
 *     OrtStatusPtr (*ModelMetadataGetCustomMetadataMapKeys)(const OrtModelMetadata *, OrtAllocator *, char ***, int64_t *);
 *     OrtStatusPtr (*AddFreeDimensionOverrideByName)(OrtSessionOptions *, const char *, int64_t);
 *     OrtStatusPtr (*GetAvailableProviders)(char ***, int *);
 *     OrtStatusPtr (*ReleaseAvailableProviders)(char **, int);
 *     OrtStatusPtr (*GetStringTensorElementLength)(const OrtValue *, size_t, size_t *);
 *     OrtStatusPtr (*GetStringTensorElement)(const OrtValue *, size_t, size_t, void *);
 *     OrtStatusPtr (*FillStringTensorElement)(OrtValue *, const char *, size_t);
 *     OrtStatusPtr (*AddSessionConfigEntry)(OrtSessionOptions *, const char *, const char *);
 *     OrtStatusPtr (*CreateAllocator)(const OrtSession *, const OrtMemoryInfo *, OrtAllocator **);
 *     void (*ReleaseAllocator)(OrtAllocator *);
 *     OrtStatusPtr (*RunWithBinding)(OrtSession *, const OrtRunOptions *, const OrtIoBinding *);
 *     OrtStatusPtr (*CreateIoBinding)(OrtSession *, OrtIoBinding **);
 *     void (*ReleaseIoBinding)(OrtIoBinding *);
 *     OrtStatusPtr (*BindInput)(OrtIoBinding *, const char *, const OrtValue *);
 *     OrtStatusPtr (*BindOutput)(OrtIoBinding *, const char *, const OrtValue *);
 *     OrtStatusPtr (*BindOutputToDevice)(OrtIoBinding *, const char *, const OrtMemoryInfo *);
 *     OrtStatusPtr (*GetBoundOutputNames)(const OrtIoBinding *, OrtAllocator *, char **, size_t **, size_t *);
 *     OrtStatusPtr (*GetBoundOutputValues)(const OrtIoBinding *, OrtAllocator *, OrtValue ***, size_t *);
 *     void (*ClearBoundInputs)(OrtIoBinding *);
 *     void (*ClearBoundOutputs)(OrtIoBinding *);
 *     OrtStatusPtr (*TensorAt)(OrtValue *, const int64_t *, size_t, void **);
 *     OrtStatusPtr (*CreateAndRegisterAllocator)(OrtEnv *, const OrtMemoryInfo *, const OrtArenaCfg *);
 *     OrtStatusPtr (*SetLanguageProjection)(const OrtEnv *, OrtLanguageProjection);
 *     OrtStatusPtr (*SessionGetProfilingStartTimeNs)(const OrtSession *, uint64_t *);
 *     OrtStatusPtr (*SetGlobalIntraOpNumThreads)(OrtThreadingOptions *, int);
 *     OrtStatusPtr (*SetGlobalInterOpNumThreads)(OrtThreadingOptions *, int);
 *     OrtStatusPtr (*SetGlobalSpinControl)(OrtThreadingOptions *, int);
 *     OrtStatusPtr (*AddInitializer)(OrtSessionOptions *, const char *, const OrtValue *);
 *     OrtStatusPtr (*CreateEnvWithCustomLoggerAndGlobalThreadPools)(OrtLoggingFunction, void *, OrtLoggingLevel, const char *, const struct OrtThreadingOptions *, OrtEnv **);
 *     OrtStatusPtr (*SessionOptionsAppendExecutionProvider_CUDA)(OrtSessionOptions *, const OrtCUDAProviderOptions *);
 *     OrtStatusPtr (*SessionOptionsAppendExecutionProvider_ROCM)(OrtSessionOptions *, const OrtROCMProviderOptions *);
 *     OrtStatusPtr (*SessionOptionsAppendExecutionProvider_OpenVINO)(OrtSessionOptions *, const OrtOpenVINOProviderOptions *);
 *     OrtStatusPtr (*SetGlobalDenormalAsZero)(OrtThreadingOptions *);
 *     OrtStatusPtr (*CreateArenaCfg)(size_t, int, int, int, OrtArenaCfg **);
 *     void (*ReleaseArenaCfg)(OrtArenaCfg *);
 *     OrtStatusPtr (*ModelMetadataGetGraphDescription)(const OrtModelMetadata *, OrtAllocator *, char **);
 *     OrtStatusPtr (*SessionOptionsAppendExecutionProvider_TensorRT)(OrtSessionOptions *, const OrtTensorRTProviderOptions *);
 *     OrtStatusPtr (*SetCurrentGpuDeviceId)(int);
 *     OrtStatusPtr (*GetCurrentGpuDeviceId)(int *);
 *     OrtStatusPtr (*KernelInfoGetAttributeArray_float)(const OrtKernelInfo *, const char *, float *, size_t *);
 *     OrtStatusPtr (*KernelInfoGetAttributeArray_int64)(const OrtKernelInfo *, const char *, int64_t *, size_t *);
 *     OrtStatusPtr (*CreateArenaCfgV2)(const char *const *, const size_t *, size_t, OrtArenaCfg **);
 *     OrtStatusPtr (*AddRunConfigEntry)(OrtRunOptions *, const char *, const char *);
 *     OrtStatusPtr (*CreatePrepackedWeightsContainer)(OrtPrepackedWeightsContainer **);
 *     void (*ReleasePrepackedWeightsContainer)(OrtPrepackedWeightsContainer *);
 *     OrtStatusPtr (*CreateSessionWithPrepackedWeightsContainer)(const OrtEnv *, const char *, const OrtSessionOptions *, OrtPrepackedWeightsContainer *, OrtSession **);
 *     OrtStatusPtr (*CreateSessionFromArrayWithPrepackedWeightsContainer)(const OrtEnv *, const void *, size_t, const OrtSessionOptions *, OrtPrepackedWeightsContainer *, OrtSession **);
 *     OrtStatusPtr (*SessionOptionsAppendExecutionProvider_TensorRT_V2)(OrtSessionOptions *, const OrtTensorRTProviderOptionsV2 *);
 *     OrtStatusPtr (*CreateTensorRTProviderOptions)(OrtTensorRTProviderOptionsV2 **);
 *     OrtStatusPtr (*UpdateTensorRTProviderOptions)(OrtTensorRTProviderOptionsV2 *, const char *const *, const char *const *, size_t);
 *     OrtStatusPtr (*GetTensorRTProviderOptionsAsString)(const OrtTensorRTProviderOptionsV2 *, OrtAllocator *, char **);
 *     void (*ReleaseTensorRTProviderOptions)(OrtTensorRTProviderOptionsV2 *);
 *     OrtStatusPtr (*EnableOrtCustomOps)(OrtSessionOptions *);
 *     OrtStatusPtr (*RegisterAllocator)(OrtEnv *, OrtAllocator *);
 *     OrtStatusPtr (*UnregisterAllocator)(OrtEnv *, const OrtMemoryInfo *);
 *     OrtStatusPtr (*IsSparseTensor)(const OrtValue *, int *);
 *     OrtStatusPtr (*CreateSparseTensorAsOrtValue)(OrtAllocator *, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **);
 *     OrtStatusPtr (*FillSparseTensorCoo)(OrtValue *, const OrtMemoryInfo *, const int64_t *, size_t, const void *, const int64_t *, size_t);
 *     OrtStatusPtr (*FillSparseTensorCsr)(OrtValue *, const OrtMemoryInfo *, const int64_t *, size_t, const void *, const int64_t *, size_t, const int64_t *, size_t);
 *     OrtStatusPtr (*FillSparseTensorBlockSparse)(OrtValue *, const OrtMemoryInfo *, const int64_t *, size_t, const void *, const int64_t *, size_t, const int32_t *);
 *     OrtStatusPtr (*CreateSparseTensorWithValuesAsOrtValue)(const OrtMemoryInfo *, void *, const int64_t *, size_t, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **);
 *     OrtStatusPtr (*UseCooIndices)(OrtValue *, int64_t *, size_t);
 *     OrtStatusPtr (*UseCsrIndices)(OrtValue *, int64_t *, size_t, int64_t *, size_t);
 *     OrtStatusPtr (*UseBlockSparseIndices)(OrtValue *, const int64_t *, size_t, int32_t *);
 *     OrtStatusPtr (*GetSparseTensorFormat)(const OrtValue *, enum OrtSparseFormat *);
 *     OrtStatusPtr (*GetSparseTensorValuesTypeAndShape)(const OrtValue *, OrtTensorTypeAndShapeInfo **);
 *     OrtStatusPtr (*GetSparseTensorValues)(const OrtValue *, const void **);
 *     OrtStatusPtr (*GetSparseTensorIndicesTypeShape)(const OrtValue *, enum OrtSparseIndicesFormat, OrtTensorTypeAndShapeInfo **);
 *     OrtStatusPtr (*GetSparseTensorIndices)(const OrtValue *, enum OrtSparseIndicesFormat, size_t *, const void **);
 *     OrtStatusPtr (*HasValue)(const OrtValue *, int *);
 *     OrtStatusPtr (*KernelContext_GetGPUComputeStream)(const OrtKernelContext *, void **);
 *     OrtStatusPtr (*GetTensorMemoryInfo)(const OrtValue *, const OrtMemoryInfo **);
 *     OrtStatusPtr (*GetExecutionProviderApi)(const char *, uint32_t, const void **);
 *     OrtStatusPtr (*SessionOptionsSetCustomCreateThreadFn)(OrtSessionOptions *, OrtCustomCreateThreadFn);
 *     OrtStatusPtr (*SessionOptionsSetCustomThreadCreationOptions)(OrtSessionOptions *, void *);
 *     OrtStatusPtr (*SessionOptionsSetCustomJoinThreadFn)(OrtSessionOptions *, OrtCustomJoinThreadFn);
 *     OrtStatusPtr (*SetGlobalCustomCreateThreadFn)(OrtThreadingOptions *, OrtCustomCreateThreadFn);
 *     OrtStatusPtr (*SetGlobalCustomThreadCreationOptions)(OrtThreadingOptions *, void *);
 *     OrtStatusPtr (*SetGlobalCustomJoinThreadFn)(OrtThreadingOptions *, OrtCustomJoinThreadFn);
 *     OrtStatusPtr (*SynchronizeBoundInputs)(OrtIoBinding *);
 *     OrtStatusPtr (*SynchronizeBoundOutputs)(OrtIoBinding *);
 *     OrtStatusPtr (*SessionOptionsAppendExecutionProvider_CUDA_V2)(OrtSessionOptions *, const OrtCUDAProviderOptionsV2 *);
 *     OrtStatusPtr (*CreateCUDAProviderOptions)(OrtCUDAProviderOptionsV2 **);
 *     OrtStatusPtr (*UpdateCUDAProviderOptions)(OrtCUDAProviderOptionsV2 *, const char *const *, const char *const *, size_t);
 *     OrtStatusPtr (*GetCUDAProviderOptionsAsString)(const OrtCUDAProviderOptionsV2 *, OrtAllocator *, char **);
 *     void (*ReleaseCUDAProviderOptions)(OrtCUDAProviderOptionsV2 *);
 *     OrtStatusPtr (*SessionOptionsAppendExecutionProvider_MIGraphX)(OrtSessionOptions *, const OrtMIGraphXProviderOptions *);
 *     OrtStatusPtr (*AddExternalInitializers)(OrtSessionOptions *, const char *const *, const OrtValue *const *, size_t);
 *     OrtStatusPtr (*CreateOpAttr)(const char *, const void *, int, OrtOpAttrType, OrtOpAttr **);
 *     void (*ReleaseOpAttr)(OrtOpAttr *);
 *     OrtStatusPtr (*CreateOp)(const OrtKernelInfo *, const char *, const char *, int, const char **, const ONNXTensorElementDataType *, int, const OrtOpAttr *const *, int, int, int, OrtOp **);
 *     OrtStatusPtr (*InvokeOp)(const OrtKernelContext *, const OrtOp *, const OrtValue *const *, int, OrtValue *const *, int);
 *     void (*ReleaseOp)(OrtOp *);
 *     OrtStatusPtr (*SessionOptionsAppendExecutionProvider)(OrtSessionOptions *, const char *, const char *const *, const char *const *, size_t);
 *     OrtStatusPtr (*CopyKernelInfo)(const OrtKernelInfo *, OrtKernelInfo **);
 *     void (*ReleaseKernelInfo)(OrtKernelInfo *);
 *     const OrtTrainingApi *(*GetTrainingApi)(uint32_t);
 *     OrtStatusPtr (*SessionOptionsAppendExecutionProvider_CANN)(OrtSessionOptions *, const OrtCANNProviderOptions *);
 *     OrtStatusPtr (*CreateCANNProviderOptions)(OrtCANNProviderOptions **);
 *     OrtStatusPtr (*UpdateCANNProviderOptions)(OrtCANNProviderOptions *, const char *const *, const char *const *, size_t);
 *     OrtStatusPtr (*GetCANNProviderOptionsAsString)(const OrtCANNProviderOptions *, OrtAllocator *, char **);
 *     void (*ReleaseCANNProviderOptions)(OrtCANNProviderOptions *);
 *     void (*MemoryInfoGetDeviceType)(const OrtMemoryInfo *, OrtMemoryInfoDeviceType *);
 *     OrtStatusPtr (*UpdateEnvWithCustomLogLevel)(OrtEnv *, OrtLoggingLevel);
 *     OrtStatusPtr (*SetGlobalIntraOpThreadAffinity)(OrtThreadingOptions *, const char *);
 *     OrtStatusPtr (*RegisterCustomOpsLibrary_V2)(OrtSessionOptions *, const char *);
 *     OrtStatusPtr (*RegisterCustomOpsUsingFunction)(OrtSessionOptions *, const char *);
 *     OrtStatusPtr (*KernelInfo_GetInputCount)(const OrtKernelInfo *, size_t *);
 *     OrtStatusPtr (*KernelInfo_GetOutputCount)(const OrtKernelInfo *, size_t *);
 *     OrtStatusPtr (*KernelInfo_GetInputName)(const OrtKernelInfo *, size_t, char *, size_t *);
 *     OrtStatusPtr (*KernelInfo_GetOutputName)(const OrtKernelInfo *, size_t, char *, size_t *);
 *     OrtStatusPtr (*KernelInfo_GetInputTypeInfo)(const OrtKernelInfo *, size_t, OrtTypeInfo **);
 *     OrtStatusPtr (*KernelInfo_GetOutputTypeInfo)(const OrtKernelInfo *, size_t, OrtTypeInfo **);
 *     OrtStatusPtr (*KernelInfoGetAttribute_tensor)(const OrtKernelInfo *, const char *, OrtAllocator *, OrtValue **);
 *     OrtStatusPtr (*HasSessionConfigEntry)(const OrtSessionOptions *, const char *, int *);
 *     OrtStatusPtr (*GetSessionConfigEntry)(const OrtSessionOptions *, const char *, char *, size_t *);
 *     OrtStatusPtr (*SessionOptionsAppendExecutionProvider_Dnnl)(OrtSessionOptions *, const OrtDnnlProviderOptions *);
 *     OrtStatusPtr (*CreateDnnlProviderOptions)(OrtDnnlProviderOptions **);
 *     OrtStatusPtr (*UpdateDnnlProviderOptions)(OrtDnnlProviderOptions *, const char *const *, const char *const *, size_t);
 *     OrtStatusPtr (*GetDnnlProviderOptionsAsString)(const OrtDnnlProviderOptions *, OrtAllocator *, char **);
 *     void (*ReleaseDnnlProviderOptions)(OrtDnnlProviderOptions *);
 *     OrtStatusPtr (*KernelInfo_GetNodeName)(const OrtKernelInfo *, char *, size_t *);
 *     OrtStatusPtr (*KernelInfo_GetLogger)(const OrtKernelInfo *, const OrtLogger **);
 *     OrtStatusPtr (*KernelContext_GetLogger)(const OrtKernelContext *, const OrtLogger **);
 *     OrtStatusPtr (*Logger_LogMessage)(const OrtLogger *, OrtLoggingLevel, const char *, const char *, int, const char *);
 *     OrtStatusPtr (*Logger_GetLoggingSeverityLevel)(const OrtLogger *, OrtLoggingLevel *);
 *     OrtStatusPtr (*KernelInfoGetConstantInput_tensor)(const OrtKernelInfo *, size_t, int *, const OrtValue **);
 *     OrtStatusPtr (*CastTypeInfoToOptionalTypeInfo)(const OrtTypeInfo *, const OrtOptionalTypeInfo **);
 *     OrtStatusPtr (*GetOptionalContainedTypeInfo)(const OrtOptionalTypeInfo *, OrtTypeInfo **);
 *     OrtStatusPtr (*GetResizedStringTensorElementBuffer)(OrtValue *, size_t, size_t, char **);
 *     OrtStatusPtr (*KernelContext_GetAllocator)(const OrtKernelContext *, const OrtMemoryInfo *, OrtAllocator **);
 *     const char *(*GetBuildInfoString)(void);
 *     OrtStatusPtr (*CreateROCMProviderOptions)(OrtROCMProviderOptions **);
 *     OrtStatusPtr (*UpdateROCMProviderOptions)(OrtROCMProviderOptions *, const char *const *, const char *const *, size_t);
 *     OrtStatusPtr (*GetROCMProviderOptionsAsString)(const OrtROCMProviderOptions *, OrtAllocator *, char **);
 *     void (*ReleaseROCMProviderOptions)(OrtROCMProviderOptions *);
 *     OrtStatusPtr (*CreateAndRegisterAllocatorV2)(OrtEnv *, const char *, const OrtMemoryInfo *, const OrtArenaCfg *, const char *const *, const char *const *, size_t);
 *     OrtStatusPtr (*RunAsync)(OrtSession *, const OrtRunOptions *, const char *const *, const OrtValue *const *, size_t, const char *const *, size_t, OrtValue **, RunAsyncCallbackFn, void *);
 *     OrtStatusPtr (*UpdateTensorRTProviderOptionsWithValue)(OrtTensorRTProviderOptionsV2 *, const char *, void *);
 *     OrtStatusPtr (*GetTensorRTProviderOptionsByName)(const OrtTensorRTProviderOptionsV2 *, const char *, void **);
 *     OrtStatusPtr (*UpdateCUDAProviderOptionsWithValue)(OrtCUDAProviderOptionsV2 *, const char *, void *);
 *     OrtStatusPtr (*GetCUDAProviderOptionsByName)(const OrtCUDAProviderOptionsV2 *, const char *, void **);
 *     OrtStatusPtr (*KernelContext_GetResource)(const OrtKernelContext *, int, int, void **);
 *     OrtStatusPtr (*SetUserLoggingFunction)(OrtSessionOptions *, OrtLoggingFunction, void *);
 *     OrtStatusPtr (*ShapeInferContext_GetInputCount)(const OrtShapeInferContext *, size_t *);
 *     OrtStatusPtr (*ShapeInferContext_GetInputTypeShape)(const OrtShapeInferContext *, size_t, OrtTensorTypeAndShapeInfo **);
 *     OrtStatusPtr (*ShapeInferContext_GetAttribute)(const OrtShapeInferContext *, const char *, const OrtOpAttr **);
 *     OrtStatusPtr (*ShapeInferContext_SetOutputTypeShape)(const OrtShapeInferContext *, size_t, const OrtTensorTypeAndShapeInfo *);
 *     OrtStatusPtr (*SetSymbolicDimensions)(OrtTensorTypeAndShapeInfo *, const char **, size_t);
 *     OrtStatusPtr (*ReadOpAttr)(const OrtOpAttr *, OrtOpAttrType, void *, size_t, size_t *);
 *     OrtStatusPtr (*SetDeterministicCompute)(OrtSessionOptions *, bool);
 *     OrtStatusPtr (*KernelContext_ParallelFor)(const OrtKernelContext *, void (*)(void *, size_t), size_t, size_t, void *);
 *     OrtStatusPtr (*SessionOptionsAppendExecutionProvider_OpenVINO_V2)(OrtSessionOptions *, const char *const *, const char *const *, size_t);
 *     OrtStatusPtr (*SessionOptionsAppendExecutionProvider_VitisAI)(OrtSessionOptions *, const char *const *, const char *const *, size_t);
 *     OrtStatusPtr (*KernelContext_GetScratchBuffer)(const OrtKernelContext *, const OrtMemoryInfo *, size_t, void **);
 *     OrtStatusPtr (*KernelInfoGetAllocator)(const OrtKernelInfo *, OrtMemType, OrtAllocator **);
 *     OrtStatusPtr (*AddExternalInitializersFromFilesInMemory)(OrtSessionOptions *, const char *const *, char *const *, const size_t *, size_t);
 *     OrtStatusPtr (*CreateLoraAdapter)(const char *, OrtAllocator *, OrtLoraAdapter **);
 *     OrtStatusPtr (*CreateLoraAdapterFromArray)(const void *, size_t, OrtAllocator *, OrtLoraAdapter **);
 *     void (*ReleaseLoraAdapter)(OrtLoraAdapter *);
 *     OrtStatusPtr (*RunOptionsAddActiveLoraAdapter)(OrtRunOptions *, const OrtLoraAdapter *);
 *     OrtStatusPtr (*SetEpDynamicOptions)(OrtSession *, const char *const *, const char *const *, size_t);
 * }
 * }
 */
public class OrtApi {

    OrtApi() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
                    onnxruntime_all_h.C_POINTER.withName("CreateStatus"),
                    onnxruntime_all_h.C_POINTER.withName("GetErrorCode"),
                    onnxruntime_all_h.C_POINTER.withName("GetErrorMessage"),
                    onnxruntime_all_h.C_POINTER.withName("CreateEnv"),
                    onnxruntime_all_h.C_POINTER.withName("CreateEnvWithCustomLogger"),
                    onnxruntime_all_h.C_POINTER.withName("EnableTelemetryEvents"),
                    onnxruntime_all_h.C_POINTER.withName("DisableTelemetryEvents"),
                    onnxruntime_all_h.C_POINTER.withName("CreateSession"),
                    onnxruntime_all_h.C_POINTER.withName("CreateSessionFromArray"),
                    onnxruntime_all_h.C_POINTER.withName("Run"),
                    onnxruntime_all_h.C_POINTER.withName("CreateSessionOptions"),
                    onnxruntime_all_h.C_POINTER.withName("SetOptimizedModelFilePath"),
                    onnxruntime_all_h.C_POINTER.withName("CloneSessionOptions"),
                    onnxruntime_all_h.C_POINTER.withName("SetSessionExecutionMode"),
                    onnxruntime_all_h.C_POINTER.withName("EnableProfiling"),
                    onnxruntime_all_h.C_POINTER.withName("DisableProfiling"),
                    onnxruntime_all_h.C_POINTER.withName("EnableMemPattern"),
                    onnxruntime_all_h.C_POINTER.withName("DisableMemPattern"),
                    onnxruntime_all_h.C_POINTER.withName("EnableCpuMemArena"),
                    onnxruntime_all_h.C_POINTER.withName("DisableCpuMemArena"),
                    onnxruntime_all_h.C_POINTER.withName("SetSessionLogId"),
                    onnxruntime_all_h.C_POINTER.withName("SetSessionLogVerbosityLevel"),
                    onnxruntime_all_h.C_POINTER.withName("SetSessionLogSeverityLevel"),
                    onnxruntime_all_h.C_POINTER.withName("SetSessionGraphOptimizationLevel"),
                    onnxruntime_all_h.C_POINTER.withName("SetIntraOpNumThreads"),
                    onnxruntime_all_h.C_POINTER.withName("SetInterOpNumThreads"),
                    onnxruntime_all_h.C_POINTER.withName("CreateCustomOpDomain"),
                    onnxruntime_all_h.C_POINTER.withName("CustomOpDomain_Add"),
                    onnxruntime_all_h.C_POINTER.withName("AddCustomOpDomain"),
                    onnxruntime_all_h.C_POINTER.withName("RegisterCustomOpsLibrary"),
                    onnxruntime_all_h.C_POINTER.withName("SessionGetInputCount"),
                    onnxruntime_all_h.C_POINTER.withName("SessionGetOutputCount"),
                    onnxruntime_all_h.C_POINTER.withName("SessionGetOverridableInitializerCount"),
                    onnxruntime_all_h.C_POINTER.withName("SessionGetInputTypeInfo"),
                    onnxruntime_all_h.C_POINTER.withName("SessionGetOutputTypeInfo"),
                    onnxruntime_all_h.C_POINTER.withName("SessionGetOverridableInitializerTypeInfo"),
                    onnxruntime_all_h.C_POINTER.withName("SessionGetInputName"),
                    onnxruntime_all_h.C_POINTER.withName("SessionGetOutputName"),
                    onnxruntime_all_h.C_POINTER.withName("SessionGetOverridableInitializerName"),
                    onnxruntime_all_h.C_POINTER.withName("CreateRunOptions"),
                    onnxruntime_all_h.C_POINTER.withName("RunOptionsSetRunLogVerbosityLevel"),
                    onnxruntime_all_h.C_POINTER.withName("RunOptionsSetRunLogSeverityLevel"),
                    onnxruntime_all_h.C_POINTER.withName("RunOptionsSetRunTag"),
                    onnxruntime_all_h.C_POINTER.withName("RunOptionsGetRunLogVerbosityLevel"),
                    onnxruntime_all_h.C_POINTER.withName("RunOptionsGetRunLogSeverityLevel"),
                    onnxruntime_all_h.C_POINTER.withName("RunOptionsGetRunTag"),
                    onnxruntime_all_h.C_POINTER.withName("RunOptionsSetTerminate"),
                    onnxruntime_all_h.C_POINTER.withName("RunOptionsUnsetTerminate"),
                    onnxruntime_all_h.C_POINTER.withName("CreateTensorAsOrtValue"),
                    onnxruntime_all_h.C_POINTER.withName("CreateTensorWithDataAsOrtValue"),
                    onnxruntime_all_h.C_POINTER.withName("IsTensor"),
                    onnxruntime_all_h.C_POINTER.withName("GetTensorMutableData"),
                    onnxruntime_all_h.C_POINTER.withName("FillStringTensor"),
                    onnxruntime_all_h.C_POINTER.withName("GetStringTensorDataLength"),
                    onnxruntime_all_h.C_POINTER.withName("GetStringTensorContent"),
                    onnxruntime_all_h.C_POINTER.withName("CastTypeInfoToTensorInfo"),
                    onnxruntime_all_h.C_POINTER.withName("GetOnnxTypeFromTypeInfo"),
                    onnxruntime_all_h.C_POINTER.withName("CreateTensorTypeAndShapeInfo"),
                    onnxruntime_all_h.C_POINTER.withName("SetTensorElementType"),
                    onnxruntime_all_h.C_POINTER.withName("SetDimensions"),
                    onnxruntime_all_h.C_POINTER.withName("GetTensorElementType"),
                    onnxruntime_all_h.C_POINTER.withName("GetDimensionsCount"),
                    onnxruntime_all_h.C_POINTER.withName("GetDimensions"),
                    onnxruntime_all_h.C_POINTER.withName("GetSymbolicDimensions"),
                    onnxruntime_all_h.C_POINTER.withName("GetTensorShapeElementCount"),
                    onnxruntime_all_h.C_POINTER.withName("GetTensorTypeAndShape"),
                    onnxruntime_all_h.C_POINTER.withName("GetTypeInfo"),
                    onnxruntime_all_h.C_POINTER.withName("GetValueType"),
                    onnxruntime_all_h.C_POINTER.withName("CreateMemoryInfo"),
                    onnxruntime_all_h.C_POINTER.withName("CreateCpuMemoryInfo"),
                    onnxruntime_all_h.C_POINTER.withName("CompareMemoryInfo"),
                    onnxruntime_all_h.C_POINTER.withName("MemoryInfoGetName"),
                    onnxruntime_all_h.C_POINTER.withName("MemoryInfoGetId"),
                    onnxruntime_all_h.C_POINTER.withName("MemoryInfoGetMemType"),
                    onnxruntime_all_h.C_POINTER.withName("MemoryInfoGetType"),
                    onnxruntime_all_h.C_POINTER.withName("AllocatorAlloc"),
                    onnxruntime_all_h.C_POINTER.withName("AllocatorFree"),
                    onnxruntime_all_h.C_POINTER.withName("AllocatorGetInfo"),
                    onnxruntime_all_h.C_POINTER.withName("GetAllocatorWithDefaultOptions"),
                    onnxruntime_all_h.C_POINTER.withName("AddFreeDimensionOverride"),
                    onnxruntime_all_h.C_POINTER.withName("GetValue"),
                    onnxruntime_all_h.C_POINTER.withName("GetValueCount"),
                    onnxruntime_all_h.C_POINTER.withName("CreateValue"),
                    onnxruntime_all_h.C_POINTER.withName("CreateOpaqueValue"),
                    onnxruntime_all_h.C_POINTER.withName("GetOpaqueValue"),
                    onnxruntime_all_h.C_POINTER.withName("KernelInfoGetAttribute_float"),
                    onnxruntime_all_h.C_POINTER.withName("KernelInfoGetAttribute_int64"),
                    onnxruntime_all_h.C_POINTER.withName("KernelInfoGetAttribute_string"),
                    onnxruntime_all_h.C_POINTER.withName("KernelContext_GetInputCount"),
                    onnxruntime_all_h.C_POINTER.withName("KernelContext_GetOutputCount"),
                    onnxruntime_all_h.C_POINTER.withName("KernelContext_GetInput"),
                    onnxruntime_all_h.C_POINTER.withName("KernelContext_GetOutput"),
                    onnxruntime_all_h.C_POINTER.withName("ReleaseEnv"),
                    onnxruntime_all_h.C_POINTER.withName("ReleaseStatus"),
                    onnxruntime_all_h.C_POINTER.withName("ReleaseMemoryInfo"),
                    onnxruntime_all_h.C_POINTER.withName("ReleaseSession"),
                    onnxruntime_all_h.C_POINTER.withName("ReleaseValue"),
                    onnxruntime_all_h.C_POINTER.withName("ReleaseRunOptions"),
                    onnxruntime_all_h.C_POINTER.withName("ReleaseTypeInfo"),
                    onnxruntime_all_h.C_POINTER.withName("ReleaseTensorTypeAndShapeInfo"),
                    onnxruntime_all_h.C_POINTER.withName("ReleaseSessionOptions"),
                    onnxruntime_all_h.C_POINTER.withName("ReleaseCustomOpDomain"),
                    onnxruntime_all_h.C_POINTER.withName("GetDenotationFromTypeInfo"),
                    onnxruntime_all_h.C_POINTER.withName("CastTypeInfoToMapTypeInfo"),
                    onnxruntime_all_h.C_POINTER.withName("CastTypeInfoToSequenceTypeInfo"),
                    onnxruntime_all_h.C_POINTER.withName("GetMapKeyType"),
                    onnxruntime_all_h.C_POINTER.withName("GetMapValueType"),
                    onnxruntime_all_h.C_POINTER.withName("GetSequenceElementType"),
                    onnxruntime_all_h.C_POINTER.withName("ReleaseMapTypeInfo"),
                    onnxruntime_all_h.C_POINTER.withName("ReleaseSequenceTypeInfo"),
                    onnxruntime_all_h.C_POINTER.withName("SessionEndProfiling"),
                    onnxruntime_all_h.C_POINTER.withName("SessionGetModelMetadata"),
                    onnxruntime_all_h.C_POINTER.withName("ModelMetadataGetProducerName"),
                    onnxruntime_all_h.C_POINTER.withName("ModelMetadataGetGraphName"),
                    onnxruntime_all_h.C_POINTER.withName("ModelMetadataGetDomain"),
                    onnxruntime_all_h.C_POINTER.withName("ModelMetadataGetDescription"),
                    onnxruntime_all_h.C_POINTER.withName("ModelMetadataLookupCustomMetadataMap"),
                    onnxruntime_all_h.C_POINTER.withName("ModelMetadataGetVersion"),
                    onnxruntime_all_h.C_POINTER.withName("ReleaseModelMetadata"),
                    onnxruntime_all_h.C_POINTER.withName("CreateEnvWithGlobalThreadPools"),
                    onnxruntime_all_h.C_POINTER.withName("DisablePerSessionThreads"),
                    onnxruntime_all_h.C_POINTER.withName("CreateThreadingOptions"),
                    onnxruntime_all_h.C_POINTER.withName("ReleaseThreadingOptions"),
                    onnxruntime_all_h.C_POINTER.withName("ModelMetadataGetCustomMetadataMapKeys"),
                    onnxruntime_all_h.C_POINTER.withName("AddFreeDimensionOverrideByName"),
                    onnxruntime_all_h.C_POINTER.withName("GetAvailableProviders"),
                    onnxruntime_all_h.C_POINTER.withName("ReleaseAvailableProviders"),
                    onnxruntime_all_h.C_POINTER.withName("GetStringTensorElementLength"),
                    onnxruntime_all_h.C_POINTER.withName("GetStringTensorElement"),
                    onnxruntime_all_h.C_POINTER.withName("FillStringTensorElement"),
                    onnxruntime_all_h.C_POINTER.withName("AddSessionConfigEntry"),
                    onnxruntime_all_h.C_POINTER.withName("CreateAllocator"),
                    onnxruntime_all_h.C_POINTER.withName("ReleaseAllocator"),
                    onnxruntime_all_h.C_POINTER.withName("RunWithBinding"),
                    onnxruntime_all_h.C_POINTER.withName("CreateIoBinding"),
                    onnxruntime_all_h.C_POINTER.withName("ReleaseIoBinding"),
                    onnxruntime_all_h.C_POINTER.withName("BindInput"),
                    onnxruntime_all_h.C_POINTER.withName("BindOutput"),
                    onnxruntime_all_h.C_POINTER.withName("BindOutputToDevice"),
                    onnxruntime_all_h.C_POINTER.withName("GetBoundOutputNames"),
                    onnxruntime_all_h.C_POINTER.withName("GetBoundOutputValues"),
                    onnxruntime_all_h.C_POINTER.withName("ClearBoundInputs"),
                    onnxruntime_all_h.C_POINTER.withName("ClearBoundOutputs"),
                    onnxruntime_all_h.C_POINTER.withName("TensorAt"),
                    onnxruntime_all_h.C_POINTER.withName("CreateAndRegisterAllocator"),
                    onnxruntime_all_h.C_POINTER.withName("SetLanguageProjection"),
                    onnxruntime_all_h.C_POINTER.withName("SessionGetProfilingStartTimeNs"),
                    onnxruntime_all_h.C_POINTER.withName("SetGlobalIntraOpNumThreads"),
                    onnxruntime_all_h.C_POINTER.withName("SetGlobalInterOpNumThreads"),
                    onnxruntime_all_h.C_POINTER.withName("SetGlobalSpinControl"),
                    onnxruntime_all_h.C_POINTER.withName("AddInitializer"),
                    onnxruntime_all_h.C_POINTER.withName("CreateEnvWithCustomLoggerAndGlobalThreadPools"),
                    onnxruntime_all_h.C_POINTER.withName("SessionOptionsAppendExecutionProvider_CUDA"),
                    onnxruntime_all_h.C_POINTER.withName("SessionOptionsAppendExecutionProvider_ROCM"),
                    onnxruntime_all_h.C_POINTER.withName("SessionOptionsAppendExecutionProvider_OpenVINO"),
                    onnxruntime_all_h.C_POINTER.withName("SetGlobalDenormalAsZero"),
                    onnxruntime_all_h.C_POINTER.withName("CreateArenaCfg"),
                    onnxruntime_all_h.C_POINTER.withName("ReleaseArenaCfg"),
                    onnxruntime_all_h.C_POINTER.withName("ModelMetadataGetGraphDescription"),
                    onnxruntime_all_h.C_POINTER.withName("SessionOptionsAppendExecutionProvider_TensorRT"),
                    onnxruntime_all_h.C_POINTER.withName("SetCurrentGpuDeviceId"),
                    onnxruntime_all_h.C_POINTER.withName("GetCurrentGpuDeviceId"),
                    onnxruntime_all_h.C_POINTER.withName("KernelInfoGetAttributeArray_float"),
                    onnxruntime_all_h.C_POINTER.withName("KernelInfoGetAttributeArray_int64"),
                    onnxruntime_all_h.C_POINTER.withName("CreateArenaCfgV2"),
                    onnxruntime_all_h.C_POINTER.withName("AddRunConfigEntry"),
                    onnxruntime_all_h.C_POINTER.withName("CreatePrepackedWeightsContainer"),
                    onnxruntime_all_h.C_POINTER.withName("ReleasePrepackedWeightsContainer"),
                    onnxruntime_all_h.C_POINTER.withName("CreateSessionWithPrepackedWeightsContainer"),
                    onnxruntime_all_h.C_POINTER.withName("CreateSessionFromArrayWithPrepackedWeightsContainer"),
                    onnxruntime_all_h.C_POINTER.withName("SessionOptionsAppendExecutionProvider_TensorRT_V2"),
                    onnxruntime_all_h.C_POINTER.withName("CreateTensorRTProviderOptions"),
                    onnxruntime_all_h.C_POINTER.withName("UpdateTensorRTProviderOptions"),
                    onnxruntime_all_h.C_POINTER.withName("GetTensorRTProviderOptionsAsString"),
                    onnxruntime_all_h.C_POINTER.withName("ReleaseTensorRTProviderOptions"),
                    onnxruntime_all_h.C_POINTER.withName("EnableOrtCustomOps"),
                    onnxruntime_all_h.C_POINTER.withName("RegisterAllocator"),
                    onnxruntime_all_h.C_POINTER.withName("UnregisterAllocator"),
                    onnxruntime_all_h.C_POINTER.withName("IsSparseTensor"),
                    onnxruntime_all_h.C_POINTER.withName("CreateSparseTensorAsOrtValue"),
                    onnxruntime_all_h.C_POINTER.withName("FillSparseTensorCoo"),
                    onnxruntime_all_h.C_POINTER.withName("FillSparseTensorCsr"),
                    onnxruntime_all_h.C_POINTER.withName("FillSparseTensorBlockSparse"),
                    onnxruntime_all_h.C_POINTER.withName("CreateSparseTensorWithValuesAsOrtValue"),
                    onnxruntime_all_h.C_POINTER.withName("UseCooIndices"),
                    onnxruntime_all_h.C_POINTER.withName("UseCsrIndices"),
                    onnxruntime_all_h.C_POINTER.withName("UseBlockSparseIndices"),
                    onnxruntime_all_h.C_POINTER.withName("GetSparseTensorFormat"),
                    onnxruntime_all_h.C_POINTER.withName("GetSparseTensorValuesTypeAndShape"),
                    onnxruntime_all_h.C_POINTER.withName("GetSparseTensorValues"),
                    onnxruntime_all_h.C_POINTER.withName("GetSparseTensorIndicesTypeShape"),
                    onnxruntime_all_h.C_POINTER.withName("GetSparseTensorIndices"),
                    onnxruntime_all_h.C_POINTER.withName("HasValue"),
                    onnxruntime_all_h.C_POINTER.withName("KernelContext_GetGPUComputeStream"),
                    onnxruntime_all_h.C_POINTER.withName("GetTensorMemoryInfo"),
                    onnxruntime_all_h.C_POINTER.withName("GetExecutionProviderApi"),
                    onnxruntime_all_h.C_POINTER.withName("SessionOptionsSetCustomCreateThreadFn"),
                    onnxruntime_all_h.C_POINTER.withName("SessionOptionsSetCustomThreadCreationOptions"),
                    onnxruntime_all_h.C_POINTER.withName("SessionOptionsSetCustomJoinThreadFn"),
                    onnxruntime_all_h.C_POINTER.withName("SetGlobalCustomCreateThreadFn"),
                    onnxruntime_all_h.C_POINTER.withName("SetGlobalCustomThreadCreationOptions"),
                    onnxruntime_all_h.C_POINTER.withName("SetGlobalCustomJoinThreadFn"),
                    onnxruntime_all_h.C_POINTER.withName("SynchronizeBoundInputs"),
                    onnxruntime_all_h.C_POINTER.withName("SynchronizeBoundOutputs"),
                    onnxruntime_all_h.C_POINTER.withName("SessionOptionsAppendExecutionProvider_CUDA_V2"),
                    onnxruntime_all_h.C_POINTER.withName("CreateCUDAProviderOptions"),
                    onnxruntime_all_h.C_POINTER.withName("UpdateCUDAProviderOptions"),
                    onnxruntime_all_h.C_POINTER.withName("GetCUDAProviderOptionsAsString"),
                    onnxruntime_all_h.C_POINTER.withName("ReleaseCUDAProviderOptions"),
                    onnxruntime_all_h.C_POINTER.withName("SessionOptionsAppendExecutionProvider_MIGraphX"),
                    onnxruntime_all_h.C_POINTER.withName("AddExternalInitializers"),
                    onnxruntime_all_h.C_POINTER.withName("CreateOpAttr"),
                    onnxruntime_all_h.C_POINTER.withName("ReleaseOpAttr"),
                    onnxruntime_all_h.C_POINTER.withName("CreateOp"),
                    onnxruntime_all_h.C_POINTER.withName("InvokeOp"),
                    onnxruntime_all_h.C_POINTER.withName("ReleaseOp"),
                    onnxruntime_all_h.C_POINTER.withName("SessionOptionsAppendExecutionProvider"),
                    onnxruntime_all_h.C_POINTER.withName("CopyKernelInfo"),
                    onnxruntime_all_h.C_POINTER.withName("ReleaseKernelInfo"),
                    onnxruntime_all_h.C_POINTER.withName("GetTrainingApi"),
                    onnxruntime_all_h.C_POINTER.withName("SessionOptionsAppendExecutionProvider_CANN"),
                    onnxruntime_all_h.C_POINTER.withName("CreateCANNProviderOptions"),
                    onnxruntime_all_h.C_POINTER.withName("UpdateCANNProviderOptions"),
                    onnxruntime_all_h.C_POINTER.withName("GetCANNProviderOptionsAsString"),
                    onnxruntime_all_h.C_POINTER.withName("ReleaseCANNProviderOptions"),
                    onnxruntime_all_h.C_POINTER.withName("MemoryInfoGetDeviceType"),
                    onnxruntime_all_h.C_POINTER.withName("UpdateEnvWithCustomLogLevel"),
                    onnxruntime_all_h.C_POINTER.withName("SetGlobalIntraOpThreadAffinity"),
                    onnxruntime_all_h.C_POINTER.withName("RegisterCustomOpsLibrary_V2"),
                    onnxruntime_all_h.C_POINTER.withName("RegisterCustomOpsUsingFunction"),
                    onnxruntime_all_h.C_POINTER.withName("KernelInfo_GetInputCount"),
                    onnxruntime_all_h.C_POINTER.withName("KernelInfo_GetOutputCount"),
                    onnxruntime_all_h.C_POINTER.withName("KernelInfo_GetInputName"),
                    onnxruntime_all_h.C_POINTER.withName("KernelInfo_GetOutputName"),
                    onnxruntime_all_h.C_POINTER.withName("KernelInfo_GetInputTypeInfo"),
                    onnxruntime_all_h.C_POINTER.withName("KernelInfo_GetOutputTypeInfo"),
                    onnxruntime_all_h.C_POINTER.withName("KernelInfoGetAttribute_tensor"),
                    onnxruntime_all_h.C_POINTER.withName("HasSessionConfigEntry"),
                    onnxruntime_all_h.C_POINTER.withName("GetSessionConfigEntry"),
                    onnxruntime_all_h.C_POINTER.withName("SessionOptionsAppendExecutionProvider_Dnnl"),
                    onnxruntime_all_h.C_POINTER.withName("CreateDnnlProviderOptions"),
                    onnxruntime_all_h.C_POINTER.withName("UpdateDnnlProviderOptions"),
                    onnxruntime_all_h.C_POINTER.withName("GetDnnlProviderOptionsAsString"),
                    onnxruntime_all_h.C_POINTER.withName("ReleaseDnnlProviderOptions"),
                    onnxruntime_all_h.C_POINTER.withName("KernelInfo_GetNodeName"),
                    onnxruntime_all_h.C_POINTER.withName("KernelInfo_GetLogger"),
                    onnxruntime_all_h.C_POINTER.withName("KernelContext_GetLogger"),
                    onnxruntime_all_h.C_POINTER.withName("Logger_LogMessage"),
                    onnxruntime_all_h.C_POINTER.withName("Logger_GetLoggingSeverityLevel"),
                    onnxruntime_all_h.C_POINTER.withName("KernelInfoGetConstantInput_tensor"),
                    onnxruntime_all_h.C_POINTER.withName("CastTypeInfoToOptionalTypeInfo"),
                    onnxruntime_all_h.C_POINTER.withName("GetOptionalContainedTypeInfo"),
                    onnxruntime_all_h.C_POINTER.withName("GetResizedStringTensorElementBuffer"),
                    onnxruntime_all_h.C_POINTER.withName("KernelContext_GetAllocator"),
                    onnxruntime_all_h.C_POINTER.withName("GetBuildInfoString"),
                    onnxruntime_all_h.C_POINTER.withName("CreateROCMProviderOptions"),
                    onnxruntime_all_h.C_POINTER.withName("UpdateROCMProviderOptions"),
                    onnxruntime_all_h.C_POINTER.withName("GetROCMProviderOptionsAsString"),
                    onnxruntime_all_h.C_POINTER.withName("ReleaseROCMProviderOptions"),
                    onnxruntime_all_h.C_POINTER.withName("CreateAndRegisterAllocatorV2"),
                    onnxruntime_all_h.C_POINTER.withName("RunAsync"),
                    onnxruntime_all_h.C_POINTER.withName("UpdateTensorRTProviderOptionsWithValue"),
                    onnxruntime_all_h.C_POINTER.withName("GetTensorRTProviderOptionsByName"),
                    onnxruntime_all_h.C_POINTER.withName("UpdateCUDAProviderOptionsWithValue"),
                    onnxruntime_all_h.C_POINTER.withName("GetCUDAProviderOptionsByName"),
                    onnxruntime_all_h.C_POINTER.withName("KernelContext_GetResource"),
                    onnxruntime_all_h.C_POINTER.withName("SetUserLoggingFunction"),
                    onnxruntime_all_h.C_POINTER.withName("ShapeInferContext_GetInputCount"),
                    onnxruntime_all_h.C_POINTER.withName("ShapeInferContext_GetInputTypeShape"),
                    onnxruntime_all_h.C_POINTER.withName("ShapeInferContext_GetAttribute"),
                    onnxruntime_all_h.C_POINTER.withName("ShapeInferContext_SetOutputTypeShape"),
                    onnxruntime_all_h.C_POINTER.withName("SetSymbolicDimensions"),
                    onnxruntime_all_h.C_POINTER.withName("ReadOpAttr"),
                    onnxruntime_all_h.C_POINTER.withName("SetDeterministicCompute"),
                    onnxruntime_all_h.C_POINTER.withName("KernelContext_ParallelFor"),
                    onnxruntime_all_h.C_POINTER.withName("SessionOptionsAppendExecutionProvider_OpenVINO_V2"),
                    onnxruntime_all_h.C_POINTER.withName("SessionOptionsAppendExecutionProvider_VitisAI"),
                    onnxruntime_all_h.C_POINTER.withName("KernelContext_GetScratchBuffer"),
                    onnxruntime_all_h.C_POINTER.withName("KernelInfoGetAllocator"),
                    onnxruntime_all_h.C_POINTER.withName("AddExternalInitializersFromFilesInMemory"),
                    onnxruntime_all_h.C_POINTER.withName("CreateLoraAdapter"),
                    onnxruntime_all_h.C_POINTER.withName("CreateLoraAdapterFromArray"),
                    onnxruntime_all_h.C_POINTER.withName("ReleaseLoraAdapter"),
                    onnxruntime_all_h.C_POINTER.withName("RunOptionsAddActiveLoraAdapter"),
                    onnxruntime_all_h.C_POINTER.withName("SetEpDynamicOptions"))
            .withName("OrtApi");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    /**
     * {@snippet lang=c :
     * OrtStatus *(*CreateStatus)(OrtErrorCode, const char *)
     * }
     */
    public static class CreateStatus {

        CreateStatus() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(int _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_INT, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(CreateStatus.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateStatus.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, int _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static CreateStatus.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout CreateStatus$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("CreateStatus"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatus *(*CreateStatus)(OrtErrorCode, const char *)
     * }
     */
    public static final AddressLayout CreateStatus$layout() {
        return CreateStatus$LAYOUT;
    }

    private static final long CreateStatus$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatus *(*CreateStatus)(OrtErrorCode, const char *)
     * }
     */
    public static final long CreateStatus$offset() {
        return CreateStatus$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatus *(*CreateStatus)(OrtErrorCode, const char *)
     * }
     */
    public static MemorySegment CreateStatus(MemorySegment struct) {
        return struct.get(CreateStatus$LAYOUT, CreateStatus$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatus *(*CreateStatus)(OrtErrorCode, const char *)
     * }
     */
    public static void CreateStatus(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateStatus$LAYOUT, CreateStatus$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatus *(*CreateStatus)(OrtErrorCode, const char *)
     * }
     */
    public static CreateStatus.Function CreateStatusFunction(MemorySegment struct) {
        return CreateStatus.function(CreateStatus(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtErrorCode (*GetErrorCode)(const OrtStatus *)
     * }
     */
    public static class GetErrorCode {

        GetErrorCode() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            int apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC =
                FunctionDescriptor.of(onnxruntime_all_h.C_INT, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(GetErrorCode.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetErrorCode.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static int invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (int) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static GetErrorCode.Function function(MemorySegment funcPtr) {
            return (_x0) -> invoke(funcPtr, _x0);
        }
    }

    private static final AddressLayout GetErrorCode$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("GetErrorCode"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtErrorCode (*GetErrorCode)(const OrtStatus *)
     * }
     */
    public static final AddressLayout GetErrorCode$layout() {
        return GetErrorCode$LAYOUT;
    }

    private static final long GetErrorCode$OFFSET = 8;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtErrorCode (*GetErrorCode)(const OrtStatus *)
     * }
     */
    public static final long GetErrorCode$offset() {
        return GetErrorCode$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtErrorCode (*GetErrorCode)(const OrtStatus *)
     * }
     */
    public static MemorySegment GetErrorCode(MemorySegment struct) {
        return struct.get(GetErrorCode$LAYOUT, GetErrorCode$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtErrorCode (*GetErrorCode)(const OrtStatus *)
     * }
     */
    public static void GetErrorCode(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetErrorCode$LAYOUT, GetErrorCode$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtErrorCode (*GetErrorCode)(const OrtStatus *)
     * }
     */
    public static GetErrorCode.Function GetErrorCodeFunction(MemorySegment struct) {
        return GetErrorCode.function(GetErrorCode(struct));
    }

    /**
     * {@snippet lang=c :
     * const char *(*GetErrorMessage)(const OrtStatus *)
     * }
     */
    public static class GetErrorMessage {

        GetErrorMessage() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC =
                FunctionDescriptor.of(onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(GetErrorMessage.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetErrorMessage.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static GetErrorMessage.Function function(MemorySegment funcPtr) {
            return (_x0) -> invoke(funcPtr, _x0);
        }
    }

    private static final AddressLayout GetErrorMessage$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("GetErrorMessage"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * const char *(*GetErrorMessage)(const OrtStatus *)
     * }
     */
    public static final AddressLayout GetErrorMessage$layout() {
        return GetErrorMessage$LAYOUT;
    }

    private static final long GetErrorMessage$OFFSET = 16;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * const char *(*GetErrorMessage)(const OrtStatus *)
     * }
     */
    public static final long GetErrorMessage$offset() {
        return GetErrorMessage$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * const char *(*GetErrorMessage)(const OrtStatus *)
     * }
     */
    public static MemorySegment GetErrorMessage(MemorySegment struct) {
        return struct.get(GetErrorMessage$LAYOUT, GetErrorMessage$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * const char *(*GetErrorMessage)(const OrtStatus *)
     * }
     */
    public static void GetErrorMessage(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetErrorMessage$LAYOUT, GetErrorMessage$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * const char *(*GetErrorMessage)(const OrtStatus *)
     * }
     */
    public static GetErrorMessage.Function GetErrorMessageFunction(MemorySegment struct) {
        return GetErrorMessage.function(GetErrorMessage(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateEnv)(OrtLoggingLevel, const char *, OrtEnv **)
     * }
     */
    public static class CreateEnv {

        CreateEnv() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(int _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_INT,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(CreateEnv.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateEnv.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, int _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static CreateEnv.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2) -> invoke(funcPtr, _x0, _x1, _x2);
        }
    }

    private static final AddressLayout CreateEnv$LAYOUT = (AddressLayout) $LAYOUT.select(groupElement("CreateEnv"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateEnv)(OrtLoggingLevel, const char *, OrtEnv **)
     * }
     */
    public static final AddressLayout CreateEnv$layout() {
        return CreateEnv$LAYOUT;
    }

    private static final long CreateEnv$OFFSET = 24;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateEnv)(OrtLoggingLevel, const char *, OrtEnv **)
     * }
     */
    public static final long CreateEnv$offset() {
        return CreateEnv$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateEnv)(OrtLoggingLevel, const char *, OrtEnv **)
     * }
     */
    public static MemorySegment CreateEnv(MemorySegment struct) {
        return struct.get(CreateEnv$LAYOUT, CreateEnv$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateEnv)(OrtLoggingLevel, const char *, OrtEnv **)
     * }
     */
    public static void CreateEnv(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateEnv$LAYOUT, CreateEnv$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateEnv)(OrtLoggingLevel, const char *, OrtEnv **)
     * }
     */
    public static CreateEnv.Function CreateEnvFunction(MemorySegment struct) {
        return CreateEnv.function(CreateEnv(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateEnvWithCustomLogger)(OrtLoggingFunction, void *, OrtLoggingLevel, const char *, OrtEnv **)
     * }
     */
    public static class CreateEnvWithCustomLogger {

        CreateEnvWithCustomLogger() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, int _x2, MemorySegment _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_INT,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(CreateEnvWithCustomLogger.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateEnvWithCustomLogger.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr,
                MemorySegment _x0,
                MemorySegment _x1,
                int _x2,
                MemorySegment _x3,
                MemorySegment _x4) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static CreateEnvWithCustomLogger.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2, _x3, _x4) -> invoke(funcPtr, _x0, _x1, _x2, _x3, _x4);
        }
    }

    private static final AddressLayout CreateEnvWithCustomLogger$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("CreateEnvWithCustomLogger"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateEnvWithCustomLogger)(OrtLoggingFunction, void *, OrtLoggingLevel, const char *, OrtEnv **)
     * }
     */
    public static final AddressLayout CreateEnvWithCustomLogger$layout() {
        return CreateEnvWithCustomLogger$LAYOUT;
    }

    private static final long CreateEnvWithCustomLogger$OFFSET = 32;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateEnvWithCustomLogger)(OrtLoggingFunction, void *, OrtLoggingLevel, const char *, OrtEnv **)
     * }
     */
    public static final long CreateEnvWithCustomLogger$offset() {
        return CreateEnvWithCustomLogger$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateEnvWithCustomLogger)(OrtLoggingFunction, void *, OrtLoggingLevel, const char *, OrtEnv **)
     * }
     */
    public static MemorySegment CreateEnvWithCustomLogger(MemorySegment struct) {
        return struct.get(CreateEnvWithCustomLogger$LAYOUT, CreateEnvWithCustomLogger$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateEnvWithCustomLogger)(OrtLoggingFunction, void *, OrtLoggingLevel, const char *, OrtEnv **)
     * }
     */
    public static void CreateEnvWithCustomLogger(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateEnvWithCustomLogger$LAYOUT, CreateEnvWithCustomLogger$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateEnvWithCustomLogger)(OrtLoggingFunction, void *, OrtLoggingLevel, const char *, OrtEnv **)
     * }
     */
    public static CreateEnvWithCustomLogger.Function CreateEnvWithCustomLoggerFunction(MemorySegment struct) {
        return CreateEnvWithCustomLogger.function(CreateEnvWithCustomLogger(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*EnableTelemetryEvents)(const OrtEnv *)
     * }
     */
    public static class EnableTelemetryEvents {

        EnableTelemetryEvents() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC =
                FunctionDescriptor.of(onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(EnableTelemetryEvents.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(EnableTelemetryEvents.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static EnableTelemetryEvents.Function function(MemorySegment funcPtr) {
            return (_x0) -> invoke(funcPtr, _x0);
        }
    }

    private static final AddressLayout EnableTelemetryEvents$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("EnableTelemetryEvents"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*EnableTelemetryEvents)(const OrtEnv *)
     * }
     */
    public static final AddressLayout EnableTelemetryEvents$layout() {
        return EnableTelemetryEvents$LAYOUT;
    }

    private static final long EnableTelemetryEvents$OFFSET = 40;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*EnableTelemetryEvents)(const OrtEnv *)
     * }
     */
    public static final long EnableTelemetryEvents$offset() {
        return EnableTelemetryEvents$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*EnableTelemetryEvents)(const OrtEnv *)
     * }
     */
    public static MemorySegment EnableTelemetryEvents(MemorySegment struct) {
        return struct.get(EnableTelemetryEvents$LAYOUT, EnableTelemetryEvents$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*EnableTelemetryEvents)(const OrtEnv *)
     * }
     */
    public static void EnableTelemetryEvents(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(EnableTelemetryEvents$LAYOUT, EnableTelemetryEvents$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*EnableTelemetryEvents)(const OrtEnv *)
     * }
     */
    public static EnableTelemetryEvents.Function EnableTelemetryEventsFunction(MemorySegment struct) {
        return EnableTelemetryEvents.function(EnableTelemetryEvents(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*DisableTelemetryEvents)(const OrtEnv *)
     * }
     */
    public static class DisableTelemetryEvents {

        DisableTelemetryEvents() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC =
                FunctionDescriptor.of(onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(DisableTelemetryEvents.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(DisableTelemetryEvents.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static DisableTelemetryEvents.Function function(MemorySegment funcPtr) {
            return (_x0) -> invoke(funcPtr, _x0);
        }
    }

    private static final AddressLayout DisableTelemetryEvents$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("DisableTelemetryEvents"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*DisableTelemetryEvents)(const OrtEnv *)
     * }
     */
    public static final AddressLayout DisableTelemetryEvents$layout() {
        return DisableTelemetryEvents$LAYOUT;
    }

    private static final long DisableTelemetryEvents$OFFSET = 48;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*DisableTelemetryEvents)(const OrtEnv *)
     * }
     */
    public static final long DisableTelemetryEvents$offset() {
        return DisableTelemetryEvents$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*DisableTelemetryEvents)(const OrtEnv *)
     * }
     */
    public static MemorySegment DisableTelemetryEvents(MemorySegment struct) {
        return struct.get(DisableTelemetryEvents$LAYOUT, DisableTelemetryEvents$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*DisableTelemetryEvents)(const OrtEnv *)
     * }
     */
    public static void DisableTelemetryEvents(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(DisableTelemetryEvents$LAYOUT, DisableTelemetryEvents$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*DisableTelemetryEvents)(const OrtEnv *)
     * }
     */
    public static DisableTelemetryEvents.Function DisableTelemetryEventsFunction(MemorySegment struct) {
        return DisableTelemetryEvents.function(DisableTelemetryEvents(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSession)(const OrtEnv *, const char *, const OrtSessionOptions *, OrtSession **)
     * }
     */
    public static class CreateSession {

        CreateSession() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(CreateSession.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateSession.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static CreateSession.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2, _x3) -> invoke(funcPtr, _x0, _x1, _x2, _x3);
        }
    }

    private static final AddressLayout CreateSession$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("CreateSession"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSession)(const OrtEnv *, const char *, const OrtSessionOptions *, OrtSession **)
     * }
     */
    public static final AddressLayout CreateSession$layout() {
        return CreateSession$LAYOUT;
    }

    private static final long CreateSession$OFFSET = 56;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSession)(const OrtEnv *, const char *, const OrtSessionOptions *, OrtSession **)
     * }
     */
    public static final long CreateSession$offset() {
        return CreateSession$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSession)(const OrtEnv *, const char *, const OrtSessionOptions *, OrtSession **)
     * }
     */
    public static MemorySegment CreateSession(MemorySegment struct) {
        return struct.get(CreateSession$LAYOUT, CreateSession$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSession)(const OrtEnv *, const char *, const OrtSessionOptions *, OrtSession **)
     * }
     */
    public static void CreateSession(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateSession$LAYOUT, CreateSession$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSession)(const OrtEnv *, const char *, const OrtSessionOptions *, OrtSession **)
     * }
     */
    public static CreateSession.Function CreateSessionFunction(MemorySegment struct) {
        return CreateSession.function(CreateSession(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSessionFromArray)(const OrtEnv *, const void *, size_t, const OrtSessionOptions *, OrtSession **)
     * }
     */
    public static class CreateSessionFromArray {

        CreateSessionFromArray() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_LONG,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(CreateSessionFromArray.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateSessionFromArray.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr,
                MemorySegment _x0,
                MemorySegment _x1,
                long _x2,
                MemorySegment _x3,
                MemorySegment _x4) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static CreateSessionFromArray.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2, _x3, _x4) -> invoke(funcPtr, _x0, _x1, _x2, _x3, _x4);
        }
    }

    private static final AddressLayout CreateSessionFromArray$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("CreateSessionFromArray"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSessionFromArray)(const OrtEnv *, const void *, size_t, const OrtSessionOptions *, OrtSession **)
     * }
     */
    public static final AddressLayout CreateSessionFromArray$layout() {
        return CreateSessionFromArray$LAYOUT;
    }

    private static final long CreateSessionFromArray$OFFSET = 64;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSessionFromArray)(const OrtEnv *, const void *, size_t, const OrtSessionOptions *, OrtSession **)
     * }
     */
    public static final long CreateSessionFromArray$offset() {
        return CreateSessionFromArray$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSessionFromArray)(const OrtEnv *, const void *, size_t, const OrtSessionOptions *, OrtSession **)
     * }
     */
    public static MemorySegment CreateSessionFromArray(MemorySegment struct) {
        return struct.get(CreateSessionFromArray$LAYOUT, CreateSessionFromArray$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSessionFromArray)(const OrtEnv *, const void *, size_t, const OrtSessionOptions *, OrtSession **)
     * }
     */
    public static void CreateSessionFromArray(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateSessionFromArray$LAYOUT, CreateSessionFromArray$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSessionFromArray)(const OrtEnv *, const void *, size_t, const OrtSessionOptions *, OrtSession **)
     * }
     */
    public static CreateSessionFromArray.Function CreateSessionFromArrayFunction(MemorySegment struct) {
        return CreateSessionFromArray.function(CreateSessionFromArray(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*Run)(OrtSession *, const OrtRunOptions *, const char *const *, const OrtValue *const *, size_t, const char *const *, size_t, OrtValue **)
     * }
     */
    public static class Run {

        Run() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(
                    MemorySegment _x0,
                    MemorySegment _x1,
                    MemorySegment _x2,
                    MemorySegment _x3,
                    long _x4,
                    MemorySegment _x5,
                    long _x6,
                    MemorySegment _x7);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_LONG,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_LONG,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_all_h.upcallHandle(Run.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Run.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr,
                MemorySegment _x0,
                MemorySegment _x1,
                MemorySegment _x2,
                MemorySegment _x3,
                long _x4,
                MemorySegment _x5,
                long _x6,
                MemorySegment _x7) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static Run.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7) -> invoke(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7);
        }
    }

    private static final AddressLayout Run$LAYOUT = (AddressLayout) $LAYOUT.select(groupElement("Run"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Run)(OrtSession *, const OrtRunOptions *, const char *const *, const OrtValue *const *, size_t, const char *const *, size_t, OrtValue **)
     * }
     */
    public static final AddressLayout Run$layout() {
        return Run$LAYOUT;
    }

    private static final long Run$OFFSET = 72;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Run)(OrtSession *, const OrtRunOptions *, const char *const *, const OrtValue *const *, size_t, const char *const *, size_t, OrtValue **)
     * }
     */
    public static final long Run$offset() {
        return Run$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Run)(OrtSession *, const OrtRunOptions *, const char *const *, const OrtValue *const *, size_t, const char *const *, size_t, OrtValue **)
     * }
     */
    public static MemorySegment Run(MemorySegment struct) {
        return struct.get(Run$LAYOUT, Run$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Run)(OrtSession *, const OrtRunOptions *, const char *const *, const OrtValue *const *, size_t, const char *const *, size_t, OrtValue **)
     * }
     */
    public static void Run(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(Run$LAYOUT, Run$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Run)(OrtSession *, const OrtRunOptions *, const char *const *, const OrtValue *const *, size_t, const char *const *, size_t, OrtValue **)
     * }
     */
    public static Run.Function RunFunction(MemorySegment struct) {
        return Run.function(Run(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSessionOptions)(OrtSessionOptions **)
     * }
     */
    public static class CreateSessionOptions {

        CreateSessionOptions() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC =
                FunctionDescriptor.of(onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(CreateSessionOptions.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateSessionOptions.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static CreateSessionOptions.Function function(MemorySegment funcPtr) {
            return (_x0) -> invoke(funcPtr, _x0);
        }
    }

    private static final AddressLayout CreateSessionOptions$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("CreateSessionOptions"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSessionOptions)(OrtSessionOptions **)
     * }
     */
    public static final AddressLayout CreateSessionOptions$layout() {
        return CreateSessionOptions$LAYOUT;
    }

    private static final long CreateSessionOptions$OFFSET = 80;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSessionOptions)(OrtSessionOptions **)
     * }
     */
    public static final long CreateSessionOptions$offset() {
        return CreateSessionOptions$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSessionOptions)(OrtSessionOptions **)
     * }
     */
    public static MemorySegment CreateSessionOptions(MemorySegment struct) {
        return struct.get(CreateSessionOptions$LAYOUT, CreateSessionOptions$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSessionOptions)(OrtSessionOptions **)
     * }
     */
    public static void CreateSessionOptions(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateSessionOptions$LAYOUT, CreateSessionOptions$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSessionOptions)(OrtSessionOptions **)
     * }
     */
    public static CreateSessionOptions.Function CreateSessionOptionsFunction(MemorySegment struct) {
        return CreateSessionOptions.function(CreateSessionOptions(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SetOptimizedModelFilePath)(OrtSessionOptions *, const char *)
     * }
     */
    public static class SetOptimizedModelFilePath {

        SetOptimizedModelFilePath() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(SetOptimizedModelFilePath.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetOptimizedModelFilePath.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static SetOptimizedModelFilePath.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout SetOptimizedModelFilePath$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("SetOptimizedModelFilePath"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetOptimizedModelFilePath)(OrtSessionOptions *, const char *)
     * }
     */
    public static final AddressLayout SetOptimizedModelFilePath$layout() {
        return SetOptimizedModelFilePath$LAYOUT;
    }

    private static final long SetOptimizedModelFilePath$OFFSET = 88;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetOptimizedModelFilePath)(OrtSessionOptions *, const char *)
     * }
     */
    public static final long SetOptimizedModelFilePath$offset() {
        return SetOptimizedModelFilePath$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetOptimizedModelFilePath)(OrtSessionOptions *, const char *)
     * }
     */
    public static MemorySegment SetOptimizedModelFilePath(MemorySegment struct) {
        return struct.get(SetOptimizedModelFilePath$LAYOUT, SetOptimizedModelFilePath$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetOptimizedModelFilePath)(OrtSessionOptions *, const char *)
     * }
     */
    public static void SetOptimizedModelFilePath(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetOptimizedModelFilePath$LAYOUT, SetOptimizedModelFilePath$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetOptimizedModelFilePath)(OrtSessionOptions *, const char *)
     * }
     */
    public static SetOptimizedModelFilePath.Function SetOptimizedModelFilePathFunction(MemorySegment struct) {
        return SetOptimizedModelFilePath.function(SetOptimizedModelFilePath(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CloneSessionOptions)(const OrtSessionOptions *, OrtSessionOptions **)
     * }
     */
    public static class CloneSessionOptions {

        CloneSessionOptions() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(CloneSessionOptions.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CloneSessionOptions.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static CloneSessionOptions.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout CloneSessionOptions$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("CloneSessionOptions"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CloneSessionOptions)(const OrtSessionOptions *, OrtSessionOptions **)
     * }
     */
    public static final AddressLayout CloneSessionOptions$layout() {
        return CloneSessionOptions$LAYOUT;
    }

    private static final long CloneSessionOptions$OFFSET = 96;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CloneSessionOptions)(const OrtSessionOptions *, OrtSessionOptions **)
     * }
     */
    public static final long CloneSessionOptions$offset() {
        return CloneSessionOptions$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CloneSessionOptions)(const OrtSessionOptions *, OrtSessionOptions **)
     * }
     */
    public static MemorySegment CloneSessionOptions(MemorySegment struct) {
        return struct.get(CloneSessionOptions$LAYOUT, CloneSessionOptions$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CloneSessionOptions)(const OrtSessionOptions *, OrtSessionOptions **)
     * }
     */
    public static void CloneSessionOptions(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CloneSessionOptions$LAYOUT, CloneSessionOptions$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CloneSessionOptions)(const OrtSessionOptions *, OrtSessionOptions **)
     * }
     */
    public static CloneSessionOptions.Function CloneSessionOptionsFunction(MemorySegment struct) {
        return CloneSessionOptions.function(CloneSessionOptions(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SetSessionExecutionMode)(OrtSessionOptions *, ExecutionMode)
     * }
     */
    public static class SetSessionExecutionMode {

        SetSessionExecutionMode() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, int _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_INT);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(SetSessionExecutionMode.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetSessionExecutionMode.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, int _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static SetSessionExecutionMode.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout SetSessionExecutionMode$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("SetSessionExecutionMode"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetSessionExecutionMode)(OrtSessionOptions *, ExecutionMode)
     * }
     */
    public static final AddressLayout SetSessionExecutionMode$layout() {
        return SetSessionExecutionMode$LAYOUT;
    }

    private static final long SetSessionExecutionMode$OFFSET = 104;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetSessionExecutionMode)(OrtSessionOptions *, ExecutionMode)
     * }
     */
    public static final long SetSessionExecutionMode$offset() {
        return SetSessionExecutionMode$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetSessionExecutionMode)(OrtSessionOptions *, ExecutionMode)
     * }
     */
    public static MemorySegment SetSessionExecutionMode(MemorySegment struct) {
        return struct.get(SetSessionExecutionMode$LAYOUT, SetSessionExecutionMode$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetSessionExecutionMode)(OrtSessionOptions *, ExecutionMode)
     * }
     */
    public static void SetSessionExecutionMode(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetSessionExecutionMode$LAYOUT, SetSessionExecutionMode$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetSessionExecutionMode)(OrtSessionOptions *, ExecutionMode)
     * }
     */
    public static SetSessionExecutionMode.Function SetSessionExecutionModeFunction(MemorySegment struct) {
        return SetSessionExecutionMode.function(SetSessionExecutionMode(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*EnableProfiling)(OrtSessionOptions *, const char *)
     * }
     */
    public static class EnableProfiling {

        EnableProfiling() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(EnableProfiling.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(EnableProfiling.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static EnableProfiling.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout EnableProfiling$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("EnableProfiling"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*EnableProfiling)(OrtSessionOptions *, const char *)
     * }
     */
    public static final AddressLayout EnableProfiling$layout() {
        return EnableProfiling$LAYOUT;
    }

    private static final long EnableProfiling$OFFSET = 112;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*EnableProfiling)(OrtSessionOptions *, const char *)
     * }
     */
    public static final long EnableProfiling$offset() {
        return EnableProfiling$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*EnableProfiling)(OrtSessionOptions *, const char *)
     * }
     */
    public static MemorySegment EnableProfiling(MemorySegment struct) {
        return struct.get(EnableProfiling$LAYOUT, EnableProfiling$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*EnableProfiling)(OrtSessionOptions *, const char *)
     * }
     */
    public static void EnableProfiling(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(EnableProfiling$LAYOUT, EnableProfiling$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*EnableProfiling)(OrtSessionOptions *, const char *)
     * }
     */
    public static EnableProfiling.Function EnableProfilingFunction(MemorySegment struct) {
        return EnableProfiling.function(EnableProfiling(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*DisableProfiling)(OrtSessionOptions *)
     * }
     */
    public static class DisableProfiling {

        DisableProfiling() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC =
                FunctionDescriptor.of(onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(DisableProfiling.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(DisableProfiling.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static DisableProfiling.Function function(MemorySegment funcPtr) {
            return (_x0) -> invoke(funcPtr, _x0);
        }
    }

    private static final AddressLayout DisableProfiling$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("DisableProfiling"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*DisableProfiling)(OrtSessionOptions *)
     * }
     */
    public static final AddressLayout DisableProfiling$layout() {
        return DisableProfiling$LAYOUT;
    }

    private static final long DisableProfiling$OFFSET = 120;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*DisableProfiling)(OrtSessionOptions *)
     * }
     */
    public static final long DisableProfiling$offset() {
        return DisableProfiling$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*DisableProfiling)(OrtSessionOptions *)
     * }
     */
    public static MemorySegment DisableProfiling(MemorySegment struct) {
        return struct.get(DisableProfiling$LAYOUT, DisableProfiling$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*DisableProfiling)(OrtSessionOptions *)
     * }
     */
    public static void DisableProfiling(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(DisableProfiling$LAYOUT, DisableProfiling$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*DisableProfiling)(OrtSessionOptions *)
     * }
     */
    public static DisableProfiling.Function DisableProfilingFunction(MemorySegment struct) {
        return DisableProfiling.function(DisableProfiling(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*EnableMemPattern)(OrtSessionOptions *)
     * }
     */
    public static class EnableMemPattern {

        EnableMemPattern() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC =
                FunctionDescriptor.of(onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(EnableMemPattern.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(EnableMemPattern.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static EnableMemPattern.Function function(MemorySegment funcPtr) {
            return (_x0) -> invoke(funcPtr, _x0);
        }
    }

    private static final AddressLayout EnableMemPattern$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("EnableMemPattern"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*EnableMemPattern)(OrtSessionOptions *)
     * }
     */
    public static final AddressLayout EnableMemPattern$layout() {
        return EnableMemPattern$LAYOUT;
    }

    private static final long EnableMemPattern$OFFSET = 128;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*EnableMemPattern)(OrtSessionOptions *)
     * }
     */
    public static final long EnableMemPattern$offset() {
        return EnableMemPattern$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*EnableMemPattern)(OrtSessionOptions *)
     * }
     */
    public static MemorySegment EnableMemPattern(MemorySegment struct) {
        return struct.get(EnableMemPattern$LAYOUT, EnableMemPattern$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*EnableMemPattern)(OrtSessionOptions *)
     * }
     */
    public static void EnableMemPattern(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(EnableMemPattern$LAYOUT, EnableMemPattern$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*EnableMemPattern)(OrtSessionOptions *)
     * }
     */
    public static EnableMemPattern.Function EnableMemPatternFunction(MemorySegment struct) {
        return EnableMemPattern.function(EnableMemPattern(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*DisableMemPattern)(OrtSessionOptions *)
     * }
     */
    public static class DisableMemPattern {

        DisableMemPattern() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC =
                FunctionDescriptor.of(onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(DisableMemPattern.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(DisableMemPattern.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static DisableMemPattern.Function function(MemorySegment funcPtr) {
            return (_x0) -> invoke(funcPtr, _x0);
        }
    }

    private static final AddressLayout DisableMemPattern$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("DisableMemPattern"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*DisableMemPattern)(OrtSessionOptions *)
     * }
     */
    public static final AddressLayout DisableMemPattern$layout() {
        return DisableMemPattern$LAYOUT;
    }

    private static final long DisableMemPattern$OFFSET = 136;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*DisableMemPattern)(OrtSessionOptions *)
     * }
     */
    public static final long DisableMemPattern$offset() {
        return DisableMemPattern$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*DisableMemPattern)(OrtSessionOptions *)
     * }
     */
    public static MemorySegment DisableMemPattern(MemorySegment struct) {
        return struct.get(DisableMemPattern$LAYOUT, DisableMemPattern$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*DisableMemPattern)(OrtSessionOptions *)
     * }
     */
    public static void DisableMemPattern(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(DisableMemPattern$LAYOUT, DisableMemPattern$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*DisableMemPattern)(OrtSessionOptions *)
     * }
     */
    public static DisableMemPattern.Function DisableMemPatternFunction(MemorySegment struct) {
        return DisableMemPattern.function(DisableMemPattern(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*EnableCpuMemArena)(OrtSessionOptions *)
     * }
     */
    public static class EnableCpuMemArena {

        EnableCpuMemArena() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC =
                FunctionDescriptor.of(onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(EnableCpuMemArena.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(EnableCpuMemArena.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static EnableCpuMemArena.Function function(MemorySegment funcPtr) {
            return (_x0) -> invoke(funcPtr, _x0);
        }
    }

    private static final AddressLayout EnableCpuMemArena$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("EnableCpuMemArena"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*EnableCpuMemArena)(OrtSessionOptions *)
     * }
     */
    public static final AddressLayout EnableCpuMemArena$layout() {
        return EnableCpuMemArena$LAYOUT;
    }

    private static final long EnableCpuMemArena$OFFSET = 144;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*EnableCpuMemArena)(OrtSessionOptions *)
     * }
     */
    public static final long EnableCpuMemArena$offset() {
        return EnableCpuMemArena$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*EnableCpuMemArena)(OrtSessionOptions *)
     * }
     */
    public static MemorySegment EnableCpuMemArena(MemorySegment struct) {
        return struct.get(EnableCpuMemArena$LAYOUT, EnableCpuMemArena$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*EnableCpuMemArena)(OrtSessionOptions *)
     * }
     */
    public static void EnableCpuMemArena(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(EnableCpuMemArena$LAYOUT, EnableCpuMemArena$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*EnableCpuMemArena)(OrtSessionOptions *)
     * }
     */
    public static EnableCpuMemArena.Function EnableCpuMemArenaFunction(MemorySegment struct) {
        return EnableCpuMemArena.function(EnableCpuMemArena(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*DisableCpuMemArena)(OrtSessionOptions *)
     * }
     */
    public static class DisableCpuMemArena {

        DisableCpuMemArena() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC =
                FunctionDescriptor.of(onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(DisableCpuMemArena.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(DisableCpuMemArena.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static DisableCpuMemArena.Function function(MemorySegment funcPtr) {
            return (_x0) -> invoke(funcPtr, _x0);
        }
    }

    private static final AddressLayout DisableCpuMemArena$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("DisableCpuMemArena"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*DisableCpuMemArena)(OrtSessionOptions *)
     * }
     */
    public static final AddressLayout DisableCpuMemArena$layout() {
        return DisableCpuMemArena$LAYOUT;
    }

    private static final long DisableCpuMemArena$OFFSET = 152;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*DisableCpuMemArena)(OrtSessionOptions *)
     * }
     */
    public static final long DisableCpuMemArena$offset() {
        return DisableCpuMemArena$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*DisableCpuMemArena)(OrtSessionOptions *)
     * }
     */
    public static MemorySegment DisableCpuMemArena(MemorySegment struct) {
        return struct.get(DisableCpuMemArena$LAYOUT, DisableCpuMemArena$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*DisableCpuMemArena)(OrtSessionOptions *)
     * }
     */
    public static void DisableCpuMemArena(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(DisableCpuMemArena$LAYOUT, DisableCpuMemArena$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*DisableCpuMemArena)(OrtSessionOptions *)
     * }
     */
    public static DisableCpuMemArena.Function DisableCpuMemArenaFunction(MemorySegment struct) {
        return DisableCpuMemArena.function(DisableCpuMemArena(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SetSessionLogId)(OrtSessionOptions *, const char *)
     * }
     */
    public static class SetSessionLogId {

        SetSessionLogId() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(SetSessionLogId.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetSessionLogId.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static SetSessionLogId.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout SetSessionLogId$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("SetSessionLogId"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetSessionLogId)(OrtSessionOptions *, const char *)
     * }
     */
    public static final AddressLayout SetSessionLogId$layout() {
        return SetSessionLogId$LAYOUT;
    }

    private static final long SetSessionLogId$OFFSET = 160;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetSessionLogId)(OrtSessionOptions *, const char *)
     * }
     */
    public static final long SetSessionLogId$offset() {
        return SetSessionLogId$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetSessionLogId)(OrtSessionOptions *, const char *)
     * }
     */
    public static MemorySegment SetSessionLogId(MemorySegment struct) {
        return struct.get(SetSessionLogId$LAYOUT, SetSessionLogId$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetSessionLogId)(OrtSessionOptions *, const char *)
     * }
     */
    public static void SetSessionLogId(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetSessionLogId$LAYOUT, SetSessionLogId$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetSessionLogId)(OrtSessionOptions *, const char *)
     * }
     */
    public static SetSessionLogId.Function SetSessionLogIdFunction(MemorySegment struct) {
        return SetSessionLogId.function(SetSessionLogId(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SetSessionLogVerbosityLevel)(OrtSessionOptions *, int)
     * }
     */
    public static class SetSessionLogVerbosityLevel {

        SetSessionLogVerbosityLevel() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, int _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_INT);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(SetSessionLogVerbosityLevel.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetSessionLogVerbosityLevel.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, int _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static SetSessionLogVerbosityLevel.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout SetSessionLogVerbosityLevel$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("SetSessionLogVerbosityLevel"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetSessionLogVerbosityLevel)(OrtSessionOptions *, int)
     * }
     */
    public static final AddressLayout SetSessionLogVerbosityLevel$layout() {
        return SetSessionLogVerbosityLevel$LAYOUT;
    }

    private static final long SetSessionLogVerbosityLevel$OFFSET = 168;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetSessionLogVerbosityLevel)(OrtSessionOptions *, int)
     * }
     */
    public static final long SetSessionLogVerbosityLevel$offset() {
        return SetSessionLogVerbosityLevel$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetSessionLogVerbosityLevel)(OrtSessionOptions *, int)
     * }
     */
    public static MemorySegment SetSessionLogVerbosityLevel(MemorySegment struct) {
        return struct.get(SetSessionLogVerbosityLevel$LAYOUT, SetSessionLogVerbosityLevel$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetSessionLogVerbosityLevel)(OrtSessionOptions *, int)
     * }
     */
    public static void SetSessionLogVerbosityLevel(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetSessionLogVerbosityLevel$LAYOUT, SetSessionLogVerbosityLevel$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetSessionLogVerbosityLevel)(OrtSessionOptions *, int)
     * }
     */
    public static SetSessionLogVerbosityLevel.Function SetSessionLogVerbosityLevelFunction(MemorySegment struct) {
        return SetSessionLogVerbosityLevel.function(SetSessionLogVerbosityLevel(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SetSessionLogSeverityLevel)(OrtSessionOptions *, int)
     * }
     */
    public static class SetSessionLogSeverityLevel {

        SetSessionLogSeverityLevel() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, int _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_INT);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(SetSessionLogSeverityLevel.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetSessionLogSeverityLevel.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, int _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static SetSessionLogSeverityLevel.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout SetSessionLogSeverityLevel$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("SetSessionLogSeverityLevel"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetSessionLogSeverityLevel)(OrtSessionOptions *, int)
     * }
     */
    public static final AddressLayout SetSessionLogSeverityLevel$layout() {
        return SetSessionLogSeverityLevel$LAYOUT;
    }

    private static final long SetSessionLogSeverityLevel$OFFSET = 176;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetSessionLogSeverityLevel)(OrtSessionOptions *, int)
     * }
     */
    public static final long SetSessionLogSeverityLevel$offset() {
        return SetSessionLogSeverityLevel$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetSessionLogSeverityLevel)(OrtSessionOptions *, int)
     * }
     */
    public static MemorySegment SetSessionLogSeverityLevel(MemorySegment struct) {
        return struct.get(SetSessionLogSeverityLevel$LAYOUT, SetSessionLogSeverityLevel$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetSessionLogSeverityLevel)(OrtSessionOptions *, int)
     * }
     */
    public static void SetSessionLogSeverityLevel(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetSessionLogSeverityLevel$LAYOUT, SetSessionLogSeverityLevel$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetSessionLogSeverityLevel)(OrtSessionOptions *, int)
     * }
     */
    public static SetSessionLogSeverityLevel.Function SetSessionLogSeverityLevelFunction(MemorySegment struct) {
        return SetSessionLogSeverityLevel.function(SetSessionLogSeverityLevel(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SetSessionGraphOptimizationLevel)(OrtSessionOptions *, GraphOptimizationLevel)
     * }
     */
    public static class SetSessionGraphOptimizationLevel {

        SetSessionGraphOptimizationLevel() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, int _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_INT);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(SetSessionGraphOptimizationLevel.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetSessionGraphOptimizationLevel.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, int _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static SetSessionGraphOptimizationLevel.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout SetSessionGraphOptimizationLevel$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("SetSessionGraphOptimizationLevel"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetSessionGraphOptimizationLevel)(OrtSessionOptions *, GraphOptimizationLevel)
     * }
     */
    public static final AddressLayout SetSessionGraphOptimizationLevel$layout() {
        return SetSessionGraphOptimizationLevel$LAYOUT;
    }

    private static final long SetSessionGraphOptimizationLevel$OFFSET = 184;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetSessionGraphOptimizationLevel)(OrtSessionOptions *, GraphOptimizationLevel)
     * }
     */
    public static final long SetSessionGraphOptimizationLevel$offset() {
        return SetSessionGraphOptimizationLevel$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetSessionGraphOptimizationLevel)(OrtSessionOptions *, GraphOptimizationLevel)
     * }
     */
    public static MemorySegment SetSessionGraphOptimizationLevel(MemorySegment struct) {
        return struct.get(SetSessionGraphOptimizationLevel$LAYOUT, SetSessionGraphOptimizationLevel$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetSessionGraphOptimizationLevel)(OrtSessionOptions *, GraphOptimizationLevel)
     * }
     */
    public static void SetSessionGraphOptimizationLevel(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetSessionGraphOptimizationLevel$LAYOUT, SetSessionGraphOptimizationLevel$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetSessionGraphOptimizationLevel)(OrtSessionOptions *, GraphOptimizationLevel)
     * }
     */
    public static SetSessionGraphOptimizationLevel.Function SetSessionGraphOptimizationLevelFunction(
            MemorySegment struct) {
        return SetSessionGraphOptimizationLevel.function(SetSessionGraphOptimizationLevel(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SetIntraOpNumThreads)(OrtSessionOptions *, int)
     * }
     */
    public static class SetIntraOpNumThreads {

        SetIntraOpNumThreads() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, int _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_INT);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(SetIntraOpNumThreads.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetIntraOpNumThreads.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, int _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static SetIntraOpNumThreads.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout SetIntraOpNumThreads$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("SetIntraOpNumThreads"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetIntraOpNumThreads)(OrtSessionOptions *, int)
     * }
     */
    public static final AddressLayout SetIntraOpNumThreads$layout() {
        return SetIntraOpNumThreads$LAYOUT;
    }

    private static final long SetIntraOpNumThreads$OFFSET = 192;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetIntraOpNumThreads)(OrtSessionOptions *, int)
     * }
     */
    public static final long SetIntraOpNumThreads$offset() {
        return SetIntraOpNumThreads$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetIntraOpNumThreads)(OrtSessionOptions *, int)
     * }
     */
    public static MemorySegment SetIntraOpNumThreads(MemorySegment struct) {
        return struct.get(SetIntraOpNumThreads$LAYOUT, SetIntraOpNumThreads$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetIntraOpNumThreads)(OrtSessionOptions *, int)
     * }
     */
    public static void SetIntraOpNumThreads(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetIntraOpNumThreads$LAYOUT, SetIntraOpNumThreads$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetIntraOpNumThreads)(OrtSessionOptions *, int)
     * }
     */
    public static SetIntraOpNumThreads.Function SetIntraOpNumThreadsFunction(MemorySegment struct) {
        return SetIntraOpNumThreads.function(SetIntraOpNumThreads(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SetInterOpNumThreads)(OrtSessionOptions *, int)
     * }
     */
    public static class SetInterOpNumThreads {

        SetInterOpNumThreads() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, int _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_INT);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(SetInterOpNumThreads.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetInterOpNumThreads.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, int _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static SetInterOpNumThreads.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout SetInterOpNumThreads$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("SetInterOpNumThreads"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetInterOpNumThreads)(OrtSessionOptions *, int)
     * }
     */
    public static final AddressLayout SetInterOpNumThreads$layout() {
        return SetInterOpNumThreads$LAYOUT;
    }

    private static final long SetInterOpNumThreads$OFFSET = 200;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetInterOpNumThreads)(OrtSessionOptions *, int)
     * }
     */
    public static final long SetInterOpNumThreads$offset() {
        return SetInterOpNumThreads$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetInterOpNumThreads)(OrtSessionOptions *, int)
     * }
     */
    public static MemorySegment SetInterOpNumThreads(MemorySegment struct) {
        return struct.get(SetInterOpNumThreads$LAYOUT, SetInterOpNumThreads$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetInterOpNumThreads)(OrtSessionOptions *, int)
     * }
     */
    public static void SetInterOpNumThreads(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetInterOpNumThreads$LAYOUT, SetInterOpNumThreads$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetInterOpNumThreads)(OrtSessionOptions *, int)
     * }
     */
    public static SetInterOpNumThreads.Function SetInterOpNumThreadsFunction(MemorySegment struct) {
        return SetInterOpNumThreads.function(SetInterOpNumThreads(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateCustomOpDomain)(const char *, OrtCustomOpDomain **)
     * }
     */
    public static class CreateCustomOpDomain {

        CreateCustomOpDomain() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(CreateCustomOpDomain.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateCustomOpDomain.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static CreateCustomOpDomain.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout CreateCustomOpDomain$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("CreateCustomOpDomain"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateCustomOpDomain)(const char *, OrtCustomOpDomain **)
     * }
     */
    public static final AddressLayout CreateCustomOpDomain$layout() {
        return CreateCustomOpDomain$LAYOUT;
    }

    private static final long CreateCustomOpDomain$OFFSET = 208;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateCustomOpDomain)(const char *, OrtCustomOpDomain **)
     * }
     */
    public static final long CreateCustomOpDomain$offset() {
        return CreateCustomOpDomain$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateCustomOpDomain)(const char *, OrtCustomOpDomain **)
     * }
     */
    public static MemorySegment CreateCustomOpDomain(MemorySegment struct) {
        return struct.get(CreateCustomOpDomain$LAYOUT, CreateCustomOpDomain$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateCustomOpDomain)(const char *, OrtCustomOpDomain **)
     * }
     */
    public static void CreateCustomOpDomain(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateCustomOpDomain$LAYOUT, CreateCustomOpDomain$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateCustomOpDomain)(const char *, OrtCustomOpDomain **)
     * }
     */
    public static CreateCustomOpDomain.Function CreateCustomOpDomainFunction(MemorySegment struct) {
        return CreateCustomOpDomain.function(CreateCustomOpDomain(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CustomOpDomain_Add)(OrtCustomOpDomain *, const OrtCustomOp *)
     * }
     */
    public static class CustomOpDomain_Add {

        CustomOpDomain_Add() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(CustomOpDomain_Add.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CustomOpDomain_Add.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static CustomOpDomain_Add.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout CustomOpDomain_Add$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("CustomOpDomain_Add"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CustomOpDomain_Add)(OrtCustomOpDomain *, const OrtCustomOp *)
     * }
     */
    public static final AddressLayout CustomOpDomain_Add$layout() {
        return CustomOpDomain_Add$LAYOUT;
    }

    private static final long CustomOpDomain_Add$OFFSET = 216;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CustomOpDomain_Add)(OrtCustomOpDomain *, const OrtCustomOp *)
     * }
     */
    public static final long CustomOpDomain_Add$offset() {
        return CustomOpDomain_Add$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CustomOpDomain_Add)(OrtCustomOpDomain *, const OrtCustomOp *)
     * }
     */
    public static MemorySegment CustomOpDomain_Add(MemorySegment struct) {
        return struct.get(CustomOpDomain_Add$LAYOUT, CustomOpDomain_Add$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CustomOpDomain_Add)(OrtCustomOpDomain *, const OrtCustomOp *)
     * }
     */
    public static void CustomOpDomain_Add(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CustomOpDomain_Add$LAYOUT, CustomOpDomain_Add$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CustomOpDomain_Add)(OrtCustomOpDomain *, const OrtCustomOp *)
     * }
     */
    public static CustomOpDomain_Add.Function CustomOpDomain_AddFunction(MemorySegment struct) {
        return CustomOpDomain_Add.function(CustomOpDomain_Add(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*AddCustomOpDomain)(OrtSessionOptions *, OrtCustomOpDomain *)
     * }
     */
    public static class AddCustomOpDomain {

        AddCustomOpDomain() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(AddCustomOpDomain.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(AddCustomOpDomain.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static AddCustomOpDomain.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout AddCustomOpDomain$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("AddCustomOpDomain"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddCustomOpDomain)(OrtSessionOptions *, OrtCustomOpDomain *)
     * }
     */
    public static final AddressLayout AddCustomOpDomain$layout() {
        return AddCustomOpDomain$LAYOUT;
    }

    private static final long AddCustomOpDomain$OFFSET = 224;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddCustomOpDomain)(OrtSessionOptions *, OrtCustomOpDomain *)
     * }
     */
    public static final long AddCustomOpDomain$offset() {
        return AddCustomOpDomain$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddCustomOpDomain)(OrtSessionOptions *, OrtCustomOpDomain *)
     * }
     */
    public static MemorySegment AddCustomOpDomain(MemorySegment struct) {
        return struct.get(AddCustomOpDomain$LAYOUT, AddCustomOpDomain$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddCustomOpDomain)(OrtSessionOptions *, OrtCustomOpDomain *)
     * }
     */
    public static void AddCustomOpDomain(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(AddCustomOpDomain$LAYOUT, AddCustomOpDomain$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddCustomOpDomain)(OrtSessionOptions *, OrtCustomOpDomain *)
     * }
     */
    public static AddCustomOpDomain.Function AddCustomOpDomainFunction(MemorySegment struct) {
        return AddCustomOpDomain.function(AddCustomOpDomain(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*RegisterCustomOpsLibrary)(OrtSessionOptions *, const char *, void **)
     * }
     */
    public static class RegisterCustomOpsLibrary {

        RegisterCustomOpsLibrary() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(RegisterCustomOpsLibrary.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(RegisterCustomOpsLibrary.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static RegisterCustomOpsLibrary.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2) -> invoke(funcPtr, _x0, _x1, _x2);
        }
    }

    private static final AddressLayout RegisterCustomOpsLibrary$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("RegisterCustomOpsLibrary"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RegisterCustomOpsLibrary)(OrtSessionOptions *, const char *, void **)
     * }
     */
    public static final AddressLayout RegisterCustomOpsLibrary$layout() {
        return RegisterCustomOpsLibrary$LAYOUT;
    }

    private static final long RegisterCustomOpsLibrary$OFFSET = 232;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RegisterCustomOpsLibrary)(OrtSessionOptions *, const char *, void **)
     * }
     */
    public static final long RegisterCustomOpsLibrary$offset() {
        return RegisterCustomOpsLibrary$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RegisterCustomOpsLibrary)(OrtSessionOptions *, const char *, void **)
     * }
     */
    public static MemorySegment RegisterCustomOpsLibrary(MemorySegment struct) {
        return struct.get(RegisterCustomOpsLibrary$LAYOUT, RegisterCustomOpsLibrary$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RegisterCustomOpsLibrary)(OrtSessionOptions *, const char *, void **)
     * }
     */
    public static void RegisterCustomOpsLibrary(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(RegisterCustomOpsLibrary$LAYOUT, RegisterCustomOpsLibrary$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RegisterCustomOpsLibrary)(OrtSessionOptions *, const char *, void **)
     * }
     */
    public static RegisterCustomOpsLibrary.Function RegisterCustomOpsLibraryFunction(MemorySegment struct) {
        return RegisterCustomOpsLibrary.function(RegisterCustomOpsLibrary(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetInputCount)(const OrtSession *, size_t *)
     * }
     */
    public static class SessionGetInputCount {

        SessionGetInputCount() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(SessionGetInputCount.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SessionGetInputCount.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static SessionGetInputCount.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout SessionGetInputCount$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("SessionGetInputCount"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetInputCount)(const OrtSession *, size_t *)
     * }
     */
    public static final AddressLayout SessionGetInputCount$layout() {
        return SessionGetInputCount$LAYOUT;
    }

    private static final long SessionGetInputCount$OFFSET = 240;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetInputCount)(const OrtSession *, size_t *)
     * }
     */
    public static final long SessionGetInputCount$offset() {
        return SessionGetInputCount$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetInputCount)(const OrtSession *, size_t *)
     * }
     */
    public static MemorySegment SessionGetInputCount(MemorySegment struct) {
        return struct.get(SessionGetInputCount$LAYOUT, SessionGetInputCount$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetInputCount)(const OrtSession *, size_t *)
     * }
     */
    public static void SessionGetInputCount(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SessionGetInputCount$LAYOUT, SessionGetInputCount$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetInputCount)(const OrtSession *, size_t *)
     * }
     */
    public static SessionGetInputCount.Function SessionGetInputCountFunction(MemorySegment struct) {
        return SessionGetInputCount.function(SessionGetInputCount(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetOutputCount)(const OrtSession *, size_t *)
     * }
     */
    public static class SessionGetOutputCount {

        SessionGetOutputCount() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(SessionGetOutputCount.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SessionGetOutputCount.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static SessionGetOutputCount.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout SessionGetOutputCount$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("SessionGetOutputCount"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetOutputCount)(const OrtSession *, size_t *)
     * }
     */
    public static final AddressLayout SessionGetOutputCount$layout() {
        return SessionGetOutputCount$LAYOUT;
    }

    private static final long SessionGetOutputCount$OFFSET = 248;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetOutputCount)(const OrtSession *, size_t *)
     * }
     */
    public static final long SessionGetOutputCount$offset() {
        return SessionGetOutputCount$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetOutputCount)(const OrtSession *, size_t *)
     * }
     */
    public static MemorySegment SessionGetOutputCount(MemorySegment struct) {
        return struct.get(SessionGetOutputCount$LAYOUT, SessionGetOutputCount$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetOutputCount)(const OrtSession *, size_t *)
     * }
     */
    public static void SessionGetOutputCount(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SessionGetOutputCount$LAYOUT, SessionGetOutputCount$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetOutputCount)(const OrtSession *, size_t *)
     * }
     */
    public static SessionGetOutputCount.Function SessionGetOutputCountFunction(MemorySegment struct) {
        return SessionGetOutputCount.function(SessionGetOutputCount(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetOverridableInitializerCount)(const OrtSession *, size_t *)
     * }
     */
    public static class SessionGetOverridableInitializerCount {

        SessionGetOverridableInitializerCount() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(SessionGetOverridableInitializerCount.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SessionGetOverridableInitializerCount.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static SessionGetOverridableInitializerCount.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout SessionGetOverridableInitializerCount$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("SessionGetOverridableInitializerCount"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetOverridableInitializerCount)(const OrtSession *, size_t *)
     * }
     */
    public static final AddressLayout SessionGetOverridableInitializerCount$layout() {
        return SessionGetOverridableInitializerCount$LAYOUT;
    }

    private static final long SessionGetOverridableInitializerCount$OFFSET = 256;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetOverridableInitializerCount)(const OrtSession *, size_t *)
     * }
     */
    public static final long SessionGetOverridableInitializerCount$offset() {
        return SessionGetOverridableInitializerCount$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetOverridableInitializerCount)(const OrtSession *, size_t *)
     * }
     */
    public static MemorySegment SessionGetOverridableInitializerCount(MemorySegment struct) {
        return struct.get(SessionGetOverridableInitializerCount$LAYOUT, SessionGetOverridableInitializerCount$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetOverridableInitializerCount)(const OrtSession *, size_t *)
     * }
     */
    public static void SessionGetOverridableInitializerCount(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(
                SessionGetOverridableInitializerCount$LAYOUT, SessionGetOverridableInitializerCount$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetOverridableInitializerCount)(const OrtSession *, size_t *)
     * }
     */
    public static SessionGetOverridableInitializerCount.Function SessionGetOverridableInitializerCountFunction(
            MemorySegment struct) {
        return SessionGetOverridableInitializerCount.function(SessionGetOverridableInitializerCount(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetInputTypeInfo)(const OrtSession *, size_t, OrtTypeInfo **)
     * }
     */
    public static class SessionGetInputTypeInfo {

        SessionGetInputTypeInfo() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, long _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_LONG,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(SessionGetInputTypeInfo.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SessionGetInputTypeInfo.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, long _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static SessionGetInputTypeInfo.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2) -> invoke(funcPtr, _x0, _x1, _x2);
        }
    }

    private static final AddressLayout SessionGetInputTypeInfo$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("SessionGetInputTypeInfo"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetInputTypeInfo)(const OrtSession *, size_t, OrtTypeInfo **)
     * }
     */
    public static final AddressLayout SessionGetInputTypeInfo$layout() {
        return SessionGetInputTypeInfo$LAYOUT;
    }

    private static final long SessionGetInputTypeInfo$OFFSET = 264;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetInputTypeInfo)(const OrtSession *, size_t, OrtTypeInfo **)
     * }
     */
    public static final long SessionGetInputTypeInfo$offset() {
        return SessionGetInputTypeInfo$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetInputTypeInfo)(const OrtSession *, size_t, OrtTypeInfo **)
     * }
     */
    public static MemorySegment SessionGetInputTypeInfo(MemorySegment struct) {
        return struct.get(SessionGetInputTypeInfo$LAYOUT, SessionGetInputTypeInfo$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetInputTypeInfo)(const OrtSession *, size_t, OrtTypeInfo **)
     * }
     */
    public static void SessionGetInputTypeInfo(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SessionGetInputTypeInfo$LAYOUT, SessionGetInputTypeInfo$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetInputTypeInfo)(const OrtSession *, size_t, OrtTypeInfo **)
     * }
     */
    public static SessionGetInputTypeInfo.Function SessionGetInputTypeInfoFunction(MemorySegment struct) {
        return SessionGetInputTypeInfo.function(SessionGetInputTypeInfo(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetOutputTypeInfo)(const OrtSession *, size_t, OrtTypeInfo **)
     * }
     */
    public static class SessionGetOutputTypeInfo {

        SessionGetOutputTypeInfo() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, long _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_LONG,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(SessionGetOutputTypeInfo.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SessionGetOutputTypeInfo.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, long _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static SessionGetOutputTypeInfo.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2) -> invoke(funcPtr, _x0, _x1, _x2);
        }
    }

    private static final AddressLayout SessionGetOutputTypeInfo$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("SessionGetOutputTypeInfo"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetOutputTypeInfo)(const OrtSession *, size_t, OrtTypeInfo **)
     * }
     */
    public static final AddressLayout SessionGetOutputTypeInfo$layout() {
        return SessionGetOutputTypeInfo$LAYOUT;
    }

    private static final long SessionGetOutputTypeInfo$OFFSET = 272;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetOutputTypeInfo)(const OrtSession *, size_t, OrtTypeInfo **)
     * }
     */
    public static final long SessionGetOutputTypeInfo$offset() {
        return SessionGetOutputTypeInfo$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetOutputTypeInfo)(const OrtSession *, size_t, OrtTypeInfo **)
     * }
     */
    public static MemorySegment SessionGetOutputTypeInfo(MemorySegment struct) {
        return struct.get(SessionGetOutputTypeInfo$LAYOUT, SessionGetOutputTypeInfo$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetOutputTypeInfo)(const OrtSession *, size_t, OrtTypeInfo **)
     * }
     */
    public static void SessionGetOutputTypeInfo(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SessionGetOutputTypeInfo$LAYOUT, SessionGetOutputTypeInfo$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetOutputTypeInfo)(const OrtSession *, size_t, OrtTypeInfo **)
     * }
     */
    public static SessionGetOutputTypeInfo.Function SessionGetOutputTypeInfoFunction(MemorySegment struct) {
        return SessionGetOutputTypeInfo.function(SessionGetOutputTypeInfo(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetOverridableInitializerTypeInfo)(const OrtSession *, size_t, OrtTypeInfo **)
     * }
     */
    public static class SessionGetOverridableInitializerTypeInfo {

        SessionGetOverridableInitializerTypeInfo() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, long _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_LONG,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(SessionGetOverridableInitializerTypeInfo.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SessionGetOverridableInitializerTypeInfo.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, long _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static SessionGetOverridableInitializerTypeInfo.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2) -> invoke(funcPtr, _x0, _x1, _x2);
        }
    }

    private static final AddressLayout SessionGetOverridableInitializerTypeInfo$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("SessionGetOverridableInitializerTypeInfo"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetOverridableInitializerTypeInfo)(const OrtSession *, size_t, OrtTypeInfo **)
     * }
     */
    public static final AddressLayout SessionGetOverridableInitializerTypeInfo$layout() {
        return SessionGetOverridableInitializerTypeInfo$LAYOUT;
    }

    private static final long SessionGetOverridableInitializerTypeInfo$OFFSET = 280;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetOverridableInitializerTypeInfo)(const OrtSession *, size_t, OrtTypeInfo **)
     * }
     */
    public static final long SessionGetOverridableInitializerTypeInfo$offset() {
        return SessionGetOverridableInitializerTypeInfo$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetOverridableInitializerTypeInfo)(const OrtSession *, size_t, OrtTypeInfo **)
     * }
     */
    public static MemorySegment SessionGetOverridableInitializerTypeInfo(MemorySegment struct) {
        return struct.get(
                SessionGetOverridableInitializerTypeInfo$LAYOUT, SessionGetOverridableInitializerTypeInfo$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetOverridableInitializerTypeInfo)(const OrtSession *, size_t, OrtTypeInfo **)
     * }
     */
    public static void SessionGetOverridableInitializerTypeInfo(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(
                SessionGetOverridableInitializerTypeInfo$LAYOUT,
                SessionGetOverridableInitializerTypeInfo$OFFSET,
                fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetOverridableInitializerTypeInfo)(const OrtSession *, size_t, OrtTypeInfo **)
     * }
     */
    public static SessionGetOverridableInitializerTypeInfo.Function SessionGetOverridableInitializerTypeInfoFunction(
            MemorySegment struct) {
        return SessionGetOverridableInitializerTypeInfo.function(SessionGetOverridableInitializerTypeInfo(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetInputName)(const OrtSession *, size_t, OrtAllocator *, char **)
     * }
     */
    public static class SessionGetInputName {

        SessionGetInputName() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_LONG,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(SessionGetInputName.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SessionGetInputName.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr, MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static SessionGetInputName.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2, _x3) -> invoke(funcPtr, _x0, _x1, _x2, _x3);
        }
    }

    private static final AddressLayout SessionGetInputName$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("SessionGetInputName"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetInputName)(const OrtSession *, size_t, OrtAllocator *, char **)
     * }
     */
    public static final AddressLayout SessionGetInputName$layout() {
        return SessionGetInputName$LAYOUT;
    }

    private static final long SessionGetInputName$OFFSET = 288;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetInputName)(const OrtSession *, size_t, OrtAllocator *, char **)
     * }
     */
    public static final long SessionGetInputName$offset() {
        return SessionGetInputName$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetInputName)(const OrtSession *, size_t, OrtAllocator *, char **)
     * }
     */
    public static MemorySegment SessionGetInputName(MemorySegment struct) {
        return struct.get(SessionGetInputName$LAYOUT, SessionGetInputName$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetInputName)(const OrtSession *, size_t, OrtAllocator *, char **)
     * }
     */
    public static void SessionGetInputName(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SessionGetInputName$LAYOUT, SessionGetInputName$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetInputName)(const OrtSession *, size_t, OrtAllocator *, char **)
     * }
     */
    public static SessionGetInputName.Function SessionGetInputNameFunction(MemorySegment struct) {
        return SessionGetInputName.function(SessionGetInputName(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetOutputName)(const OrtSession *, size_t, OrtAllocator *, char **)
     * }
     */
    public static class SessionGetOutputName {

        SessionGetOutputName() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_LONG,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(SessionGetOutputName.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SessionGetOutputName.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr, MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static SessionGetOutputName.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2, _x3) -> invoke(funcPtr, _x0, _x1, _x2, _x3);
        }
    }

    private static final AddressLayout SessionGetOutputName$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("SessionGetOutputName"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetOutputName)(const OrtSession *, size_t, OrtAllocator *, char **)
     * }
     */
    public static final AddressLayout SessionGetOutputName$layout() {
        return SessionGetOutputName$LAYOUT;
    }

    private static final long SessionGetOutputName$OFFSET = 296;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetOutputName)(const OrtSession *, size_t, OrtAllocator *, char **)
     * }
     */
    public static final long SessionGetOutputName$offset() {
        return SessionGetOutputName$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetOutputName)(const OrtSession *, size_t, OrtAllocator *, char **)
     * }
     */
    public static MemorySegment SessionGetOutputName(MemorySegment struct) {
        return struct.get(SessionGetOutputName$LAYOUT, SessionGetOutputName$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetOutputName)(const OrtSession *, size_t, OrtAllocator *, char **)
     * }
     */
    public static void SessionGetOutputName(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SessionGetOutputName$LAYOUT, SessionGetOutputName$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetOutputName)(const OrtSession *, size_t, OrtAllocator *, char **)
     * }
     */
    public static SessionGetOutputName.Function SessionGetOutputNameFunction(MemorySegment struct) {
        return SessionGetOutputName.function(SessionGetOutputName(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetOverridableInitializerName)(const OrtSession *, size_t, OrtAllocator *, char **)
     * }
     */
    public static class SessionGetOverridableInitializerName {

        SessionGetOverridableInitializerName() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_LONG,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(SessionGetOverridableInitializerName.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SessionGetOverridableInitializerName.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr, MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static SessionGetOverridableInitializerName.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2, _x3) -> invoke(funcPtr, _x0, _x1, _x2, _x3);
        }
    }

    private static final AddressLayout SessionGetOverridableInitializerName$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("SessionGetOverridableInitializerName"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetOverridableInitializerName)(const OrtSession *, size_t, OrtAllocator *, char **)
     * }
     */
    public static final AddressLayout SessionGetOverridableInitializerName$layout() {
        return SessionGetOverridableInitializerName$LAYOUT;
    }

    private static final long SessionGetOverridableInitializerName$OFFSET = 304;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetOverridableInitializerName)(const OrtSession *, size_t, OrtAllocator *, char **)
     * }
     */
    public static final long SessionGetOverridableInitializerName$offset() {
        return SessionGetOverridableInitializerName$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetOverridableInitializerName)(const OrtSession *, size_t, OrtAllocator *, char **)
     * }
     */
    public static MemorySegment SessionGetOverridableInitializerName(MemorySegment struct) {
        return struct.get(SessionGetOverridableInitializerName$LAYOUT, SessionGetOverridableInitializerName$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetOverridableInitializerName)(const OrtSession *, size_t, OrtAllocator *, char **)
     * }
     */
    public static void SessionGetOverridableInitializerName(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(
                SessionGetOverridableInitializerName$LAYOUT, SessionGetOverridableInitializerName$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetOverridableInitializerName)(const OrtSession *, size_t, OrtAllocator *, char **)
     * }
     */
    public static SessionGetOverridableInitializerName.Function SessionGetOverridableInitializerNameFunction(
            MemorySegment struct) {
        return SessionGetOverridableInitializerName.function(SessionGetOverridableInitializerName(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateRunOptions)(OrtRunOptions **)
     * }
     */
    public static class CreateRunOptions {

        CreateRunOptions() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC =
                FunctionDescriptor.of(onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(CreateRunOptions.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateRunOptions.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static CreateRunOptions.Function function(MemorySegment funcPtr) {
            return (_x0) -> invoke(funcPtr, _x0);
        }
    }

    private static final AddressLayout CreateRunOptions$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("CreateRunOptions"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateRunOptions)(OrtRunOptions **)
     * }
     */
    public static final AddressLayout CreateRunOptions$layout() {
        return CreateRunOptions$LAYOUT;
    }

    private static final long CreateRunOptions$OFFSET = 312;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateRunOptions)(OrtRunOptions **)
     * }
     */
    public static final long CreateRunOptions$offset() {
        return CreateRunOptions$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateRunOptions)(OrtRunOptions **)
     * }
     */
    public static MemorySegment CreateRunOptions(MemorySegment struct) {
        return struct.get(CreateRunOptions$LAYOUT, CreateRunOptions$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateRunOptions)(OrtRunOptions **)
     * }
     */
    public static void CreateRunOptions(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateRunOptions$LAYOUT, CreateRunOptions$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateRunOptions)(OrtRunOptions **)
     * }
     */
    public static CreateRunOptions.Function CreateRunOptionsFunction(MemorySegment struct) {
        return CreateRunOptions.function(CreateRunOptions(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsSetRunLogVerbosityLevel)(OrtRunOptions *, int)
     * }
     */
    public static class RunOptionsSetRunLogVerbosityLevel {

        RunOptionsSetRunLogVerbosityLevel() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, int _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_INT);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(RunOptionsSetRunLogVerbosityLevel.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(RunOptionsSetRunLogVerbosityLevel.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, int _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static RunOptionsSetRunLogVerbosityLevel.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout RunOptionsSetRunLogVerbosityLevel$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("RunOptionsSetRunLogVerbosityLevel"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsSetRunLogVerbosityLevel)(OrtRunOptions *, int)
     * }
     */
    public static final AddressLayout RunOptionsSetRunLogVerbosityLevel$layout() {
        return RunOptionsSetRunLogVerbosityLevel$LAYOUT;
    }

    private static final long RunOptionsSetRunLogVerbosityLevel$OFFSET = 320;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsSetRunLogVerbosityLevel)(OrtRunOptions *, int)
     * }
     */
    public static final long RunOptionsSetRunLogVerbosityLevel$offset() {
        return RunOptionsSetRunLogVerbosityLevel$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsSetRunLogVerbosityLevel)(OrtRunOptions *, int)
     * }
     */
    public static MemorySegment RunOptionsSetRunLogVerbosityLevel(MemorySegment struct) {
        return struct.get(RunOptionsSetRunLogVerbosityLevel$LAYOUT, RunOptionsSetRunLogVerbosityLevel$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsSetRunLogVerbosityLevel)(OrtRunOptions *, int)
     * }
     */
    public static void RunOptionsSetRunLogVerbosityLevel(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(RunOptionsSetRunLogVerbosityLevel$LAYOUT, RunOptionsSetRunLogVerbosityLevel$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsSetRunLogVerbosityLevel)(OrtRunOptions *, int)
     * }
     */
    public static RunOptionsSetRunLogVerbosityLevel.Function RunOptionsSetRunLogVerbosityLevelFunction(
            MemorySegment struct) {
        return RunOptionsSetRunLogVerbosityLevel.function(RunOptionsSetRunLogVerbosityLevel(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsSetRunLogSeverityLevel)(OrtRunOptions *, int)
     * }
     */
    public static class RunOptionsSetRunLogSeverityLevel {

        RunOptionsSetRunLogSeverityLevel() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, int _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_INT);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(RunOptionsSetRunLogSeverityLevel.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(RunOptionsSetRunLogSeverityLevel.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, int _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static RunOptionsSetRunLogSeverityLevel.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout RunOptionsSetRunLogSeverityLevel$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("RunOptionsSetRunLogSeverityLevel"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsSetRunLogSeverityLevel)(OrtRunOptions *, int)
     * }
     */
    public static final AddressLayout RunOptionsSetRunLogSeverityLevel$layout() {
        return RunOptionsSetRunLogSeverityLevel$LAYOUT;
    }

    private static final long RunOptionsSetRunLogSeverityLevel$OFFSET = 328;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsSetRunLogSeverityLevel)(OrtRunOptions *, int)
     * }
     */
    public static final long RunOptionsSetRunLogSeverityLevel$offset() {
        return RunOptionsSetRunLogSeverityLevel$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsSetRunLogSeverityLevel)(OrtRunOptions *, int)
     * }
     */
    public static MemorySegment RunOptionsSetRunLogSeverityLevel(MemorySegment struct) {
        return struct.get(RunOptionsSetRunLogSeverityLevel$LAYOUT, RunOptionsSetRunLogSeverityLevel$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsSetRunLogSeverityLevel)(OrtRunOptions *, int)
     * }
     */
    public static void RunOptionsSetRunLogSeverityLevel(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(RunOptionsSetRunLogSeverityLevel$LAYOUT, RunOptionsSetRunLogSeverityLevel$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsSetRunLogSeverityLevel)(OrtRunOptions *, int)
     * }
     */
    public static RunOptionsSetRunLogSeverityLevel.Function RunOptionsSetRunLogSeverityLevelFunction(
            MemorySegment struct) {
        return RunOptionsSetRunLogSeverityLevel.function(RunOptionsSetRunLogSeverityLevel(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsSetRunTag)(OrtRunOptions *, const char *)
     * }
     */
    public static class RunOptionsSetRunTag {

        RunOptionsSetRunTag() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(RunOptionsSetRunTag.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(RunOptionsSetRunTag.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static RunOptionsSetRunTag.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout RunOptionsSetRunTag$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("RunOptionsSetRunTag"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsSetRunTag)(OrtRunOptions *, const char *)
     * }
     */
    public static final AddressLayout RunOptionsSetRunTag$layout() {
        return RunOptionsSetRunTag$LAYOUT;
    }

    private static final long RunOptionsSetRunTag$OFFSET = 336;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsSetRunTag)(OrtRunOptions *, const char *)
     * }
     */
    public static final long RunOptionsSetRunTag$offset() {
        return RunOptionsSetRunTag$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsSetRunTag)(OrtRunOptions *, const char *)
     * }
     */
    public static MemorySegment RunOptionsSetRunTag(MemorySegment struct) {
        return struct.get(RunOptionsSetRunTag$LAYOUT, RunOptionsSetRunTag$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsSetRunTag)(OrtRunOptions *, const char *)
     * }
     */
    public static void RunOptionsSetRunTag(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(RunOptionsSetRunTag$LAYOUT, RunOptionsSetRunTag$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsSetRunTag)(OrtRunOptions *, const char *)
     * }
     */
    public static RunOptionsSetRunTag.Function RunOptionsSetRunTagFunction(MemorySegment struct) {
        return RunOptionsSetRunTag.function(RunOptionsSetRunTag(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsGetRunLogVerbosityLevel)(const OrtRunOptions *, int *)
     * }
     */
    public static class RunOptionsGetRunLogVerbosityLevel {

        RunOptionsGetRunLogVerbosityLevel() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(RunOptionsGetRunLogVerbosityLevel.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(RunOptionsGetRunLogVerbosityLevel.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static RunOptionsGetRunLogVerbosityLevel.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout RunOptionsGetRunLogVerbosityLevel$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("RunOptionsGetRunLogVerbosityLevel"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsGetRunLogVerbosityLevel)(const OrtRunOptions *, int *)
     * }
     */
    public static final AddressLayout RunOptionsGetRunLogVerbosityLevel$layout() {
        return RunOptionsGetRunLogVerbosityLevel$LAYOUT;
    }

    private static final long RunOptionsGetRunLogVerbosityLevel$OFFSET = 344;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsGetRunLogVerbosityLevel)(const OrtRunOptions *, int *)
     * }
     */
    public static final long RunOptionsGetRunLogVerbosityLevel$offset() {
        return RunOptionsGetRunLogVerbosityLevel$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsGetRunLogVerbosityLevel)(const OrtRunOptions *, int *)
     * }
     */
    public static MemorySegment RunOptionsGetRunLogVerbosityLevel(MemorySegment struct) {
        return struct.get(RunOptionsGetRunLogVerbosityLevel$LAYOUT, RunOptionsGetRunLogVerbosityLevel$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsGetRunLogVerbosityLevel)(const OrtRunOptions *, int *)
     * }
     */
    public static void RunOptionsGetRunLogVerbosityLevel(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(RunOptionsGetRunLogVerbosityLevel$LAYOUT, RunOptionsGetRunLogVerbosityLevel$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsGetRunLogVerbosityLevel)(const OrtRunOptions *, int *)
     * }
     */
    public static RunOptionsGetRunLogVerbosityLevel.Function RunOptionsGetRunLogVerbosityLevelFunction(
            MemorySegment struct) {
        return RunOptionsGetRunLogVerbosityLevel.function(RunOptionsGetRunLogVerbosityLevel(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsGetRunLogSeverityLevel)(const OrtRunOptions *, int *)
     * }
     */
    public static class RunOptionsGetRunLogSeverityLevel {

        RunOptionsGetRunLogSeverityLevel() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(RunOptionsGetRunLogSeverityLevel.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(RunOptionsGetRunLogSeverityLevel.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static RunOptionsGetRunLogSeverityLevel.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout RunOptionsGetRunLogSeverityLevel$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("RunOptionsGetRunLogSeverityLevel"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsGetRunLogSeverityLevel)(const OrtRunOptions *, int *)
     * }
     */
    public static final AddressLayout RunOptionsGetRunLogSeverityLevel$layout() {
        return RunOptionsGetRunLogSeverityLevel$LAYOUT;
    }

    private static final long RunOptionsGetRunLogSeverityLevel$OFFSET = 352;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsGetRunLogSeverityLevel)(const OrtRunOptions *, int *)
     * }
     */
    public static final long RunOptionsGetRunLogSeverityLevel$offset() {
        return RunOptionsGetRunLogSeverityLevel$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsGetRunLogSeverityLevel)(const OrtRunOptions *, int *)
     * }
     */
    public static MemorySegment RunOptionsGetRunLogSeverityLevel(MemorySegment struct) {
        return struct.get(RunOptionsGetRunLogSeverityLevel$LAYOUT, RunOptionsGetRunLogSeverityLevel$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsGetRunLogSeverityLevel)(const OrtRunOptions *, int *)
     * }
     */
    public static void RunOptionsGetRunLogSeverityLevel(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(RunOptionsGetRunLogSeverityLevel$LAYOUT, RunOptionsGetRunLogSeverityLevel$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsGetRunLogSeverityLevel)(const OrtRunOptions *, int *)
     * }
     */
    public static RunOptionsGetRunLogSeverityLevel.Function RunOptionsGetRunLogSeverityLevelFunction(
            MemorySegment struct) {
        return RunOptionsGetRunLogSeverityLevel.function(RunOptionsGetRunLogSeverityLevel(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsGetRunTag)(const OrtRunOptions *, const char **)
     * }
     */
    public static class RunOptionsGetRunTag {

        RunOptionsGetRunTag() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(RunOptionsGetRunTag.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(RunOptionsGetRunTag.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static RunOptionsGetRunTag.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout RunOptionsGetRunTag$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("RunOptionsGetRunTag"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsGetRunTag)(const OrtRunOptions *, const char **)
     * }
     */
    public static final AddressLayout RunOptionsGetRunTag$layout() {
        return RunOptionsGetRunTag$LAYOUT;
    }

    private static final long RunOptionsGetRunTag$OFFSET = 360;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsGetRunTag)(const OrtRunOptions *, const char **)
     * }
     */
    public static final long RunOptionsGetRunTag$offset() {
        return RunOptionsGetRunTag$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsGetRunTag)(const OrtRunOptions *, const char **)
     * }
     */
    public static MemorySegment RunOptionsGetRunTag(MemorySegment struct) {
        return struct.get(RunOptionsGetRunTag$LAYOUT, RunOptionsGetRunTag$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsGetRunTag)(const OrtRunOptions *, const char **)
     * }
     */
    public static void RunOptionsGetRunTag(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(RunOptionsGetRunTag$LAYOUT, RunOptionsGetRunTag$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsGetRunTag)(const OrtRunOptions *, const char **)
     * }
     */
    public static RunOptionsGetRunTag.Function RunOptionsGetRunTagFunction(MemorySegment struct) {
        return RunOptionsGetRunTag.function(RunOptionsGetRunTag(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsSetTerminate)(OrtRunOptions *)
     * }
     */
    public static class RunOptionsSetTerminate {

        RunOptionsSetTerminate() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC =
                FunctionDescriptor.of(onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(RunOptionsSetTerminate.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(RunOptionsSetTerminate.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static RunOptionsSetTerminate.Function function(MemorySegment funcPtr) {
            return (_x0) -> invoke(funcPtr, _x0);
        }
    }

    private static final AddressLayout RunOptionsSetTerminate$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("RunOptionsSetTerminate"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsSetTerminate)(OrtRunOptions *)
     * }
     */
    public static final AddressLayout RunOptionsSetTerminate$layout() {
        return RunOptionsSetTerminate$LAYOUT;
    }

    private static final long RunOptionsSetTerminate$OFFSET = 368;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsSetTerminate)(OrtRunOptions *)
     * }
     */
    public static final long RunOptionsSetTerminate$offset() {
        return RunOptionsSetTerminate$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsSetTerminate)(OrtRunOptions *)
     * }
     */
    public static MemorySegment RunOptionsSetTerminate(MemorySegment struct) {
        return struct.get(RunOptionsSetTerminate$LAYOUT, RunOptionsSetTerminate$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsSetTerminate)(OrtRunOptions *)
     * }
     */
    public static void RunOptionsSetTerminate(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(RunOptionsSetTerminate$LAYOUT, RunOptionsSetTerminate$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsSetTerminate)(OrtRunOptions *)
     * }
     */
    public static RunOptionsSetTerminate.Function RunOptionsSetTerminateFunction(MemorySegment struct) {
        return RunOptionsSetTerminate.function(RunOptionsSetTerminate(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsUnsetTerminate)(OrtRunOptions *)
     * }
     */
    public static class RunOptionsUnsetTerminate {

        RunOptionsUnsetTerminate() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC =
                FunctionDescriptor.of(onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(RunOptionsUnsetTerminate.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(RunOptionsUnsetTerminate.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static RunOptionsUnsetTerminate.Function function(MemorySegment funcPtr) {
            return (_x0) -> invoke(funcPtr, _x0);
        }
    }

    private static final AddressLayout RunOptionsUnsetTerminate$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("RunOptionsUnsetTerminate"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsUnsetTerminate)(OrtRunOptions *)
     * }
     */
    public static final AddressLayout RunOptionsUnsetTerminate$layout() {
        return RunOptionsUnsetTerminate$LAYOUT;
    }

    private static final long RunOptionsUnsetTerminate$OFFSET = 376;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsUnsetTerminate)(OrtRunOptions *)
     * }
     */
    public static final long RunOptionsUnsetTerminate$offset() {
        return RunOptionsUnsetTerminate$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsUnsetTerminate)(OrtRunOptions *)
     * }
     */
    public static MemorySegment RunOptionsUnsetTerminate(MemorySegment struct) {
        return struct.get(RunOptionsUnsetTerminate$LAYOUT, RunOptionsUnsetTerminate$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsUnsetTerminate)(OrtRunOptions *)
     * }
     */
    public static void RunOptionsUnsetTerminate(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(RunOptionsUnsetTerminate$LAYOUT, RunOptionsUnsetTerminate$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsUnsetTerminate)(OrtRunOptions *)
     * }
     */
    public static RunOptionsUnsetTerminate.Function RunOptionsUnsetTerminateFunction(MemorySegment struct) {
        return RunOptionsUnsetTerminate.function(RunOptionsUnsetTerminate(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateTensorAsOrtValue)(OrtAllocator *, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)
     * }
     */
    public static class CreateTensorAsOrtValue {

        CreateTensorAsOrtValue() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2, int _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_LONG,
                onnxruntime_all_h.C_INT,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(CreateTensorAsOrtValue.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateTensorAsOrtValue.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, long _x2, int _x3, MemorySegment _x4) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static CreateTensorAsOrtValue.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2, _x3, _x4) -> invoke(funcPtr, _x0, _x1, _x2, _x3, _x4);
        }
    }

    private static final AddressLayout CreateTensorAsOrtValue$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("CreateTensorAsOrtValue"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateTensorAsOrtValue)(OrtAllocator *, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)
     * }
     */
    public static final AddressLayout CreateTensorAsOrtValue$layout() {
        return CreateTensorAsOrtValue$LAYOUT;
    }

    private static final long CreateTensorAsOrtValue$OFFSET = 384;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateTensorAsOrtValue)(OrtAllocator *, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)
     * }
     */
    public static final long CreateTensorAsOrtValue$offset() {
        return CreateTensorAsOrtValue$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateTensorAsOrtValue)(OrtAllocator *, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)
     * }
     */
    public static MemorySegment CreateTensorAsOrtValue(MemorySegment struct) {
        return struct.get(CreateTensorAsOrtValue$LAYOUT, CreateTensorAsOrtValue$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateTensorAsOrtValue)(OrtAllocator *, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)
     * }
     */
    public static void CreateTensorAsOrtValue(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateTensorAsOrtValue$LAYOUT, CreateTensorAsOrtValue$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateTensorAsOrtValue)(OrtAllocator *, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)
     * }
     */
    public static CreateTensorAsOrtValue.Function CreateTensorAsOrtValueFunction(MemorySegment struct) {
        return CreateTensorAsOrtValue.function(CreateTensorAsOrtValue(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateTensorWithDataAsOrtValue)(const OrtMemoryInfo *, void *, size_t, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)
     * }
     */
    public static class CreateTensorWithDataAsOrtValue {

        CreateTensorWithDataAsOrtValue() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(
                    MemorySegment _x0,
                    MemorySegment _x1,
                    long _x2,
                    MemorySegment _x3,
                    long _x4,
                    int _x5,
                    MemorySegment _x6);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_LONG,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_LONG,
                onnxruntime_all_h.C_INT,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(CreateTensorWithDataAsOrtValue.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateTensorWithDataAsOrtValue.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr,
                MemorySegment _x0,
                MemorySegment _x1,
                long _x2,
                MemorySegment _x3,
                long _x4,
                int _x5,
                MemorySegment _x6) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static CreateTensorWithDataAsOrtValue.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2, _x3, _x4, _x5, _x6) -> invoke(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6);
        }
    }

    private static final AddressLayout CreateTensorWithDataAsOrtValue$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("CreateTensorWithDataAsOrtValue"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateTensorWithDataAsOrtValue)(const OrtMemoryInfo *, void *, size_t, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)
     * }
     */
    public static final AddressLayout CreateTensorWithDataAsOrtValue$layout() {
        return CreateTensorWithDataAsOrtValue$LAYOUT;
    }

    private static final long CreateTensorWithDataAsOrtValue$OFFSET = 392;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateTensorWithDataAsOrtValue)(const OrtMemoryInfo *, void *, size_t, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)
     * }
     */
    public static final long CreateTensorWithDataAsOrtValue$offset() {
        return CreateTensorWithDataAsOrtValue$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateTensorWithDataAsOrtValue)(const OrtMemoryInfo *, void *, size_t, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)
     * }
     */
    public static MemorySegment CreateTensorWithDataAsOrtValue(MemorySegment struct) {
        return struct.get(CreateTensorWithDataAsOrtValue$LAYOUT, CreateTensorWithDataAsOrtValue$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateTensorWithDataAsOrtValue)(const OrtMemoryInfo *, void *, size_t, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)
     * }
     */
    public static void CreateTensorWithDataAsOrtValue(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateTensorWithDataAsOrtValue$LAYOUT, CreateTensorWithDataAsOrtValue$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateTensorWithDataAsOrtValue)(const OrtMemoryInfo *, void *, size_t, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)
     * }
     */
    public static CreateTensorWithDataAsOrtValue.Function CreateTensorWithDataAsOrtValueFunction(MemorySegment struct) {
        return CreateTensorWithDataAsOrtValue.function(CreateTensorWithDataAsOrtValue(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*IsTensor)(const OrtValue *, int *)
     * }
     */
    public static class IsTensor {

        IsTensor() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(IsTensor.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(IsTensor.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static IsTensor.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout IsTensor$LAYOUT = (AddressLayout) $LAYOUT.select(groupElement("IsTensor"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*IsTensor)(const OrtValue *, int *)
     * }
     */
    public static final AddressLayout IsTensor$layout() {
        return IsTensor$LAYOUT;
    }

    private static final long IsTensor$OFFSET = 400;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*IsTensor)(const OrtValue *, int *)
     * }
     */
    public static final long IsTensor$offset() {
        return IsTensor$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*IsTensor)(const OrtValue *, int *)
     * }
     */
    public static MemorySegment IsTensor(MemorySegment struct) {
        return struct.get(IsTensor$LAYOUT, IsTensor$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*IsTensor)(const OrtValue *, int *)
     * }
     */
    public static void IsTensor(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(IsTensor$LAYOUT, IsTensor$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*IsTensor)(const OrtValue *, int *)
     * }
     */
    public static IsTensor.Function IsTensorFunction(MemorySegment struct) {
        return IsTensor.function(IsTensor(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorMutableData)(OrtValue *, void **)
     * }
     */
    public static class GetTensorMutableData {

        GetTensorMutableData() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(GetTensorMutableData.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetTensorMutableData.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static GetTensorMutableData.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout GetTensorMutableData$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("GetTensorMutableData"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorMutableData)(OrtValue *, void **)
     * }
     */
    public static final AddressLayout GetTensorMutableData$layout() {
        return GetTensorMutableData$LAYOUT;
    }

    private static final long GetTensorMutableData$OFFSET = 408;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorMutableData)(OrtValue *, void **)
     * }
     */
    public static final long GetTensorMutableData$offset() {
        return GetTensorMutableData$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorMutableData)(OrtValue *, void **)
     * }
     */
    public static MemorySegment GetTensorMutableData(MemorySegment struct) {
        return struct.get(GetTensorMutableData$LAYOUT, GetTensorMutableData$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorMutableData)(OrtValue *, void **)
     * }
     */
    public static void GetTensorMutableData(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetTensorMutableData$LAYOUT, GetTensorMutableData$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorMutableData)(OrtValue *, void **)
     * }
     */
    public static GetTensorMutableData.Function GetTensorMutableDataFunction(MemorySegment struct) {
        return GetTensorMutableData.function(GetTensorMutableData(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*FillStringTensor)(OrtValue *, const char *const *, size_t)
     * }
     */
    public static class FillStringTensor {

        FillStringTensor() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_LONG);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(FillStringTensor.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(FillStringTensor.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, long _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static FillStringTensor.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2) -> invoke(funcPtr, _x0, _x1, _x2);
        }
    }

    private static final AddressLayout FillStringTensor$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("FillStringTensor"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*FillStringTensor)(OrtValue *, const char *const *, size_t)
     * }
     */
    public static final AddressLayout FillStringTensor$layout() {
        return FillStringTensor$LAYOUT;
    }

    private static final long FillStringTensor$OFFSET = 416;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*FillStringTensor)(OrtValue *, const char *const *, size_t)
     * }
     */
    public static final long FillStringTensor$offset() {
        return FillStringTensor$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*FillStringTensor)(OrtValue *, const char *const *, size_t)
     * }
     */
    public static MemorySegment FillStringTensor(MemorySegment struct) {
        return struct.get(FillStringTensor$LAYOUT, FillStringTensor$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*FillStringTensor)(OrtValue *, const char *const *, size_t)
     * }
     */
    public static void FillStringTensor(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(FillStringTensor$LAYOUT, FillStringTensor$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*FillStringTensor)(OrtValue *, const char *const *, size_t)
     * }
     */
    public static FillStringTensor.Function FillStringTensorFunction(MemorySegment struct) {
        return FillStringTensor.function(FillStringTensor(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetStringTensorDataLength)(const OrtValue *, size_t *)
     * }
     */
    public static class GetStringTensorDataLength {

        GetStringTensorDataLength() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(GetStringTensorDataLength.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetStringTensorDataLength.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static GetStringTensorDataLength.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout GetStringTensorDataLength$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("GetStringTensorDataLength"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetStringTensorDataLength)(const OrtValue *, size_t *)
     * }
     */
    public static final AddressLayout GetStringTensorDataLength$layout() {
        return GetStringTensorDataLength$LAYOUT;
    }

    private static final long GetStringTensorDataLength$OFFSET = 424;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetStringTensorDataLength)(const OrtValue *, size_t *)
     * }
     */
    public static final long GetStringTensorDataLength$offset() {
        return GetStringTensorDataLength$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetStringTensorDataLength)(const OrtValue *, size_t *)
     * }
     */
    public static MemorySegment GetStringTensorDataLength(MemorySegment struct) {
        return struct.get(GetStringTensorDataLength$LAYOUT, GetStringTensorDataLength$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetStringTensorDataLength)(const OrtValue *, size_t *)
     * }
     */
    public static void GetStringTensorDataLength(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetStringTensorDataLength$LAYOUT, GetStringTensorDataLength$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetStringTensorDataLength)(const OrtValue *, size_t *)
     * }
     */
    public static GetStringTensorDataLength.Function GetStringTensorDataLengthFunction(MemorySegment struct) {
        return GetStringTensorDataLength.function(GetStringTensorDataLength(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetStringTensorContent)(const OrtValue *, void *, size_t, size_t *, size_t)
     * }
     */
    public static class GetStringTensorContent {

        GetStringTensorContent() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3, long _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_LONG,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_LONG);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(GetStringTensorContent.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetStringTensorContent.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3, long _x4) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static GetStringTensorContent.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2, _x3, _x4) -> invoke(funcPtr, _x0, _x1, _x2, _x3, _x4);
        }
    }

    private static final AddressLayout GetStringTensorContent$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("GetStringTensorContent"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetStringTensorContent)(const OrtValue *, void *, size_t, size_t *, size_t)
     * }
     */
    public static final AddressLayout GetStringTensorContent$layout() {
        return GetStringTensorContent$LAYOUT;
    }

    private static final long GetStringTensorContent$OFFSET = 432;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetStringTensorContent)(const OrtValue *, void *, size_t, size_t *, size_t)
     * }
     */
    public static final long GetStringTensorContent$offset() {
        return GetStringTensorContent$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetStringTensorContent)(const OrtValue *, void *, size_t, size_t *, size_t)
     * }
     */
    public static MemorySegment GetStringTensorContent(MemorySegment struct) {
        return struct.get(GetStringTensorContent$LAYOUT, GetStringTensorContent$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetStringTensorContent)(const OrtValue *, void *, size_t, size_t *, size_t)
     * }
     */
    public static void GetStringTensorContent(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetStringTensorContent$LAYOUT, GetStringTensorContent$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetStringTensorContent)(const OrtValue *, void *, size_t, size_t *, size_t)
     * }
     */
    public static GetStringTensorContent.Function GetStringTensorContentFunction(MemorySegment struct) {
        return GetStringTensorContent.function(GetStringTensorContent(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CastTypeInfoToTensorInfo)(const OrtTypeInfo *, const OrtTensorTypeAndShapeInfo **)
     * }
     */
    public static class CastTypeInfoToTensorInfo {

        CastTypeInfoToTensorInfo() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(CastTypeInfoToTensorInfo.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CastTypeInfoToTensorInfo.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static CastTypeInfoToTensorInfo.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout CastTypeInfoToTensorInfo$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("CastTypeInfoToTensorInfo"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CastTypeInfoToTensorInfo)(const OrtTypeInfo *, const OrtTensorTypeAndShapeInfo **)
     * }
     */
    public static final AddressLayout CastTypeInfoToTensorInfo$layout() {
        return CastTypeInfoToTensorInfo$LAYOUT;
    }

    private static final long CastTypeInfoToTensorInfo$OFFSET = 440;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CastTypeInfoToTensorInfo)(const OrtTypeInfo *, const OrtTensorTypeAndShapeInfo **)
     * }
     */
    public static final long CastTypeInfoToTensorInfo$offset() {
        return CastTypeInfoToTensorInfo$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CastTypeInfoToTensorInfo)(const OrtTypeInfo *, const OrtTensorTypeAndShapeInfo **)
     * }
     */
    public static MemorySegment CastTypeInfoToTensorInfo(MemorySegment struct) {
        return struct.get(CastTypeInfoToTensorInfo$LAYOUT, CastTypeInfoToTensorInfo$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CastTypeInfoToTensorInfo)(const OrtTypeInfo *, const OrtTensorTypeAndShapeInfo **)
     * }
     */
    public static void CastTypeInfoToTensorInfo(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CastTypeInfoToTensorInfo$LAYOUT, CastTypeInfoToTensorInfo$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CastTypeInfoToTensorInfo)(const OrtTypeInfo *, const OrtTensorTypeAndShapeInfo **)
     * }
     */
    public static CastTypeInfoToTensorInfo.Function CastTypeInfoToTensorInfoFunction(MemorySegment struct) {
        return CastTypeInfoToTensorInfo.function(CastTypeInfoToTensorInfo(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetOnnxTypeFromTypeInfo)(const OrtTypeInfo *, enum ONNXType *)
     * }
     */
    public static class GetOnnxTypeFromTypeInfo {

        GetOnnxTypeFromTypeInfo() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(GetOnnxTypeFromTypeInfo.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetOnnxTypeFromTypeInfo.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static GetOnnxTypeFromTypeInfo.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout GetOnnxTypeFromTypeInfo$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("GetOnnxTypeFromTypeInfo"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetOnnxTypeFromTypeInfo)(const OrtTypeInfo *, enum ONNXType *)
     * }
     */
    public static final AddressLayout GetOnnxTypeFromTypeInfo$layout() {
        return GetOnnxTypeFromTypeInfo$LAYOUT;
    }

    private static final long GetOnnxTypeFromTypeInfo$OFFSET = 448;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetOnnxTypeFromTypeInfo)(const OrtTypeInfo *, enum ONNXType *)
     * }
     */
    public static final long GetOnnxTypeFromTypeInfo$offset() {
        return GetOnnxTypeFromTypeInfo$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetOnnxTypeFromTypeInfo)(const OrtTypeInfo *, enum ONNXType *)
     * }
     */
    public static MemorySegment GetOnnxTypeFromTypeInfo(MemorySegment struct) {
        return struct.get(GetOnnxTypeFromTypeInfo$LAYOUT, GetOnnxTypeFromTypeInfo$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetOnnxTypeFromTypeInfo)(const OrtTypeInfo *, enum ONNXType *)
     * }
     */
    public static void GetOnnxTypeFromTypeInfo(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetOnnxTypeFromTypeInfo$LAYOUT, GetOnnxTypeFromTypeInfo$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetOnnxTypeFromTypeInfo)(const OrtTypeInfo *, enum ONNXType *)
     * }
     */
    public static GetOnnxTypeFromTypeInfo.Function GetOnnxTypeFromTypeInfoFunction(MemorySegment struct) {
        return GetOnnxTypeFromTypeInfo.function(GetOnnxTypeFromTypeInfo(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateTensorTypeAndShapeInfo)(OrtTensorTypeAndShapeInfo **)
     * }
     */
    public static class CreateTensorTypeAndShapeInfo {

        CreateTensorTypeAndShapeInfo() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC =
                FunctionDescriptor.of(onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(CreateTensorTypeAndShapeInfo.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateTensorTypeAndShapeInfo.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static CreateTensorTypeAndShapeInfo.Function function(MemorySegment funcPtr) {
            return (_x0) -> invoke(funcPtr, _x0);
        }
    }

    private static final AddressLayout CreateTensorTypeAndShapeInfo$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("CreateTensorTypeAndShapeInfo"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateTensorTypeAndShapeInfo)(OrtTensorTypeAndShapeInfo **)
     * }
     */
    public static final AddressLayout CreateTensorTypeAndShapeInfo$layout() {
        return CreateTensorTypeAndShapeInfo$LAYOUT;
    }

    private static final long CreateTensorTypeAndShapeInfo$OFFSET = 456;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateTensorTypeAndShapeInfo)(OrtTensorTypeAndShapeInfo **)
     * }
     */
    public static final long CreateTensorTypeAndShapeInfo$offset() {
        return CreateTensorTypeAndShapeInfo$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateTensorTypeAndShapeInfo)(OrtTensorTypeAndShapeInfo **)
     * }
     */
    public static MemorySegment CreateTensorTypeAndShapeInfo(MemorySegment struct) {
        return struct.get(CreateTensorTypeAndShapeInfo$LAYOUT, CreateTensorTypeAndShapeInfo$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateTensorTypeAndShapeInfo)(OrtTensorTypeAndShapeInfo **)
     * }
     */
    public static void CreateTensorTypeAndShapeInfo(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateTensorTypeAndShapeInfo$LAYOUT, CreateTensorTypeAndShapeInfo$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateTensorTypeAndShapeInfo)(OrtTensorTypeAndShapeInfo **)
     * }
     */
    public static CreateTensorTypeAndShapeInfo.Function CreateTensorTypeAndShapeInfoFunction(MemorySegment struct) {
        return CreateTensorTypeAndShapeInfo.function(CreateTensorTypeAndShapeInfo(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SetTensorElementType)(OrtTensorTypeAndShapeInfo *, enum ONNXTensorElementDataType)
     * }
     */
    public static class SetTensorElementType {

        SetTensorElementType() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, int _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_INT);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(SetTensorElementType.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetTensorElementType.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, int _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static SetTensorElementType.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout SetTensorElementType$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("SetTensorElementType"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetTensorElementType)(OrtTensorTypeAndShapeInfo *, enum ONNXTensorElementDataType)
     * }
     */
    public static final AddressLayout SetTensorElementType$layout() {
        return SetTensorElementType$LAYOUT;
    }

    private static final long SetTensorElementType$OFFSET = 464;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetTensorElementType)(OrtTensorTypeAndShapeInfo *, enum ONNXTensorElementDataType)
     * }
     */
    public static final long SetTensorElementType$offset() {
        return SetTensorElementType$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetTensorElementType)(OrtTensorTypeAndShapeInfo *, enum ONNXTensorElementDataType)
     * }
     */
    public static MemorySegment SetTensorElementType(MemorySegment struct) {
        return struct.get(SetTensorElementType$LAYOUT, SetTensorElementType$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetTensorElementType)(OrtTensorTypeAndShapeInfo *, enum ONNXTensorElementDataType)
     * }
     */
    public static void SetTensorElementType(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetTensorElementType$LAYOUT, SetTensorElementType$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetTensorElementType)(OrtTensorTypeAndShapeInfo *, enum ONNXTensorElementDataType)
     * }
     */
    public static SetTensorElementType.Function SetTensorElementTypeFunction(MemorySegment struct) {
        return SetTensorElementType.function(SetTensorElementType(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SetDimensions)(OrtTensorTypeAndShapeInfo *, const int64_t *, size_t)
     * }
     */
    public static class SetDimensions {

        SetDimensions() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_LONG);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(SetDimensions.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetDimensions.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, long _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static SetDimensions.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2) -> invoke(funcPtr, _x0, _x1, _x2);
        }
    }

    private static final AddressLayout SetDimensions$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("SetDimensions"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetDimensions)(OrtTensorTypeAndShapeInfo *, const int64_t *, size_t)
     * }
     */
    public static final AddressLayout SetDimensions$layout() {
        return SetDimensions$LAYOUT;
    }

    private static final long SetDimensions$OFFSET = 472;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetDimensions)(OrtTensorTypeAndShapeInfo *, const int64_t *, size_t)
     * }
     */
    public static final long SetDimensions$offset() {
        return SetDimensions$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetDimensions)(OrtTensorTypeAndShapeInfo *, const int64_t *, size_t)
     * }
     */
    public static MemorySegment SetDimensions(MemorySegment struct) {
        return struct.get(SetDimensions$LAYOUT, SetDimensions$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetDimensions)(OrtTensorTypeAndShapeInfo *, const int64_t *, size_t)
     * }
     */
    public static void SetDimensions(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetDimensions$LAYOUT, SetDimensions$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetDimensions)(OrtTensorTypeAndShapeInfo *, const int64_t *, size_t)
     * }
     */
    public static SetDimensions.Function SetDimensionsFunction(MemorySegment struct) {
        return SetDimensions.function(SetDimensions(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorElementType)(const OrtTensorTypeAndShapeInfo *, enum ONNXTensorElementDataType *)
     * }
     */
    public static class GetTensorElementType {

        GetTensorElementType() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(GetTensorElementType.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetTensorElementType.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static GetTensorElementType.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout GetTensorElementType$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("GetTensorElementType"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorElementType)(const OrtTensorTypeAndShapeInfo *, enum ONNXTensorElementDataType *)
     * }
     */
    public static final AddressLayout GetTensorElementType$layout() {
        return GetTensorElementType$LAYOUT;
    }

    private static final long GetTensorElementType$OFFSET = 480;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorElementType)(const OrtTensorTypeAndShapeInfo *, enum ONNXTensorElementDataType *)
     * }
     */
    public static final long GetTensorElementType$offset() {
        return GetTensorElementType$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorElementType)(const OrtTensorTypeAndShapeInfo *, enum ONNXTensorElementDataType *)
     * }
     */
    public static MemorySegment GetTensorElementType(MemorySegment struct) {
        return struct.get(GetTensorElementType$LAYOUT, GetTensorElementType$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorElementType)(const OrtTensorTypeAndShapeInfo *, enum ONNXTensorElementDataType *)
     * }
     */
    public static void GetTensorElementType(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetTensorElementType$LAYOUT, GetTensorElementType$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorElementType)(const OrtTensorTypeAndShapeInfo *, enum ONNXTensorElementDataType *)
     * }
     */
    public static GetTensorElementType.Function GetTensorElementTypeFunction(MemorySegment struct) {
        return GetTensorElementType.function(GetTensorElementType(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetDimensionsCount)(const OrtTensorTypeAndShapeInfo *, size_t *)
     * }
     */
    public static class GetDimensionsCount {

        GetDimensionsCount() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(GetDimensionsCount.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetDimensionsCount.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static GetDimensionsCount.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout GetDimensionsCount$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("GetDimensionsCount"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetDimensionsCount)(const OrtTensorTypeAndShapeInfo *, size_t *)
     * }
     */
    public static final AddressLayout GetDimensionsCount$layout() {
        return GetDimensionsCount$LAYOUT;
    }

    private static final long GetDimensionsCount$OFFSET = 488;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetDimensionsCount)(const OrtTensorTypeAndShapeInfo *, size_t *)
     * }
     */
    public static final long GetDimensionsCount$offset() {
        return GetDimensionsCount$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetDimensionsCount)(const OrtTensorTypeAndShapeInfo *, size_t *)
     * }
     */
    public static MemorySegment GetDimensionsCount(MemorySegment struct) {
        return struct.get(GetDimensionsCount$LAYOUT, GetDimensionsCount$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetDimensionsCount)(const OrtTensorTypeAndShapeInfo *, size_t *)
     * }
     */
    public static void GetDimensionsCount(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetDimensionsCount$LAYOUT, GetDimensionsCount$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetDimensionsCount)(const OrtTensorTypeAndShapeInfo *, size_t *)
     * }
     */
    public static GetDimensionsCount.Function GetDimensionsCountFunction(MemorySegment struct) {
        return GetDimensionsCount.function(GetDimensionsCount(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetDimensions)(const OrtTensorTypeAndShapeInfo *, int64_t *, size_t)
     * }
     */
    public static class GetDimensions {

        GetDimensions() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_LONG);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(GetDimensions.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetDimensions.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, long _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static GetDimensions.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2) -> invoke(funcPtr, _x0, _x1, _x2);
        }
    }

    private static final AddressLayout GetDimensions$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("GetDimensions"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetDimensions)(const OrtTensorTypeAndShapeInfo *, int64_t *, size_t)
     * }
     */
    public static final AddressLayout GetDimensions$layout() {
        return GetDimensions$LAYOUT;
    }

    private static final long GetDimensions$OFFSET = 496;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetDimensions)(const OrtTensorTypeAndShapeInfo *, int64_t *, size_t)
     * }
     */
    public static final long GetDimensions$offset() {
        return GetDimensions$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetDimensions)(const OrtTensorTypeAndShapeInfo *, int64_t *, size_t)
     * }
     */
    public static MemorySegment GetDimensions(MemorySegment struct) {
        return struct.get(GetDimensions$LAYOUT, GetDimensions$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetDimensions)(const OrtTensorTypeAndShapeInfo *, int64_t *, size_t)
     * }
     */
    public static void GetDimensions(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetDimensions$LAYOUT, GetDimensions$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetDimensions)(const OrtTensorTypeAndShapeInfo *, int64_t *, size_t)
     * }
     */
    public static GetDimensions.Function GetDimensionsFunction(MemorySegment struct) {
        return GetDimensions.function(GetDimensions(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSymbolicDimensions)(const OrtTensorTypeAndShapeInfo *, const char **, size_t)
     * }
     */
    public static class GetSymbolicDimensions {

        GetSymbolicDimensions() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_LONG);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(GetSymbolicDimensions.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetSymbolicDimensions.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, long _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static GetSymbolicDimensions.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2) -> invoke(funcPtr, _x0, _x1, _x2);
        }
    }

    private static final AddressLayout GetSymbolicDimensions$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("GetSymbolicDimensions"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSymbolicDimensions)(const OrtTensorTypeAndShapeInfo *, const char **, size_t)
     * }
     */
    public static final AddressLayout GetSymbolicDimensions$layout() {
        return GetSymbolicDimensions$LAYOUT;
    }

    private static final long GetSymbolicDimensions$OFFSET = 504;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSymbolicDimensions)(const OrtTensorTypeAndShapeInfo *, const char **, size_t)
     * }
     */
    public static final long GetSymbolicDimensions$offset() {
        return GetSymbolicDimensions$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSymbolicDimensions)(const OrtTensorTypeAndShapeInfo *, const char **, size_t)
     * }
     */
    public static MemorySegment GetSymbolicDimensions(MemorySegment struct) {
        return struct.get(GetSymbolicDimensions$LAYOUT, GetSymbolicDimensions$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSymbolicDimensions)(const OrtTensorTypeAndShapeInfo *, const char **, size_t)
     * }
     */
    public static void GetSymbolicDimensions(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetSymbolicDimensions$LAYOUT, GetSymbolicDimensions$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSymbolicDimensions)(const OrtTensorTypeAndShapeInfo *, const char **, size_t)
     * }
     */
    public static GetSymbolicDimensions.Function GetSymbolicDimensionsFunction(MemorySegment struct) {
        return GetSymbolicDimensions.function(GetSymbolicDimensions(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorShapeElementCount)(const OrtTensorTypeAndShapeInfo *, size_t *)
     * }
     */
    public static class GetTensorShapeElementCount {

        GetTensorShapeElementCount() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(GetTensorShapeElementCount.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetTensorShapeElementCount.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static GetTensorShapeElementCount.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout GetTensorShapeElementCount$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("GetTensorShapeElementCount"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorShapeElementCount)(const OrtTensorTypeAndShapeInfo *, size_t *)
     * }
     */
    public static final AddressLayout GetTensorShapeElementCount$layout() {
        return GetTensorShapeElementCount$LAYOUT;
    }

    private static final long GetTensorShapeElementCount$OFFSET = 512;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorShapeElementCount)(const OrtTensorTypeAndShapeInfo *, size_t *)
     * }
     */
    public static final long GetTensorShapeElementCount$offset() {
        return GetTensorShapeElementCount$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorShapeElementCount)(const OrtTensorTypeAndShapeInfo *, size_t *)
     * }
     */
    public static MemorySegment GetTensorShapeElementCount(MemorySegment struct) {
        return struct.get(GetTensorShapeElementCount$LAYOUT, GetTensorShapeElementCount$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorShapeElementCount)(const OrtTensorTypeAndShapeInfo *, size_t *)
     * }
     */
    public static void GetTensorShapeElementCount(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetTensorShapeElementCount$LAYOUT, GetTensorShapeElementCount$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorShapeElementCount)(const OrtTensorTypeAndShapeInfo *, size_t *)
     * }
     */
    public static GetTensorShapeElementCount.Function GetTensorShapeElementCountFunction(MemorySegment struct) {
        return GetTensorShapeElementCount.function(GetTensorShapeElementCount(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorTypeAndShape)(const OrtValue *, OrtTensorTypeAndShapeInfo **)
     * }
     */
    public static class GetTensorTypeAndShape {

        GetTensorTypeAndShape() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(GetTensorTypeAndShape.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetTensorTypeAndShape.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static GetTensorTypeAndShape.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout GetTensorTypeAndShape$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("GetTensorTypeAndShape"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorTypeAndShape)(const OrtValue *, OrtTensorTypeAndShapeInfo **)
     * }
     */
    public static final AddressLayout GetTensorTypeAndShape$layout() {
        return GetTensorTypeAndShape$LAYOUT;
    }

    private static final long GetTensorTypeAndShape$OFFSET = 520;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorTypeAndShape)(const OrtValue *, OrtTensorTypeAndShapeInfo **)
     * }
     */
    public static final long GetTensorTypeAndShape$offset() {
        return GetTensorTypeAndShape$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorTypeAndShape)(const OrtValue *, OrtTensorTypeAndShapeInfo **)
     * }
     */
    public static MemorySegment GetTensorTypeAndShape(MemorySegment struct) {
        return struct.get(GetTensorTypeAndShape$LAYOUT, GetTensorTypeAndShape$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorTypeAndShape)(const OrtValue *, OrtTensorTypeAndShapeInfo **)
     * }
     */
    public static void GetTensorTypeAndShape(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetTensorTypeAndShape$LAYOUT, GetTensorTypeAndShape$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorTypeAndShape)(const OrtValue *, OrtTensorTypeAndShapeInfo **)
     * }
     */
    public static GetTensorTypeAndShape.Function GetTensorTypeAndShapeFunction(MemorySegment struct) {
        return GetTensorTypeAndShape.function(GetTensorTypeAndShape(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTypeInfo)(const OrtValue *, OrtTypeInfo **)
     * }
     */
    public static class GetTypeInfo {

        GetTypeInfo() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(GetTypeInfo.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetTypeInfo.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static GetTypeInfo.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout GetTypeInfo$LAYOUT = (AddressLayout) $LAYOUT.select(groupElement("GetTypeInfo"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTypeInfo)(const OrtValue *, OrtTypeInfo **)
     * }
     */
    public static final AddressLayout GetTypeInfo$layout() {
        return GetTypeInfo$LAYOUT;
    }

    private static final long GetTypeInfo$OFFSET = 528;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTypeInfo)(const OrtValue *, OrtTypeInfo **)
     * }
     */
    public static final long GetTypeInfo$offset() {
        return GetTypeInfo$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTypeInfo)(const OrtValue *, OrtTypeInfo **)
     * }
     */
    public static MemorySegment GetTypeInfo(MemorySegment struct) {
        return struct.get(GetTypeInfo$LAYOUT, GetTypeInfo$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTypeInfo)(const OrtValue *, OrtTypeInfo **)
     * }
     */
    public static void GetTypeInfo(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetTypeInfo$LAYOUT, GetTypeInfo$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTypeInfo)(const OrtValue *, OrtTypeInfo **)
     * }
     */
    public static GetTypeInfo.Function GetTypeInfoFunction(MemorySegment struct) {
        return GetTypeInfo.function(GetTypeInfo(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetValueType)(const OrtValue *, enum ONNXType *)
     * }
     */
    public static class GetValueType {

        GetValueType() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(GetValueType.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetValueType.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static GetValueType.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout GetValueType$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("GetValueType"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetValueType)(const OrtValue *, enum ONNXType *)
     * }
     */
    public static final AddressLayout GetValueType$layout() {
        return GetValueType$LAYOUT;
    }

    private static final long GetValueType$OFFSET = 536;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetValueType)(const OrtValue *, enum ONNXType *)
     * }
     */
    public static final long GetValueType$offset() {
        return GetValueType$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetValueType)(const OrtValue *, enum ONNXType *)
     * }
     */
    public static MemorySegment GetValueType(MemorySegment struct) {
        return struct.get(GetValueType$LAYOUT, GetValueType$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetValueType)(const OrtValue *, enum ONNXType *)
     * }
     */
    public static void GetValueType(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetValueType$LAYOUT, GetValueType$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetValueType)(const OrtValue *, enum ONNXType *)
     * }
     */
    public static GetValueType.Function GetValueTypeFunction(MemorySegment struct) {
        return GetValueType.function(GetValueType(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateMemoryInfo)(const char *, enum OrtAllocatorType, int, enum OrtMemType, OrtMemoryInfo **)
     * }
     */
    public static class CreateMemoryInfo {

        CreateMemoryInfo() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, int _x1, int _x2, int _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_INT,
                onnxruntime_all_h.C_INT,
                onnxruntime_all_h.C_INT,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(CreateMemoryInfo.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateMemoryInfo.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr, MemorySegment _x0, int _x1, int _x2, int _x3, MemorySegment _x4) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static CreateMemoryInfo.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2, _x3, _x4) -> invoke(funcPtr, _x0, _x1, _x2, _x3, _x4);
        }
    }

    private static final AddressLayout CreateMemoryInfo$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("CreateMemoryInfo"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateMemoryInfo)(const char *, enum OrtAllocatorType, int, enum OrtMemType, OrtMemoryInfo **)
     * }
     */
    public static final AddressLayout CreateMemoryInfo$layout() {
        return CreateMemoryInfo$LAYOUT;
    }

    private static final long CreateMemoryInfo$OFFSET = 544;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateMemoryInfo)(const char *, enum OrtAllocatorType, int, enum OrtMemType, OrtMemoryInfo **)
     * }
     */
    public static final long CreateMemoryInfo$offset() {
        return CreateMemoryInfo$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateMemoryInfo)(const char *, enum OrtAllocatorType, int, enum OrtMemType, OrtMemoryInfo **)
     * }
     */
    public static MemorySegment CreateMemoryInfo(MemorySegment struct) {
        return struct.get(CreateMemoryInfo$LAYOUT, CreateMemoryInfo$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateMemoryInfo)(const char *, enum OrtAllocatorType, int, enum OrtMemType, OrtMemoryInfo **)
     * }
     */
    public static void CreateMemoryInfo(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateMemoryInfo$LAYOUT, CreateMemoryInfo$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateMemoryInfo)(const char *, enum OrtAllocatorType, int, enum OrtMemType, OrtMemoryInfo **)
     * }
     */
    public static CreateMemoryInfo.Function CreateMemoryInfoFunction(MemorySegment struct) {
        return CreateMemoryInfo.function(CreateMemoryInfo(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateCpuMemoryInfo)(enum OrtAllocatorType, enum OrtMemType, OrtMemoryInfo **)
     * }
     */
    public static class CreateCpuMemoryInfo {

        CreateCpuMemoryInfo() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(int _x0, int _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_INT,
                onnxruntime_all_h.C_INT,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(CreateCpuMemoryInfo.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateCpuMemoryInfo.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, int _x0, int _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static CreateCpuMemoryInfo.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2) -> invoke(funcPtr, _x0, _x1, _x2);
        }
    }

    private static final AddressLayout CreateCpuMemoryInfo$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("CreateCpuMemoryInfo"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateCpuMemoryInfo)(enum OrtAllocatorType, enum OrtMemType, OrtMemoryInfo **)
     * }
     */
    public static final AddressLayout CreateCpuMemoryInfo$layout() {
        return CreateCpuMemoryInfo$LAYOUT;
    }

    private static final long CreateCpuMemoryInfo$OFFSET = 552;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateCpuMemoryInfo)(enum OrtAllocatorType, enum OrtMemType, OrtMemoryInfo **)
     * }
     */
    public static final long CreateCpuMemoryInfo$offset() {
        return CreateCpuMemoryInfo$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateCpuMemoryInfo)(enum OrtAllocatorType, enum OrtMemType, OrtMemoryInfo **)
     * }
     */
    public static MemorySegment CreateCpuMemoryInfo(MemorySegment struct) {
        return struct.get(CreateCpuMemoryInfo$LAYOUT, CreateCpuMemoryInfo$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateCpuMemoryInfo)(enum OrtAllocatorType, enum OrtMemType, OrtMemoryInfo **)
     * }
     */
    public static void CreateCpuMemoryInfo(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateCpuMemoryInfo$LAYOUT, CreateCpuMemoryInfo$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateCpuMemoryInfo)(enum OrtAllocatorType, enum OrtMemType, OrtMemoryInfo **)
     * }
     */
    public static CreateCpuMemoryInfo.Function CreateCpuMemoryInfoFunction(MemorySegment struct) {
        return CreateCpuMemoryInfo.function(CreateCpuMemoryInfo(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CompareMemoryInfo)(const OrtMemoryInfo *, const OrtMemoryInfo *, int *)
     * }
     */
    public static class CompareMemoryInfo {

        CompareMemoryInfo() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(CompareMemoryInfo.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CompareMemoryInfo.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static CompareMemoryInfo.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2) -> invoke(funcPtr, _x0, _x1, _x2);
        }
    }

    private static final AddressLayout CompareMemoryInfo$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("CompareMemoryInfo"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CompareMemoryInfo)(const OrtMemoryInfo *, const OrtMemoryInfo *, int *)
     * }
     */
    public static final AddressLayout CompareMemoryInfo$layout() {
        return CompareMemoryInfo$LAYOUT;
    }

    private static final long CompareMemoryInfo$OFFSET = 560;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CompareMemoryInfo)(const OrtMemoryInfo *, const OrtMemoryInfo *, int *)
     * }
     */
    public static final long CompareMemoryInfo$offset() {
        return CompareMemoryInfo$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CompareMemoryInfo)(const OrtMemoryInfo *, const OrtMemoryInfo *, int *)
     * }
     */
    public static MemorySegment CompareMemoryInfo(MemorySegment struct) {
        return struct.get(CompareMemoryInfo$LAYOUT, CompareMemoryInfo$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CompareMemoryInfo)(const OrtMemoryInfo *, const OrtMemoryInfo *, int *)
     * }
     */
    public static void CompareMemoryInfo(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CompareMemoryInfo$LAYOUT, CompareMemoryInfo$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CompareMemoryInfo)(const OrtMemoryInfo *, const OrtMemoryInfo *, int *)
     * }
     */
    public static CompareMemoryInfo.Function CompareMemoryInfoFunction(MemorySegment struct) {
        return CompareMemoryInfo.function(CompareMemoryInfo(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*MemoryInfoGetName)(const OrtMemoryInfo *, const char **)
     * }
     */
    public static class MemoryInfoGetName {

        MemoryInfoGetName() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(MemoryInfoGetName.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(MemoryInfoGetName.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static MemoryInfoGetName.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout MemoryInfoGetName$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("MemoryInfoGetName"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*MemoryInfoGetName)(const OrtMemoryInfo *, const char **)
     * }
     */
    public static final AddressLayout MemoryInfoGetName$layout() {
        return MemoryInfoGetName$LAYOUT;
    }

    private static final long MemoryInfoGetName$OFFSET = 568;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*MemoryInfoGetName)(const OrtMemoryInfo *, const char **)
     * }
     */
    public static final long MemoryInfoGetName$offset() {
        return MemoryInfoGetName$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*MemoryInfoGetName)(const OrtMemoryInfo *, const char **)
     * }
     */
    public static MemorySegment MemoryInfoGetName(MemorySegment struct) {
        return struct.get(MemoryInfoGetName$LAYOUT, MemoryInfoGetName$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*MemoryInfoGetName)(const OrtMemoryInfo *, const char **)
     * }
     */
    public static void MemoryInfoGetName(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(MemoryInfoGetName$LAYOUT, MemoryInfoGetName$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*MemoryInfoGetName)(const OrtMemoryInfo *, const char **)
     * }
     */
    public static MemoryInfoGetName.Function MemoryInfoGetNameFunction(MemorySegment struct) {
        return MemoryInfoGetName.function(MemoryInfoGetName(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*MemoryInfoGetId)(const OrtMemoryInfo *, int *)
     * }
     */
    public static class MemoryInfoGetId {

        MemoryInfoGetId() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(MemoryInfoGetId.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(MemoryInfoGetId.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static MemoryInfoGetId.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout MemoryInfoGetId$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("MemoryInfoGetId"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*MemoryInfoGetId)(const OrtMemoryInfo *, int *)
     * }
     */
    public static final AddressLayout MemoryInfoGetId$layout() {
        return MemoryInfoGetId$LAYOUT;
    }

    private static final long MemoryInfoGetId$OFFSET = 576;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*MemoryInfoGetId)(const OrtMemoryInfo *, int *)
     * }
     */
    public static final long MemoryInfoGetId$offset() {
        return MemoryInfoGetId$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*MemoryInfoGetId)(const OrtMemoryInfo *, int *)
     * }
     */
    public static MemorySegment MemoryInfoGetId(MemorySegment struct) {
        return struct.get(MemoryInfoGetId$LAYOUT, MemoryInfoGetId$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*MemoryInfoGetId)(const OrtMemoryInfo *, int *)
     * }
     */
    public static void MemoryInfoGetId(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(MemoryInfoGetId$LAYOUT, MemoryInfoGetId$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*MemoryInfoGetId)(const OrtMemoryInfo *, int *)
     * }
     */
    public static MemoryInfoGetId.Function MemoryInfoGetIdFunction(MemorySegment struct) {
        return MemoryInfoGetId.function(MemoryInfoGetId(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*MemoryInfoGetMemType)(const OrtMemoryInfo *, OrtMemType *)
     * }
     */
    public static class MemoryInfoGetMemType {

        MemoryInfoGetMemType() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(MemoryInfoGetMemType.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(MemoryInfoGetMemType.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static MemoryInfoGetMemType.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout MemoryInfoGetMemType$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("MemoryInfoGetMemType"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*MemoryInfoGetMemType)(const OrtMemoryInfo *, OrtMemType *)
     * }
     */
    public static final AddressLayout MemoryInfoGetMemType$layout() {
        return MemoryInfoGetMemType$LAYOUT;
    }

    private static final long MemoryInfoGetMemType$OFFSET = 584;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*MemoryInfoGetMemType)(const OrtMemoryInfo *, OrtMemType *)
     * }
     */
    public static final long MemoryInfoGetMemType$offset() {
        return MemoryInfoGetMemType$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*MemoryInfoGetMemType)(const OrtMemoryInfo *, OrtMemType *)
     * }
     */
    public static MemorySegment MemoryInfoGetMemType(MemorySegment struct) {
        return struct.get(MemoryInfoGetMemType$LAYOUT, MemoryInfoGetMemType$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*MemoryInfoGetMemType)(const OrtMemoryInfo *, OrtMemType *)
     * }
     */
    public static void MemoryInfoGetMemType(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(MemoryInfoGetMemType$LAYOUT, MemoryInfoGetMemType$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*MemoryInfoGetMemType)(const OrtMemoryInfo *, OrtMemType *)
     * }
     */
    public static MemoryInfoGetMemType.Function MemoryInfoGetMemTypeFunction(MemorySegment struct) {
        return MemoryInfoGetMemType.function(MemoryInfoGetMemType(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*MemoryInfoGetType)(const OrtMemoryInfo *, OrtAllocatorType *)
     * }
     */
    public static class MemoryInfoGetType {

        MemoryInfoGetType() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(MemoryInfoGetType.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(MemoryInfoGetType.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static MemoryInfoGetType.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout MemoryInfoGetType$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("MemoryInfoGetType"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*MemoryInfoGetType)(const OrtMemoryInfo *, OrtAllocatorType *)
     * }
     */
    public static final AddressLayout MemoryInfoGetType$layout() {
        return MemoryInfoGetType$LAYOUT;
    }

    private static final long MemoryInfoGetType$OFFSET = 592;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*MemoryInfoGetType)(const OrtMemoryInfo *, OrtAllocatorType *)
     * }
     */
    public static final long MemoryInfoGetType$offset() {
        return MemoryInfoGetType$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*MemoryInfoGetType)(const OrtMemoryInfo *, OrtAllocatorType *)
     * }
     */
    public static MemorySegment MemoryInfoGetType(MemorySegment struct) {
        return struct.get(MemoryInfoGetType$LAYOUT, MemoryInfoGetType$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*MemoryInfoGetType)(const OrtMemoryInfo *, OrtAllocatorType *)
     * }
     */
    public static void MemoryInfoGetType(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(MemoryInfoGetType$LAYOUT, MemoryInfoGetType$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*MemoryInfoGetType)(const OrtMemoryInfo *, OrtAllocatorType *)
     * }
     */
    public static MemoryInfoGetType.Function MemoryInfoGetTypeFunction(MemorySegment struct) {
        return MemoryInfoGetType.function(MemoryInfoGetType(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*AllocatorAlloc)(OrtAllocator *, size_t, void **)
     * }
     */
    public static class AllocatorAlloc {

        AllocatorAlloc() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, long _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_LONG,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(AllocatorAlloc.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(AllocatorAlloc.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, long _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static AllocatorAlloc.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2) -> invoke(funcPtr, _x0, _x1, _x2);
        }
    }

    private static final AddressLayout AllocatorAlloc$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("AllocatorAlloc"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AllocatorAlloc)(OrtAllocator *, size_t, void **)
     * }
     */
    public static final AddressLayout AllocatorAlloc$layout() {
        return AllocatorAlloc$LAYOUT;
    }

    private static final long AllocatorAlloc$OFFSET = 600;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AllocatorAlloc)(OrtAllocator *, size_t, void **)
     * }
     */
    public static final long AllocatorAlloc$offset() {
        return AllocatorAlloc$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AllocatorAlloc)(OrtAllocator *, size_t, void **)
     * }
     */
    public static MemorySegment AllocatorAlloc(MemorySegment struct) {
        return struct.get(AllocatorAlloc$LAYOUT, AllocatorAlloc$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AllocatorAlloc)(OrtAllocator *, size_t, void **)
     * }
     */
    public static void AllocatorAlloc(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(AllocatorAlloc$LAYOUT, AllocatorAlloc$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AllocatorAlloc)(OrtAllocator *, size_t, void **)
     * }
     */
    public static AllocatorAlloc.Function AllocatorAllocFunction(MemorySegment struct) {
        return AllocatorAlloc.function(AllocatorAlloc(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*AllocatorFree)(OrtAllocator *, void *)
     * }
     */
    public static class AllocatorFree {

        AllocatorFree() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(AllocatorFree.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(AllocatorFree.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static AllocatorFree.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout AllocatorFree$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("AllocatorFree"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AllocatorFree)(OrtAllocator *, void *)
     * }
     */
    public static final AddressLayout AllocatorFree$layout() {
        return AllocatorFree$LAYOUT;
    }

    private static final long AllocatorFree$OFFSET = 608;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AllocatorFree)(OrtAllocator *, void *)
     * }
     */
    public static final long AllocatorFree$offset() {
        return AllocatorFree$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AllocatorFree)(OrtAllocator *, void *)
     * }
     */
    public static MemorySegment AllocatorFree(MemorySegment struct) {
        return struct.get(AllocatorFree$LAYOUT, AllocatorFree$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AllocatorFree)(OrtAllocator *, void *)
     * }
     */
    public static void AllocatorFree(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(AllocatorFree$LAYOUT, AllocatorFree$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AllocatorFree)(OrtAllocator *, void *)
     * }
     */
    public static AllocatorFree.Function AllocatorFreeFunction(MemorySegment struct) {
        return AllocatorFree.function(AllocatorFree(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*AllocatorGetInfo)(const OrtAllocator *, const struct OrtMemoryInfo **)
     * }
     */
    public static class AllocatorGetInfo {

        AllocatorGetInfo() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(AllocatorGetInfo.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(AllocatorGetInfo.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static AllocatorGetInfo.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout AllocatorGetInfo$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("AllocatorGetInfo"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AllocatorGetInfo)(const OrtAllocator *, const struct OrtMemoryInfo **)
     * }
     */
    public static final AddressLayout AllocatorGetInfo$layout() {
        return AllocatorGetInfo$LAYOUT;
    }

    private static final long AllocatorGetInfo$OFFSET = 616;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AllocatorGetInfo)(const OrtAllocator *, const struct OrtMemoryInfo **)
     * }
     */
    public static final long AllocatorGetInfo$offset() {
        return AllocatorGetInfo$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AllocatorGetInfo)(const OrtAllocator *, const struct OrtMemoryInfo **)
     * }
     */
    public static MemorySegment AllocatorGetInfo(MemorySegment struct) {
        return struct.get(AllocatorGetInfo$LAYOUT, AllocatorGetInfo$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AllocatorGetInfo)(const OrtAllocator *, const struct OrtMemoryInfo **)
     * }
     */
    public static void AllocatorGetInfo(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(AllocatorGetInfo$LAYOUT, AllocatorGetInfo$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AllocatorGetInfo)(const OrtAllocator *, const struct OrtMemoryInfo **)
     * }
     */
    public static AllocatorGetInfo.Function AllocatorGetInfoFunction(MemorySegment struct) {
        return AllocatorGetInfo.function(AllocatorGetInfo(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetAllocatorWithDefaultOptions)(OrtAllocator **)
     * }
     */
    public static class GetAllocatorWithDefaultOptions {

        GetAllocatorWithDefaultOptions() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC =
                FunctionDescriptor.of(onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(GetAllocatorWithDefaultOptions.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetAllocatorWithDefaultOptions.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static GetAllocatorWithDefaultOptions.Function function(MemorySegment funcPtr) {
            return (_x0) -> invoke(funcPtr, _x0);
        }
    }

    private static final AddressLayout GetAllocatorWithDefaultOptions$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("GetAllocatorWithDefaultOptions"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetAllocatorWithDefaultOptions)(OrtAllocator **)
     * }
     */
    public static final AddressLayout GetAllocatorWithDefaultOptions$layout() {
        return GetAllocatorWithDefaultOptions$LAYOUT;
    }

    private static final long GetAllocatorWithDefaultOptions$OFFSET = 624;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetAllocatorWithDefaultOptions)(OrtAllocator **)
     * }
     */
    public static final long GetAllocatorWithDefaultOptions$offset() {
        return GetAllocatorWithDefaultOptions$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetAllocatorWithDefaultOptions)(OrtAllocator **)
     * }
     */
    public static MemorySegment GetAllocatorWithDefaultOptions(MemorySegment struct) {
        return struct.get(GetAllocatorWithDefaultOptions$LAYOUT, GetAllocatorWithDefaultOptions$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetAllocatorWithDefaultOptions)(OrtAllocator **)
     * }
     */
    public static void GetAllocatorWithDefaultOptions(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetAllocatorWithDefaultOptions$LAYOUT, GetAllocatorWithDefaultOptions$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetAllocatorWithDefaultOptions)(OrtAllocator **)
     * }
     */
    public static GetAllocatorWithDefaultOptions.Function GetAllocatorWithDefaultOptionsFunction(MemorySegment struct) {
        return GetAllocatorWithDefaultOptions.function(GetAllocatorWithDefaultOptions(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*AddFreeDimensionOverride)(OrtSessionOptions *, const char *, int64_t)
     * }
     */
    public static class AddFreeDimensionOverride {

        AddFreeDimensionOverride() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_LONG_LONG);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(AddFreeDimensionOverride.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(AddFreeDimensionOverride.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, long _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static AddFreeDimensionOverride.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2) -> invoke(funcPtr, _x0, _x1, _x2);
        }
    }

    private static final AddressLayout AddFreeDimensionOverride$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("AddFreeDimensionOverride"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddFreeDimensionOverride)(OrtSessionOptions *, const char *, int64_t)
     * }
     */
    public static final AddressLayout AddFreeDimensionOverride$layout() {
        return AddFreeDimensionOverride$LAYOUT;
    }

    private static final long AddFreeDimensionOverride$OFFSET = 632;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddFreeDimensionOverride)(OrtSessionOptions *, const char *, int64_t)
     * }
     */
    public static final long AddFreeDimensionOverride$offset() {
        return AddFreeDimensionOverride$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddFreeDimensionOverride)(OrtSessionOptions *, const char *, int64_t)
     * }
     */
    public static MemorySegment AddFreeDimensionOverride(MemorySegment struct) {
        return struct.get(AddFreeDimensionOverride$LAYOUT, AddFreeDimensionOverride$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddFreeDimensionOverride)(OrtSessionOptions *, const char *, int64_t)
     * }
     */
    public static void AddFreeDimensionOverride(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(AddFreeDimensionOverride$LAYOUT, AddFreeDimensionOverride$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddFreeDimensionOverride)(OrtSessionOptions *, const char *, int64_t)
     * }
     */
    public static AddFreeDimensionOverride.Function AddFreeDimensionOverrideFunction(MemorySegment struct) {
        return AddFreeDimensionOverride.function(AddFreeDimensionOverride(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetValue)(const OrtValue *, int, OrtAllocator *, OrtValue **)
     * }
     */
    public static class GetValue {

        GetValue() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_INT,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(GetValue.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetValue.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr, MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static GetValue.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2, _x3) -> invoke(funcPtr, _x0, _x1, _x2, _x3);
        }
    }

    private static final AddressLayout GetValue$LAYOUT = (AddressLayout) $LAYOUT.select(groupElement("GetValue"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetValue)(const OrtValue *, int, OrtAllocator *, OrtValue **)
     * }
     */
    public static final AddressLayout GetValue$layout() {
        return GetValue$LAYOUT;
    }

    private static final long GetValue$OFFSET = 640;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetValue)(const OrtValue *, int, OrtAllocator *, OrtValue **)
     * }
     */
    public static final long GetValue$offset() {
        return GetValue$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetValue)(const OrtValue *, int, OrtAllocator *, OrtValue **)
     * }
     */
    public static MemorySegment GetValue(MemorySegment struct) {
        return struct.get(GetValue$LAYOUT, GetValue$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetValue)(const OrtValue *, int, OrtAllocator *, OrtValue **)
     * }
     */
    public static void GetValue(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetValue$LAYOUT, GetValue$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetValue)(const OrtValue *, int, OrtAllocator *, OrtValue **)
     * }
     */
    public static GetValue.Function GetValueFunction(MemorySegment struct) {
        return GetValue.function(GetValue(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetValueCount)(const OrtValue *, size_t *)
     * }
     */
    public static class GetValueCount {

        GetValueCount() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(GetValueCount.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetValueCount.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static GetValueCount.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout GetValueCount$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("GetValueCount"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetValueCount)(const OrtValue *, size_t *)
     * }
     */
    public static final AddressLayout GetValueCount$layout() {
        return GetValueCount$LAYOUT;
    }

    private static final long GetValueCount$OFFSET = 648;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetValueCount)(const OrtValue *, size_t *)
     * }
     */
    public static final long GetValueCount$offset() {
        return GetValueCount$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetValueCount)(const OrtValue *, size_t *)
     * }
     */
    public static MemorySegment GetValueCount(MemorySegment struct) {
        return struct.get(GetValueCount$LAYOUT, GetValueCount$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetValueCount)(const OrtValue *, size_t *)
     * }
     */
    public static void GetValueCount(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetValueCount$LAYOUT, GetValueCount$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetValueCount)(const OrtValue *, size_t *)
     * }
     */
    public static GetValueCount.Function GetValueCountFunction(MemorySegment struct) {
        return GetValueCount.function(GetValueCount(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateValue)(const OrtValue *const *, size_t, enum ONNXType, OrtValue **)
     * }
     */
    public static class CreateValue {

        CreateValue() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, long _x1, int _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_LONG,
                onnxruntime_all_h.C_INT,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(CreateValue.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateValue.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr, MemorySegment _x0, long _x1, int _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static CreateValue.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2, _x3) -> invoke(funcPtr, _x0, _x1, _x2, _x3);
        }
    }

    private static final AddressLayout CreateValue$LAYOUT = (AddressLayout) $LAYOUT.select(groupElement("CreateValue"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateValue)(const OrtValue *const *, size_t, enum ONNXType, OrtValue **)
     * }
     */
    public static final AddressLayout CreateValue$layout() {
        return CreateValue$LAYOUT;
    }

    private static final long CreateValue$OFFSET = 656;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateValue)(const OrtValue *const *, size_t, enum ONNXType, OrtValue **)
     * }
     */
    public static final long CreateValue$offset() {
        return CreateValue$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateValue)(const OrtValue *const *, size_t, enum ONNXType, OrtValue **)
     * }
     */
    public static MemorySegment CreateValue(MemorySegment struct) {
        return struct.get(CreateValue$LAYOUT, CreateValue$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateValue)(const OrtValue *const *, size_t, enum ONNXType, OrtValue **)
     * }
     */
    public static void CreateValue(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateValue$LAYOUT, CreateValue$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateValue)(const OrtValue *const *, size_t, enum ONNXType, OrtValue **)
     * }
     */
    public static CreateValue.Function CreateValueFunction(MemorySegment struct) {
        return CreateValue.function(CreateValue(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateOpaqueValue)(const char *, const char *, const void *, size_t, OrtValue **)
     * }
     */
    public static class CreateOpaqueValue {

        CreateOpaqueValue() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_LONG,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(CreateOpaqueValue.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateOpaqueValue.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr,
                MemorySegment _x0,
                MemorySegment _x1,
                MemorySegment _x2,
                long _x3,
                MemorySegment _x4) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static CreateOpaqueValue.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2, _x3, _x4) -> invoke(funcPtr, _x0, _x1, _x2, _x3, _x4);
        }
    }

    private static final AddressLayout CreateOpaqueValue$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("CreateOpaqueValue"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateOpaqueValue)(const char *, const char *, const void *, size_t, OrtValue **)
     * }
     */
    public static final AddressLayout CreateOpaqueValue$layout() {
        return CreateOpaqueValue$LAYOUT;
    }

    private static final long CreateOpaqueValue$OFFSET = 664;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateOpaqueValue)(const char *, const char *, const void *, size_t, OrtValue **)
     * }
     */
    public static final long CreateOpaqueValue$offset() {
        return CreateOpaqueValue$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateOpaqueValue)(const char *, const char *, const void *, size_t, OrtValue **)
     * }
     */
    public static MemorySegment CreateOpaqueValue(MemorySegment struct) {
        return struct.get(CreateOpaqueValue$LAYOUT, CreateOpaqueValue$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateOpaqueValue)(const char *, const char *, const void *, size_t, OrtValue **)
     * }
     */
    public static void CreateOpaqueValue(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateOpaqueValue$LAYOUT, CreateOpaqueValue$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateOpaqueValue)(const char *, const char *, const void *, size_t, OrtValue **)
     * }
     */
    public static CreateOpaqueValue.Function CreateOpaqueValueFunction(MemorySegment struct) {
        return CreateOpaqueValue.function(CreateOpaqueValue(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetOpaqueValue)(const char *, const char *, const OrtValue *, void *, size_t)
     * }
     */
    public static class GetOpaqueValue {

        GetOpaqueValue() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, long _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_LONG);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(GetOpaqueValue.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetOpaqueValue.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr,
                MemorySegment _x0,
                MemorySegment _x1,
                MemorySegment _x2,
                MemorySegment _x3,
                long _x4) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static GetOpaqueValue.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2, _x3, _x4) -> invoke(funcPtr, _x0, _x1, _x2, _x3, _x4);
        }
    }

    private static final AddressLayout GetOpaqueValue$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("GetOpaqueValue"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetOpaqueValue)(const char *, const char *, const OrtValue *, void *, size_t)
     * }
     */
    public static final AddressLayout GetOpaqueValue$layout() {
        return GetOpaqueValue$LAYOUT;
    }

    private static final long GetOpaqueValue$OFFSET = 672;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetOpaqueValue)(const char *, const char *, const OrtValue *, void *, size_t)
     * }
     */
    public static final long GetOpaqueValue$offset() {
        return GetOpaqueValue$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetOpaqueValue)(const char *, const char *, const OrtValue *, void *, size_t)
     * }
     */
    public static MemorySegment GetOpaqueValue(MemorySegment struct) {
        return struct.get(GetOpaqueValue$LAYOUT, GetOpaqueValue$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetOpaqueValue)(const char *, const char *, const OrtValue *, void *, size_t)
     * }
     */
    public static void GetOpaqueValue(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetOpaqueValue$LAYOUT, GetOpaqueValue$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetOpaqueValue)(const char *, const char *, const OrtValue *, void *, size_t)
     * }
     */
    public static GetOpaqueValue.Function GetOpaqueValueFunction(MemorySegment struct) {
        return GetOpaqueValue.function(GetOpaqueValue(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAttribute_float)(const OrtKernelInfo *, const char *, float *)
     * }
     */
    public static class KernelInfoGetAttribute_float {

        KernelInfoGetAttribute_float() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(KernelInfoGetAttribute_float.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(KernelInfoGetAttribute_float.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static KernelInfoGetAttribute_float.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2) -> invoke(funcPtr, _x0, _x1, _x2);
        }
    }

    private static final AddressLayout KernelInfoGetAttribute_float$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("KernelInfoGetAttribute_float"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAttribute_float)(const OrtKernelInfo *, const char *, float *)
     * }
     */
    public static final AddressLayout KernelInfoGetAttribute_float$layout() {
        return KernelInfoGetAttribute_float$LAYOUT;
    }

    private static final long KernelInfoGetAttribute_float$OFFSET = 680;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAttribute_float)(const OrtKernelInfo *, const char *, float *)
     * }
     */
    public static final long KernelInfoGetAttribute_float$offset() {
        return KernelInfoGetAttribute_float$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAttribute_float)(const OrtKernelInfo *, const char *, float *)
     * }
     */
    public static MemorySegment KernelInfoGetAttribute_float(MemorySegment struct) {
        return struct.get(KernelInfoGetAttribute_float$LAYOUT, KernelInfoGetAttribute_float$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAttribute_float)(const OrtKernelInfo *, const char *, float *)
     * }
     */
    public static void KernelInfoGetAttribute_float(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(KernelInfoGetAttribute_float$LAYOUT, KernelInfoGetAttribute_float$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAttribute_float)(const OrtKernelInfo *, const char *, float *)
     * }
     */
    public static KernelInfoGetAttribute_float.Function KernelInfoGetAttribute_floatFunction(MemorySegment struct) {
        return KernelInfoGetAttribute_float.function(KernelInfoGetAttribute_float(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAttribute_int64)(const OrtKernelInfo *, const char *, int64_t *)
     * }
     */
    public static class KernelInfoGetAttribute_int64 {

        KernelInfoGetAttribute_int64() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(KernelInfoGetAttribute_int64.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(KernelInfoGetAttribute_int64.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static KernelInfoGetAttribute_int64.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2) -> invoke(funcPtr, _x0, _x1, _x2);
        }
    }

    private static final AddressLayout KernelInfoGetAttribute_int64$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("KernelInfoGetAttribute_int64"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAttribute_int64)(const OrtKernelInfo *, const char *, int64_t *)
     * }
     */
    public static final AddressLayout KernelInfoGetAttribute_int64$layout() {
        return KernelInfoGetAttribute_int64$LAYOUT;
    }

    private static final long KernelInfoGetAttribute_int64$OFFSET = 688;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAttribute_int64)(const OrtKernelInfo *, const char *, int64_t *)
     * }
     */
    public static final long KernelInfoGetAttribute_int64$offset() {
        return KernelInfoGetAttribute_int64$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAttribute_int64)(const OrtKernelInfo *, const char *, int64_t *)
     * }
     */
    public static MemorySegment KernelInfoGetAttribute_int64(MemorySegment struct) {
        return struct.get(KernelInfoGetAttribute_int64$LAYOUT, KernelInfoGetAttribute_int64$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAttribute_int64)(const OrtKernelInfo *, const char *, int64_t *)
     * }
     */
    public static void KernelInfoGetAttribute_int64(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(KernelInfoGetAttribute_int64$LAYOUT, KernelInfoGetAttribute_int64$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAttribute_int64)(const OrtKernelInfo *, const char *, int64_t *)
     * }
     */
    public static KernelInfoGetAttribute_int64.Function KernelInfoGetAttribute_int64Function(MemorySegment struct) {
        return KernelInfoGetAttribute_int64.function(KernelInfoGetAttribute_int64(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAttribute_string)(const OrtKernelInfo *, const char *, char *, size_t *)
     * }
     */
    public static class KernelInfoGetAttribute_string {

        KernelInfoGetAttribute_string() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(KernelInfoGetAttribute_string.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(KernelInfoGetAttribute_string.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static KernelInfoGetAttribute_string.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2, _x3) -> invoke(funcPtr, _x0, _x1, _x2, _x3);
        }
    }

    private static final AddressLayout KernelInfoGetAttribute_string$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("KernelInfoGetAttribute_string"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAttribute_string)(const OrtKernelInfo *, const char *, char *, size_t *)
     * }
     */
    public static final AddressLayout KernelInfoGetAttribute_string$layout() {
        return KernelInfoGetAttribute_string$LAYOUT;
    }

    private static final long KernelInfoGetAttribute_string$OFFSET = 696;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAttribute_string)(const OrtKernelInfo *, const char *, char *, size_t *)
     * }
     */
    public static final long KernelInfoGetAttribute_string$offset() {
        return KernelInfoGetAttribute_string$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAttribute_string)(const OrtKernelInfo *, const char *, char *, size_t *)
     * }
     */
    public static MemorySegment KernelInfoGetAttribute_string(MemorySegment struct) {
        return struct.get(KernelInfoGetAttribute_string$LAYOUT, KernelInfoGetAttribute_string$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAttribute_string)(const OrtKernelInfo *, const char *, char *, size_t *)
     * }
     */
    public static void KernelInfoGetAttribute_string(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(KernelInfoGetAttribute_string$LAYOUT, KernelInfoGetAttribute_string$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAttribute_string)(const OrtKernelInfo *, const char *, char *, size_t *)
     * }
     */
    public static KernelInfoGetAttribute_string.Function KernelInfoGetAttribute_stringFunction(MemorySegment struct) {
        return KernelInfoGetAttribute_string.function(KernelInfoGetAttribute_string(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetInputCount)(const OrtKernelContext *, size_t *)
     * }
     */
    public static class KernelContext_GetInputCount {

        KernelContext_GetInputCount() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(KernelContext_GetInputCount.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(KernelContext_GetInputCount.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static KernelContext_GetInputCount.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout KernelContext_GetInputCount$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("KernelContext_GetInputCount"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetInputCount)(const OrtKernelContext *, size_t *)
     * }
     */
    public static final AddressLayout KernelContext_GetInputCount$layout() {
        return KernelContext_GetInputCount$LAYOUT;
    }

    private static final long KernelContext_GetInputCount$OFFSET = 704;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetInputCount)(const OrtKernelContext *, size_t *)
     * }
     */
    public static final long KernelContext_GetInputCount$offset() {
        return KernelContext_GetInputCount$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetInputCount)(const OrtKernelContext *, size_t *)
     * }
     */
    public static MemorySegment KernelContext_GetInputCount(MemorySegment struct) {
        return struct.get(KernelContext_GetInputCount$LAYOUT, KernelContext_GetInputCount$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetInputCount)(const OrtKernelContext *, size_t *)
     * }
     */
    public static void KernelContext_GetInputCount(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(KernelContext_GetInputCount$LAYOUT, KernelContext_GetInputCount$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetInputCount)(const OrtKernelContext *, size_t *)
     * }
     */
    public static KernelContext_GetInputCount.Function KernelContext_GetInputCountFunction(MemorySegment struct) {
        return KernelContext_GetInputCount.function(KernelContext_GetInputCount(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetOutputCount)(const OrtKernelContext *, size_t *)
     * }
     */
    public static class KernelContext_GetOutputCount {

        KernelContext_GetOutputCount() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(KernelContext_GetOutputCount.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(KernelContext_GetOutputCount.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static KernelContext_GetOutputCount.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout KernelContext_GetOutputCount$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("KernelContext_GetOutputCount"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetOutputCount)(const OrtKernelContext *, size_t *)
     * }
     */
    public static final AddressLayout KernelContext_GetOutputCount$layout() {
        return KernelContext_GetOutputCount$LAYOUT;
    }

    private static final long KernelContext_GetOutputCount$OFFSET = 712;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetOutputCount)(const OrtKernelContext *, size_t *)
     * }
     */
    public static final long KernelContext_GetOutputCount$offset() {
        return KernelContext_GetOutputCount$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetOutputCount)(const OrtKernelContext *, size_t *)
     * }
     */
    public static MemorySegment KernelContext_GetOutputCount(MemorySegment struct) {
        return struct.get(KernelContext_GetOutputCount$LAYOUT, KernelContext_GetOutputCount$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetOutputCount)(const OrtKernelContext *, size_t *)
     * }
     */
    public static void KernelContext_GetOutputCount(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(KernelContext_GetOutputCount$LAYOUT, KernelContext_GetOutputCount$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetOutputCount)(const OrtKernelContext *, size_t *)
     * }
     */
    public static KernelContext_GetOutputCount.Function KernelContext_GetOutputCountFunction(MemorySegment struct) {
        return KernelContext_GetOutputCount.function(KernelContext_GetOutputCount(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetInput)(const OrtKernelContext *, size_t, const OrtValue **)
     * }
     */
    public static class KernelContext_GetInput {

        KernelContext_GetInput() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, long _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_LONG,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(KernelContext_GetInput.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(KernelContext_GetInput.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, long _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static KernelContext_GetInput.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2) -> invoke(funcPtr, _x0, _x1, _x2);
        }
    }

    private static final AddressLayout KernelContext_GetInput$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("KernelContext_GetInput"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetInput)(const OrtKernelContext *, size_t, const OrtValue **)
     * }
     */
    public static final AddressLayout KernelContext_GetInput$layout() {
        return KernelContext_GetInput$LAYOUT;
    }

    private static final long KernelContext_GetInput$OFFSET = 720;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetInput)(const OrtKernelContext *, size_t, const OrtValue **)
     * }
     */
    public static final long KernelContext_GetInput$offset() {
        return KernelContext_GetInput$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetInput)(const OrtKernelContext *, size_t, const OrtValue **)
     * }
     */
    public static MemorySegment KernelContext_GetInput(MemorySegment struct) {
        return struct.get(KernelContext_GetInput$LAYOUT, KernelContext_GetInput$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetInput)(const OrtKernelContext *, size_t, const OrtValue **)
     * }
     */
    public static void KernelContext_GetInput(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(KernelContext_GetInput$LAYOUT, KernelContext_GetInput$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetInput)(const OrtKernelContext *, size_t, const OrtValue **)
     * }
     */
    public static KernelContext_GetInput.Function KernelContext_GetInputFunction(MemorySegment struct) {
        return KernelContext_GetInput.function(KernelContext_GetInput(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetOutput)(OrtKernelContext *, size_t, const int64_t *, size_t, OrtValue **)
     * }
     */
    public static class KernelContext_GetOutput {

        KernelContext_GetOutput() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, long _x1, MemorySegment _x2, long _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_LONG,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_LONG,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(KernelContext_GetOutput.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(KernelContext_GetOutput.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr, MemorySegment _x0, long _x1, MemorySegment _x2, long _x3, MemorySegment _x4) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static KernelContext_GetOutput.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2, _x3, _x4) -> invoke(funcPtr, _x0, _x1, _x2, _x3, _x4);
        }
    }

    private static final AddressLayout KernelContext_GetOutput$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("KernelContext_GetOutput"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetOutput)(OrtKernelContext *, size_t, const int64_t *, size_t, OrtValue **)
     * }
     */
    public static final AddressLayout KernelContext_GetOutput$layout() {
        return KernelContext_GetOutput$LAYOUT;
    }

    private static final long KernelContext_GetOutput$OFFSET = 728;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetOutput)(OrtKernelContext *, size_t, const int64_t *, size_t, OrtValue **)
     * }
     */
    public static final long KernelContext_GetOutput$offset() {
        return KernelContext_GetOutput$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetOutput)(OrtKernelContext *, size_t, const int64_t *, size_t, OrtValue **)
     * }
     */
    public static MemorySegment KernelContext_GetOutput(MemorySegment struct) {
        return struct.get(KernelContext_GetOutput$LAYOUT, KernelContext_GetOutput$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetOutput)(OrtKernelContext *, size_t, const int64_t *, size_t, OrtValue **)
     * }
     */
    public static void KernelContext_GetOutput(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(KernelContext_GetOutput$LAYOUT, KernelContext_GetOutput$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetOutput)(OrtKernelContext *, size_t, const int64_t *, size_t, OrtValue **)
     * }
     */
    public static KernelContext_GetOutput.Function KernelContext_GetOutputFunction(MemorySegment struct) {
        return KernelContext_GetOutput.function(KernelContext_GetOutput(struct));
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseEnv)(OrtEnv *)
     * }
     */
    public static class ReleaseEnv {

        ReleaseEnv() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(ReleaseEnv.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleaseEnv.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static ReleaseEnv.Function function(MemorySegment funcPtr) {
            return (_x0) -> invoke(funcPtr, _x0);
        }
    }

    private static final AddressLayout ReleaseEnv$LAYOUT = (AddressLayout) $LAYOUT.select(groupElement("ReleaseEnv"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ReleaseEnv)(OrtEnv *)
     * }
     */
    public static final AddressLayout ReleaseEnv$layout() {
        return ReleaseEnv$LAYOUT;
    }

    private static final long ReleaseEnv$OFFSET = 736;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ReleaseEnv)(OrtEnv *)
     * }
     */
    public static final long ReleaseEnv$offset() {
        return ReleaseEnv$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ReleaseEnv)(OrtEnv *)
     * }
     */
    public static MemorySegment ReleaseEnv(MemorySegment struct) {
        return struct.get(ReleaseEnv$LAYOUT, ReleaseEnv$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ReleaseEnv)(OrtEnv *)
     * }
     */
    public static void ReleaseEnv(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleaseEnv$LAYOUT, ReleaseEnv$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * void (*ReleaseEnv)(OrtEnv *)
     * }
     */
    public static ReleaseEnv.Function ReleaseEnvFunction(MemorySegment struct) {
        return ReleaseEnv.function(ReleaseEnv(struct));
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseStatus)(OrtStatus *)
     * }
     */
    public static class ReleaseStatus {

        ReleaseStatus() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(ReleaseStatus.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleaseStatus.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static ReleaseStatus.Function function(MemorySegment funcPtr) {
            return (_x0) -> invoke(funcPtr, _x0);
        }
    }

    private static final AddressLayout ReleaseStatus$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("ReleaseStatus"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ReleaseStatus)(OrtStatus *)
     * }
     */
    public static final AddressLayout ReleaseStatus$layout() {
        return ReleaseStatus$LAYOUT;
    }

    private static final long ReleaseStatus$OFFSET = 744;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ReleaseStatus)(OrtStatus *)
     * }
     */
    public static final long ReleaseStatus$offset() {
        return ReleaseStatus$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ReleaseStatus)(OrtStatus *)
     * }
     */
    public static MemorySegment ReleaseStatus(MemorySegment struct) {
        return struct.get(ReleaseStatus$LAYOUT, ReleaseStatus$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ReleaseStatus)(OrtStatus *)
     * }
     */
    public static void ReleaseStatus(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleaseStatus$LAYOUT, ReleaseStatus$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * void (*ReleaseStatus)(OrtStatus *)
     * }
     */
    public static ReleaseStatus.Function ReleaseStatusFunction(MemorySegment struct) {
        return ReleaseStatus.function(ReleaseStatus(struct));
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseMemoryInfo)(OrtMemoryInfo *)
     * }
     */
    public static class ReleaseMemoryInfo {

        ReleaseMemoryInfo() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(ReleaseMemoryInfo.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleaseMemoryInfo.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static ReleaseMemoryInfo.Function function(MemorySegment funcPtr) {
            return (_x0) -> invoke(funcPtr, _x0);
        }
    }

    private static final AddressLayout ReleaseMemoryInfo$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("ReleaseMemoryInfo"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ReleaseMemoryInfo)(OrtMemoryInfo *)
     * }
     */
    public static final AddressLayout ReleaseMemoryInfo$layout() {
        return ReleaseMemoryInfo$LAYOUT;
    }

    private static final long ReleaseMemoryInfo$OFFSET = 752;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ReleaseMemoryInfo)(OrtMemoryInfo *)
     * }
     */
    public static final long ReleaseMemoryInfo$offset() {
        return ReleaseMemoryInfo$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ReleaseMemoryInfo)(OrtMemoryInfo *)
     * }
     */
    public static MemorySegment ReleaseMemoryInfo(MemorySegment struct) {
        return struct.get(ReleaseMemoryInfo$LAYOUT, ReleaseMemoryInfo$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ReleaseMemoryInfo)(OrtMemoryInfo *)
     * }
     */
    public static void ReleaseMemoryInfo(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleaseMemoryInfo$LAYOUT, ReleaseMemoryInfo$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * void (*ReleaseMemoryInfo)(OrtMemoryInfo *)
     * }
     */
    public static ReleaseMemoryInfo.Function ReleaseMemoryInfoFunction(MemorySegment struct) {
        return ReleaseMemoryInfo.function(ReleaseMemoryInfo(struct));
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseSession)(OrtSession *)
     * }
     */
    public static class ReleaseSession {

        ReleaseSession() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(ReleaseSession.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleaseSession.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static ReleaseSession.Function function(MemorySegment funcPtr) {
            return (_x0) -> invoke(funcPtr, _x0);
        }
    }

    private static final AddressLayout ReleaseSession$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("ReleaseSession"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ReleaseSession)(OrtSession *)
     * }
     */
    public static final AddressLayout ReleaseSession$layout() {
        return ReleaseSession$LAYOUT;
    }

    private static final long ReleaseSession$OFFSET = 760;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ReleaseSession)(OrtSession *)
     * }
     */
    public static final long ReleaseSession$offset() {
        return ReleaseSession$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ReleaseSession)(OrtSession *)
     * }
     */
    public static MemorySegment ReleaseSession(MemorySegment struct) {
        return struct.get(ReleaseSession$LAYOUT, ReleaseSession$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ReleaseSession)(OrtSession *)
     * }
     */
    public static void ReleaseSession(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleaseSession$LAYOUT, ReleaseSession$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * void (*ReleaseSession)(OrtSession *)
     * }
     */
    public static ReleaseSession.Function ReleaseSessionFunction(MemorySegment struct) {
        return ReleaseSession.function(ReleaseSession(struct));
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseValue)(OrtValue *)
     * }
     */
    public static class ReleaseValue {

        ReleaseValue() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(ReleaseValue.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleaseValue.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static ReleaseValue.Function function(MemorySegment funcPtr) {
            return (_x0) -> invoke(funcPtr, _x0);
        }
    }

    private static final AddressLayout ReleaseValue$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("ReleaseValue"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ReleaseValue)(OrtValue *)
     * }
     */
    public static final AddressLayout ReleaseValue$layout() {
        return ReleaseValue$LAYOUT;
    }

    private static final long ReleaseValue$OFFSET = 768;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ReleaseValue)(OrtValue *)
     * }
     */
    public static final long ReleaseValue$offset() {
        return ReleaseValue$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ReleaseValue)(OrtValue *)
     * }
     */
    public static MemorySegment ReleaseValue(MemorySegment struct) {
        return struct.get(ReleaseValue$LAYOUT, ReleaseValue$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ReleaseValue)(OrtValue *)
     * }
     */
    public static void ReleaseValue(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleaseValue$LAYOUT, ReleaseValue$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * void (*ReleaseValue)(OrtValue *)
     * }
     */
    public static ReleaseValue.Function ReleaseValueFunction(MemorySegment struct) {
        return ReleaseValue.function(ReleaseValue(struct));
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseRunOptions)(OrtRunOptions *)
     * }
     */
    public static class ReleaseRunOptions {

        ReleaseRunOptions() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(ReleaseRunOptions.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleaseRunOptions.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static ReleaseRunOptions.Function function(MemorySegment funcPtr) {
            return (_x0) -> invoke(funcPtr, _x0);
        }
    }

    private static final AddressLayout ReleaseRunOptions$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("ReleaseRunOptions"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ReleaseRunOptions)(OrtRunOptions *)
     * }
     */
    public static final AddressLayout ReleaseRunOptions$layout() {
        return ReleaseRunOptions$LAYOUT;
    }

    private static final long ReleaseRunOptions$OFFSET = 776;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ReleaseRunOptions)(OrtRunOptions *)
     * }
     */
    public static final long ReleaseRunOptions$offset() {
        return ReleaseRunOptions$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ReleaseRunOptions)(OrtRunOptions *)
     * }
     */
    public static MemorySegment ReleaseRunOptions(MemorySegment struct) {
        return struct.get(ReleaseRunOptions$LAYOUT, ReleaseRunOptions$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ReleaseRunOptions)(OrtRunOptions *)
     * }
     */
    public static void ReleaseRunOptions(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleaseRunOptions$LAYOUT, ReleaseRunOptions$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * void (*ReleaseRunOptions)(OrtRunOptions *)
     * }
     */
    public static ReleaseRunOptions.Function ReleaseRunOptionsFunction(MemorySegment struct) {
        return ReleaseRunOptions.function(ReleaseRunOptions(struct));
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseTypeInfo)(OrtTypeInfo *)
     * }
     */
    public static class ReleaseTypeInfo {

        ReleaseTypeInfo() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(ReleaseTypeInfo.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleaseTypeInfo.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static ReleaseTypeInfo.Function function(MemorySegment funcPtr) {
            return (_x0) -> invoke(funcPtr, _x0);
        }
    }

    private static final AddressLayout ReleaseTypeInfo$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("ReleaseTypeInfo"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ReleaseTypeInfo)(OrtTypeInfo *)
     * }
     */
    public static final AddressLayout ReleaseTypeInfo$layout() {
        return ReleaseTypeInfo$LAYOUT;
    }

    private static final long ReleaseTypeInfo$OFFSET = 784;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ReleaseTypeInfo)(OrtTypeInfo *)
     * }
     */
    public static final long ReleaseTypeInfo$offset() {
        return ReleaseTypeInfo$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ReleaseTypeInfo)(OrtTypeInfo *)
     * }
     */
    public static MemorySegment ReleaseTypeInfo(MemorySegment struct) {
        return struct.get(ReleaseTypeInfo$LAYOUT, ReleaseTypeInfo$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ReleaseTypeInfo)(OrtTypeInfo *)
     * }
     */
    public static void ReleaseTypeInfo(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleaseTypeInfo$LAYOUT, ReleaseTypeInfo$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * void (*ReleaseTypeInfo)(OrtTypeInfo *)
     * }
     */
    public static ReleaseTypeInfo.Function ReleaseTypeInfoFunction(MemorySegment struct) {
        return ReleaseTypeInfo.function(ReleaseTypeInfo(struct));
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseTensorTypeAndShapeInfo)(OrtTensorTypeAndShapeInfo *)
     * }
     */
    public static class ReleaseTensorTypeAndShapeInfo {

        ReleaseTensorTypeAndShapeInfo() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(ReleaseTensorTypeAndShapeInfo.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleaseTensorTypeAndShapeInfo.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static ReleaseTensorTypeAndShapeInfo.Function function(MemorySegment funcPtr) {
            return (_x0) -> invoke(funcPtr, _x0);
        }
    }

    private static final AddressLayout ReleaseTensorTypeAndShapeInfo$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("ReleaseTensorTypeAndShapeInfo"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ReleaseTensorTypeAndShapeInfo)(OrtTensorTypeAndShapeInfo *)
     * }
     */
    public static final AddressLayout ReleaseTensorTypeAndShapeInfo$layout() {
        return ReleaseTensorTypeAndShapeInfo$LAYOUT;
    }

    private static final long ReleaseTensorTypeAndShapeInfo$OFFSET = 792;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ReleaseTensorTypeAndShapeInfo)(OrtTensorTypeAndShapeInfo *)
     * }
     */
    public static final long ReleaseTensorTypeAndShapeInfo$offset() {
        return ReleaseTensorTypeAndShapeInfo$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ReleaseTensorTypeAndShapeInfo)(OrtTensorTypeAndShapeInfo *)
     * }
     */
    public static MemorySegment ReleaseTensorTypeAndShapeInfo(MemorySegment struct) {
        return struct.get(ReleaseTensorTypeAndShapeInfo$LAYOUT, ReleaseTensorTypeAndShapeInfo$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ReleaseTensorTypeAndShapeInfo)(OrtTensorTypeAndShapeInfo *)
     * }
     */
    public static void ReleaseTensorTypeAndShapeInfo(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleaseTensorTypeAndShapeInfo$LAYOUT, ReleaseTensorTypeAndShapeInfo$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * void (*ReleaseTensorTypeAndShapeInfo)(OrtTensorTypeAndShapeInfo *)
     * }
     */
    public static ReleaseTensorTypeAndShapeInfo.Function ReleaseTensorTypeAndShapeInfoFunction(MemorySegment struct) {
        return ReleaseTensorTypeAndShapeInfo.function(ReleaseTensorTypeAndShapeInfo(struct));
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseSessionOptions)(OrtSessionOptions *)
     * }
     */
    public static class ReleaseSessionOptions {

        ReleaseSessionOptions() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(ReleaseSessionOptions.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleaseSessionOptions.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static ReleaseSessionOptions.Function function(MemorySegment funcPtr) {
            return (_x0) -> invoke(funcPtr, _x0);
        }
    }

    private static final AddressLayout ReleaseSessionOptions$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("ReleaseSessionOptions"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ReleaseSessionOptions)(OrtSessionOptions *)
     * }
     */
    public static final AddressLayout ReleaseSessionOptions$layout() {
        return ReleaseSessionOptions$LAYOUT;
    }

    private static final long ReleaseSessionOptions$OFFSET = 800;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ReleaseSessionOptions)(OrtSessionOptions *)
     * }
     */
    public static final long ReleaseSessionOptions$offset() {
        return ReleaseSessionOptions$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ReleaseSessionOptions)(OrtSessionOptions *)
     * }
     */
    public static MemorySegment ReleaseSessionOptions(MemorySegment struct) {
        return struct.get(ReleaseSessionOptions$LAYOUT, ReleaseSessionOptions$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ReleaseSessionOptions)(OrtSessionOptions *)
     * }
     */
    public static void ReleaseSessionOptions(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleaseSessionOptions$LAYOUT, ReleaseSessionOptions$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * void (*ReleaseSessionOptions)(OrtSessionOptions *)
     * }
     */
    public static ReleaseSessionOptions.Function ReleaseSessionOptionsFunction(MemorySegment struct) {
        return ReleaseSessionOptions.function(ReleaseSessionOptions(struct));
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseCustomOpDomain)(OrtCustomOpDomain *)
     * }
     */
    public static class ReleaseCustomOpDomain {

        ReleaseCustomOpDomain() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(ReleaseCustomOpDomain.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleaseCustomOpDomain.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static ReleaseCustomOpDomain.Function function(MemorySegment funcPtr) {
            return (_x0) -> invoke(funcPtr, _x0);
        }
    }

    private static final AddressLayout ReleaseCustomOpDomain$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("ReleaseCustomOpDomain"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ReleaseCustomOpDomain)(OrtCustomOpDomain *)
     * }
     */
    public static final AddressLayout ReleaseCustomOpDomain$layout() {
        return ReleaseCustomOpDomain$LAYOUT;
    }

    private static final long ReleaseCustomOpDomain$OFFSET = 808;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ReleaseCustomOpDomain)(OrtCustomOpDomain *)
     * }
     */
    public static final long ReleaseCustomOpDomain$offset() {
        return ReleaseCustomOpDomain$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ReleaseCustomOpDomain)(OrtCustomOpDomain *)
     * }
     */
    public static MemorySegment ReleaseCustomOpDomain(MemorySegment struct) {
        return struct.get(ReleaseCustomOpDomain$LAYOUT, ReleaseCustomOpDomain$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ReleaseCustomOpDomain)(OrtCustomOpDomain *)
     * }
     */
    public static void ReleaseCustomOpDomain(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleaseCustomOpDomain$LAYOUT, ReleaseCustomOpDomain$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * void (*ReleaseCustomOpDomain)(OrtCustomOpDomain *)
     * }
     */
    public static ReleaseCustomOpDomain.Function ReleaseCustomOpDomainFunction(MemorySegment struct) {
        return ReleaseCustomOpDomain.function(ReleaseCustomOpDomain(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetDenotationFromTypeInfo)(const OrtTypeInfo *, const char **const, size_t *)
     * }
     */
    public static class GetDenotationFromTypeInfo {

        GetDenotationFromTypeInfo() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(GetDenotationFromTypeInfo.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetDenotationFromTypeInfo.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static GetDenotationFromTypeInfo.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2) -> invoke(funcPtr, _x0, _x1, _x2);
        }
    }

    private static final AddressLayout GetDenotationFromTypeInfo$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("GetDenotationFromTypeInfo"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetDenotationFromTypeInfo)(const OrtTypeInfo *, const char **const, size_t *)
     * }
     */
    public static final AddressLayout GetDenotationFromTypeInfo$layout() {
        return GetDenotationFromTypeInfo$LAYOUT;
    }

    private static final long GetDenotationFromTypeInfo$OFFSET = 816;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetDenotationFromTypeInfo)(const OrtTypeInfo *, const char **const, size_t *)
     * }
     */
    public static final long GetDenotationFromTypeInfo$offset() {
        return GetDenotationFromTypeInfo$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetDenotationFromTypeInfo)(const OrtTypeInfo *, const char **const, size_t *)
     * }
     */
    public static MemorySegment GetDenotationFromTypeInfo(MemorySegment struct) {
        return struct.get(GetDenotationFromTypeInfo$LAYOUT, GetDenotationFromTypeInfo$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetDenotationFromTypeInfo)(const OrtTypeInfo *, const char **const, size_t *)
     * }
     */
    public static void GetDenotationFromTypeInfo(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetDenotationFromTypeInfo$LAYOUT, GetDenotationFromTypeInfo$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetDenotationFromTypeInfo)(const OrtTypeInfo *, const char **const, size_t *)
     * }
     */
    public static GetDenotationFromTypeInfo.Function GetDenotationFromTypeInfoFunction(MemorySegment struct) {
        return GetDenotationFromTypeInfo.function(GetDenotationFromTypeInfo(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CastTypeInfoToMapTypeInfo)(const OrtTypeInfo *, const OrtMapTypeInfo **)
     * }
     */
    public static class CastTypeInfoToMapTypeInfo {

        CastTypeInfoToMapTypeInfo() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(CastTypeInfoToMapTypeInfo.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CastTypeInfoToMapTypeInfo.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static CastTypeInfoToMapTypeInfo.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout CastTypeInfoToMapTypeInfo$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("CastTypeInfoToMapTypeInfo"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CastTypeInfoToMapTypeInfo)(const OrtTypeInfo *, const OrtMapTypeInfo **)
     * }
     */
    public static final AddressLayout CastTypeInfoToMapTypeInfo$layout() {
        return CastTypeInfoToMapTypeInfo$LAYOUT;
    }

    private static final long CastTypeInfoToMapTypeInfo$OFFSET = 824;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CastTypeInfoToMapTypeInfo)(const OrtTypeInfo *, const OrtMapTypeInfo **)
     * }
     */
    public static final long CastTypeInfoToMapTypeInfo$offset() {
        return CastTypeInfoToMapTypeInfo$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CastTypeInfoToMapTypeInfo)(const OrtTypeInfo *, const OrtMapTypeInfo **)
     * }
     */
    public static MemorySegment CastTypeInfoToMapTypeInfo(MemorySegment struct) {
        return struct.get(CastTypeInfoToMapTypeInfo$LAYOUT, CastTypeInfoToMapTypeInfo$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CastTypeInfoToMapTypeInfo)(const OrtTypeInfo *, const OrtMapTypeInfo **)
     * }
     */
    public static void CastTypeInfoToMapTypeInfo(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CastTypeInfoToMapTypeInfo$LAYOUT, CastTypeInfoToMapTypeInfo$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CastTypeInfoToMapTypeInfo)(const OrtTypeInfo *, const OrtMapTypeInfo **)
     * }
     */
    public static CastTypeInfoToMapTypeInfo.Function CastTypeInfoToMapTypeInfoFunction(MemorySegment struct) {
        return CastTypeInfoToMapTypeInfo.function(CastTypeInfoToMapTypeInfo(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CastTypeInfoToSequenceTypeInfo)(const OrtTypeInfo *, const OrtSequenceTypeInfo **)
     * }
     */
    public static class CastTypeInfoToSequenceTypeInfo {

        CastTypeInfoToSequenceTypeInfo() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(CastTypeInfoToSequenceTypeInfo.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CastTypeInfoToSequenceTypeInfo.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static CastTypeInfoToSequenceTypeInfo.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout CastTypeInfoToSequenceTypeInfo$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("CastTypeInfoToSequenceTypeInfo"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CastTypeInfoToSequenceTypeInfo)(const OrtTypeInfo *, const OrtSequenceTypeInfo **)
     * }
     */
    public static final AddressLayout CastTypeInfoToSequenceTypeInfo$layout() {
        return CastTypeInfoToSequenceTypeInfo$LAYOUT;
    }

    private static final long CastTypeInfoToSequenceTypeInfo$OFFSET = 832;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CastTypeInfoToSequenceTypeInfo)(const OrtTypeInfo *, const OrtSequenceTypeInfo **)
     * }
     */
    public static final long CastTypeInfoToSequenceTypeInfo$offset() {
        return CastTypeInfoToSequenceTypeInfo$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CastTypeInfoToSequenceTypeInfo)(const OrtTypeInfo *, const OrtSequenceTypeInfo **)
     * }
     */
    public static MemorySegment CastTypeInfoToSequenceTypeInfo(MemorySegment struct) {
        return struct.get(CastTypeInfoToSequenceTypeInfo$LAYOUT, CastTypeInfoToSequenceTypeInfo$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CastTypeInfoToSequenceTypeInfo)(const OrtTypeInfo *, const OrtSequenceTypeInfo **)
     * }
     */
    public static void CastTypeInfoToSequenceTypeInfo(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CastTypeInfoToSequenceTypeInfo$LAYOUT, CastTypeInfoToSequenceTypeInfo$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CastTypeInfoToSequenceTypeInfo)(const OrtTypeInfo *, const OrtSequenceTypeInfo **)
     * }
     */
    public static CastTypeInfoToSequenceTypeInfo.Function CastTypeInfoToSequenceTypeInfoFunction(MemorySegment struct) {
        return CastTypeInfoToSequenceTypeInfo.function(CastTypeInfoToSequenceTypeInfo(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetMapKeyType)(const OrtMapTypeInfo *, enum ONNXTensorElementDataType *)
     * }
     */
    public static class GetMapKeyType {

        GetMapKeyType() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(GetMapKeyType.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetMapKeyType.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static GetMapKeyType.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout GetMapKeyType$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("GetMapKeyType"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetMapKeyType)(const OrtMapTypeInfo *, enum ONNXTensorElementDataType *)
     * }
     */
    public static final AddressLayout GetMapKeyType$layout() {
        return GetMapKeyType$LAYOUT;
    }

    private static final long GetMapKeyType$OFFSET = 840;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetMapKeyType)(const OrtMapTypeInfo *, enum ONNXTensorElementDataType *)
     * }
     */
    public static final long GetMapKeyType$offset() {
        return GetMapKeyType$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetMapKeyType)(const OrtMapTypeInfo *, enum ONNXTensorElementDataType *)
     * }
     */
    public static MemorySegment GetMapKeyType(MemorySegment struct) {
        return struct.get(GetMapKeyType$LAYOUT, GetMapKeyType$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetMapKeyType)(const OrtMapTypeInfo *, enum ONNXTensorElementDataType *)
     * }
     */
    public static void GetMapKeyType(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetMapKeyType$LAYOUT, GetMapKeyType$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetMapKeyType)(const OrtMapTypeInfo *, enum ONNXTensorElementDataType *)
     * }
     */
    public static GetMapKeyType.Function GetMapKeyTypeFunction(MemorySegment struct) {
        return GetMapKeyType.function(GetMapKeyType(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetMapValueType)(const OrtMapTypeInfo *, OrtTypeInfo **)
     * }
     */
    public static class GetMapValueType {

        GetMapValueType() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(GetMapValueType.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetMapValueType.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static GetMapValueType.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout GetMapValueType$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("GetMapValueType"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetMapValueType)(const OrtMapTypeInfo *, OrtTypeInfo **)
     * }
     */
    public static final AddressLayout GetMapValueType$layout() {
        return GetMapValueType$LAYOUT;
    }

    private static final long GetMapValueType$OFFSET = 848;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetMapValueType)(const OrtMapTypeInfo *, OrtTypeInfo **)
     * }
     */
    public static final long GetMapValueType$offset() {
        return GetMapValueType$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetMapValueType)(const OrtMapTypeInfo *, OrtTypeInfo **)
     * }
     */
    public static MemorySegment GetMapValueType(MemorySegment struct) {
        return struct.get(GetMapValueType$LAYOUT, GetMapValueType$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetMapValueType)(const OrtMapTypeInfo *, OrtTypeInfo **)
     * }
     */
    public static void GetMapValueType(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetMapValueType$LAYOUT, GetMapValueType$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetMapValueType)(const OrtMapTypeInfo *, OrtTypeInfo **)
     * }
     */
    public static GetMapValueType.Function GetMapValueTypeFunction(MemorySegment struct) {
        return GetMapValueType.function(GetMapValueType(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSequenceElementType)(const OrtSequenceTypeInfo *, OrtTypeInfo **)
     * }
     */
    public static class GetSequenceElementType {

        GetSequenceElementType() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(GetSequenceElementType.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetSequenceElementType.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static GetSequenceElementType.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout GetSequenceElementType$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("GetSequenceElementType"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSequenceElementType)(const OrtSequenceTypeInfo *, OrtTypeInfo **)
     * }
     */
    public static final AddressLayout GetSequenceElementType$layout() {
        return GetSequenceElementType$LAYOUT;
    }

    private static final long GetSequenceElementType$OFFSET = 856;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSequenceElementType)(const OrtSequenceTypeInfo *, OrtTypeInfo **)
     * }
     */
    public static final long GetSequenceElementType$offset() {
        return GetSequenceElementType$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSequenceElementType)(const OrtSequenceTypeInfo *, OrtTypeInfo **)
     * }
     */
    public static MemorySegment GetSequenceElementType(MemorySegment struct) {
        return struct.get(GetSequenceElementType$LAYOUT, GetSequenceElementType$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSequenceElementType)(const OrtSequenceTypeInfo *, OrtTypeInfo **)
     * }
     */
    public static void GetSequenceElementType(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetSequenceElementType$LAYOUT, GetSequenceElementType$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSequenceElementType)(const OrtSequenceTypeInfo *, OrtTypeInfo **)
     * }
     */
    public static GetSequenceElementType.Function GetSequenceElementTypeFunction(MemorySegment struct) {
        return GetSequenceElementType.function(GetSequenceElementType(struct));
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseMapTypeInfo)(OrtMapTypeInfo *)
     * }
     */
    public static class ReleaseMapTypeInfo {

        ReleaseMapTypeInfo() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(ReleaseMapTypeInfo.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleaseMapTypeInfo.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static ReleaseMapTypeInfo.Function function(MemorySegment funcPtr) {
            return (_x0) -> invoke(funcPtr, _x0);
        }
    }

    private static final AddressLayout ReleaseMapTypeInfo$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("ReleaseMapTypeInfo"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ReleaseMapTypeInfo)(OrtMapTypeInfo *)
     * }
     */
    public static final AddressLayout ReleaseMapTypeInfo$layout() {
        return ReleaseMapTypeInfo$LAYOUT;
    }

    private static final long ReleaseMapTypeInfo$OFFSET = 864;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ReleaseMapTypeInfo)(OrtMapTypeInfo *)
     * }
     */
    public static final long ReleaseMapTypeInfo$offset() {
        return ReleaseMapTypeInfo$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ReleaseMapTypeInfo)(OrtMapTypeInfo *)
     * }
     */
    public static MemorySegment ReleaseMapTypeInfo(MemorySegment struct) {
        return struct.get(ReleaseMapTypeInfo$LAYOUT, ReleaseMapTypeInfo$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ReleaseMapTypeInfo)(OrtMapTypeInfo *)
     * }
     */
    public static void ReleaseMapTypeInfo(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleaseMapTypeInfo$LAYOUT, ReleaseMapTypeInfo$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * void (*ReleaseMapTypeInfo)(OrtMapTypeInfo *)
     * }
     */
    public static ReleaseMapTypeInfo.Function ReleaseMapTypeInfoFunction(MemorySegment struct) {
        return ReleaseMapTypeInfo.function(ReleaseMapTypeInfo(struct));
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseSequenceTypeInfo)(OrtSequenceTypeInfo *)
     * }
     */
    public static class ReleaseSequenceTypeInfo {

        ReleaseSequenceTypeInfo() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(ReleaseSequenceTypeInfo.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleaseSequenceTypeInfo.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static ReleaseSequenceTypeInfo.Function function(MemorySegment funcPtr) {
            return (_x0) -> invoke(funcPtr, _x0);
        }
    }

    private static final AddressLayout ReleaseSequenceTypeInfo$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("ReleaseSequenceTypeInfo"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ReleaseSequenceTypeInfo)(OrtSequenceTypeInfo *)
     * }
     */
    public static final AddressLayout ReleaseSequenceTypeInfo$layout() {
        return ReleaseSequenceTypeInfo$LAYOUT;
    }

    private static final long ReleaseSequenceTypeInfo$OFFSET = 872;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ReleaseSequenceTypeInfo)(OrtSequenceTypeInfo *)
     * }
     */
    public static final long ReleaseSequenceTypeInfo$offset() {
        return ReleaseSequenceTypeInfo$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ReleaseSequenceTypeInfo)(OrtSequenceTypeInfo *)
     * }
     */
    public static MemorySegment ReleaseSequenceTypeInfo(MemorySegment struct) {
        return struct.get(ReleaseSequenceTypeInfo$LAYOUT, ReleaseSequenceTypeInfo$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ReleaseSequenceTypeInfo)(OrtSequenceTypeInfo *)
     * }
     */
    public static void ReleaseSequenceTypeInfo(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleaseSequenceTypeInfo$LAYOUT, ReleaseSequenceTypeInfo$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * void (*ReleaseSequenceTypeInfo)(OrtSequenceTypeInfo *)
     * }
     */
    public static ReleaseSequenceTypeInfo.Function ReleaseSequenceTypeInfoFunction(MemorySegment struct) {
        return ReleaseSequenceTypeInfo.function(ReleaseSequenceTypeInfo(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionEndProfiling)(OrtSession *, OrtAllocator *, char **)
     * }
     */
    public static class SessionEndProfiling {

        SessionEndProfiling() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(SessionEndProfiling.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SessionEndProfiling.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static SessionEndProfiling.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2) -> invoke(funcPtr, _x0, _x1, _x2);
        }
    }

    private static final AddressLayout SessionEndProfiling$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("SessionEndProfiling"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionEndProfiling)(OrtSession *, OrtAllocator *, char **)
     * }
     */
    public static final AddressLayout SessionEndProfiling$layout() {
        return SessionEndProfiling$LAYOUT;
    }

    private static final long SessionEndProfiling$OFFSET = 880;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionEndProfiling)(OrtSession *, OrtAllocator *, char **)
     * }
     */
    public static final long SessionEndProfiling$offset() {
        return SessionEndProfiling$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionEndProfiling)(OrtSession *, OrtAllocator *, char **)
     * }
     */
    public static MemorySegment SessionEndProfiling(MemorySegment struct) {
        return struct.get(SessionEndProfiling$LAYOUT, SessionEndProfiling$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionEndProfiling)(OrtSession *, OrtAllocator *, char **)
     * }
     */
    public static void SessionEndProfiling(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SessionEndProfiling$LAYOUT, SessionEndProfiling$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionEndProfiling)(OrtSession *, OrtAllocator *, char **)
     * }
     */
    public static SessionEndProfiling.Function SessionEndProfilingFunction(MemorySegment struct) {
        return SessionEndProfiling.function(SessionEndProfiling(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetModelMetadata)(const OrtSession *, OrtModelMetadata **)
     * }
     */
    public static class SessionGetModelMetadata {

        SessionGetModelMetadata() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(SessionGetModelMetadata.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SessionGetModelMetadata.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static SessionGetModelMetadata.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout SessionGetModelMetadata$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("SessionGetModelMetadata"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetModelMetadata)(const OrtSession *, OrtModelMetadata **)
     * }
     */
    public static final AddressLayout SessionGetModelMetadata$layout() {
        return SessionGetModelMetadata$LAYOUT;
    }

    private static final long SessionGetModelMetadata$OFFSET = 888;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetModelMetadata)(const OrtSession *, OrtModelMetadata **)
     * }
     */
    public static final long SessionGetModelMetadata$offset() {
        return SessionGetModelMetadata$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetModelMetadata)(const OrtSession *, OrtModelMetadata **)
     * }
     */
    public static MemorySegment SessionGetModelMetadata(MemorySegment struct) {
        return struct.get(SessionGetModelMetadata$LAYOUT, SessionGetModelMetadata$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetModelMetadata)(const OrtSession *, OrtModelMetadata **)
     * }
     */
    public static void SessionGetModelMetadata(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SessionGetModelMetadata$LAYOUT, SessionGetModelMetadata$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetModelMetadata)(const OrtSession *, OrtModelMetadata **)
     * }
     */
    public static SessionGetModelMetadata.Function SessionGetModelMetadataFunction(MemorySegment struct) {
        return SessionGetModelMetadata.function(SessionGetModelMetadata(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetProducerName)(const OrtModelMetadata *, OrtAllocator *, char **)
     * }
     */
    public static class ModelMetadataGetProducerName {

        ModelMetadataGetProducerName() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(ModelMetadataGetProducerName.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ModelMetadataGetProducerName.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static ModelMetadataGetProducerName.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2) -> invoke(funcPtr, _x0, _x1, _x2);
        }
    }

    private static final AddressLayout ModelMetadataGetProducerName$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("ModelMetadataGetProducerName"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetProducerName)(const OrtModelMetadata *, OrtAllocator *, char **)
     * }
     */
    public static final AddressLayout ModelMetadataGetProducerName$layout() {
        return ModelMetadataGetProducerName$LAYOUT;
    }

    private static final long ModelMetadataGetProducerName$OFFSET = 896;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetProducerName)(const OrtModelMetadata *, OrtAllocator *, char **)
     * }
     */
    public static final long ModelMetadataGetProducerName$offset() {
        return ModelMetadataGetProducerName$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetProducerName)(const OrtModelMetadata *, OrtAllocator *, char **)
     * }
     */
    public static MemorySegment ModelMetadataGetProducerName(MemorySegment struct) {
        return struct.get(ModelMetadataGetProducerName$LAYOUT, ModelMetadataGetProducerName$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetProducerName)(const OrtModelMetadata *, OrtAllocator *, char **)
     * }
     */
    public static void ModelMetadataGetProducerName(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ModelMetadataGetProducerName$LAYOUT, ModelMetadataGetProducerName$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetProducerName)(const OrtModelMetadata *, OrtAllocator *, char **)
     * }
     */
    public static ModelMetadataGetProducerName.Function ModelMetadataGetProducerNameFunction(MemorySegment struct) {
        return ModelMetadataGetProducerName.function(ModelMetadataGetProducerName(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetGraphName)(const OrtModelMetadata *, OrtAllocator *, char **)
     * }
     */
    public static class ModelMetadataGetGraphName {

        ModelMetadataGetGraphName() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(ModelMetadataGetGraphName.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ModelMetadataGetGraphName.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static ModelMetadataGetGraphName.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2) -> invoke(funcPtr, _x0, _x1, _x2);
        }
    }

    private static final AddressLayout ModelMetadataGetGraphName$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("ModelMetadataGetGraphName"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetGraphName)(const OrtModelMetadata *, OrtAllocator *, char **)
     * }
     */
    public static final AddressLayout ModelMetadataGetGraphName$layout() {
        return ModelMetadataGetGraphName$LAYOUT;
    }

    private static final long ModelMetadataGetGraphName$OFFSET = 904;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetGraphName)(const OrtModelMetadata *, OrtAllocator *, char **)
     * }
     */
    public static final long ModelMetadataGetGraphName$offset() {
        return ModelMetadataGetGraphName$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetGraphName)(const OrtModelMetadata *, OrtAllocator *, char **)
     * }
     */
    public static MemorySegment ModelMetadataGetGraphName(MemorySegment struct) {
        return struct.get(ModelMetadataGetGraphName$LAYOUT, ModelMetadataGetGraphName$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetGraphName)(const OrtModelMetadata *, OrtAllocator *, char **)
     * }
     */
    public static void ModelMetadataGetGraphName(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ModelMetadataGetGraphName$LAYOUT, ModelMetadataGetGraphName$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetGraphName)(const OrtModelMetadata *, OrtAllocator *, char **)
     * }
     */
    public static ModelMetadataGetGraphName.Function ModelMetadataGetGraphNameFunction(MemorySegment struct) {
        return ModelMetadataGetGraphName.function(ModelMetadataGetGraphName(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetDomain)(const OrtModelMetadata *, OrtAllocator *, char **)
     * }
     */
    public static class ModelMetadataGetDomain {

        ModelMetadataGetDomain() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(ModelMetadataGetDomain.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ModelMetadataGetDomain.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static ModelMetadataGetDomain.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2) -> invoke(funcPtr, _x0, _x1, _x2);
        }
    }

    private static final AddressLayout ModelMetadataGetDomain$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("ModelMetadataGetDomain"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetDomain)(const OrtModelMetadata *, OrtAllocator *, char **)
     * }
     */
    public static final AddressLayout ModelMetadataGetDomain$layout() {
        return ModelMetadataGetDomain$LAYOUT;
    }

    private static final long ModelMetadataGetDomain$OFFSET = 912;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetDomain)(const OrtModelMetadata *, OrtAllocator *, char **)
     * }
     */
    public static final long ModelMetadataGetDomain$offset() {
        return ModelMetadataGetDomain$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetDomain)(const OrtModelMetadata *, OrtAllocator *, char **)
     * }
     */
    public static MemorySegment ModelMetadataGetDomain(MemorySegment struct) {
        return struct.get(ModelMetadataGetDomain$LAYOUT, ModelMetadataGetDomain$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetDomain)(const OrtModelMetadata *, OrtAllocator *, char **)
     * }
     */
    public static void ModelMetadataGetDomain(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ModelMetadataGetDomain$LAYOUT, ModelMetadataGetDomain$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetDomain)(const OrtModelMetadata *, OrtAllocator *, char **)
     * }
     */
    public static ModelMetadataGetDomain.Function ModelMetadataGetDomainFunction(MemorySegment struct) {
        return ModelMetadataGetDomain.function(ModelMetadataGetDomain(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetDescription)(const OrtModelMetadata *, OrtAllocator *, char **)
     * }
     */
    public static class ModelMetadataGetDescription {

        ModelMetadataGetDescription() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(ModelMetadataGetDescription.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ModelMetadataGetDescription.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static ModelMetadataGetDescription.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2) -> invoke(funcPtr, _x0, _x1, _x2);
        }
    }

    private static final AddressLayout ModelMetadataGetDescription$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("ModelMetadataGetDescription"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetDescription)(const OrtModelMetadata *, OrtAllocator *, char **)
     * }
     */
    public static final AddressLayout ModelMetadataGetDescription$layout() {
        return ModelMetadataGetDescription$LAYOUT;
    }

    private static final long ModelMetadataGetDescription$OFFSET = 920;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetDescription)(const OrtModelMetadata *, OrtAllocator *, char **)
     * }
     */
    public static final long ModelMetadataGetDescription$offset() {
        return ModelMetadataGetDescription$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetDescription)(const OrtModelMetadata *, OrtAllocator *, char **)
     * }
     */
    public static MemorySegment ModelMetadataGetDescription(MemorySegment struct) {
        return struct.get(ModelMetadataGetDescription$LAYOUT, ModelMetadataGetDescription$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetDescription)(const OrtModelMetadata *, OrtAllocator *, char **)
     * }
     */
    public static void ModelMetadataGetDescription(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ModelMetadataGetDescription$LAYOUT, ModelMetadataGetDescription$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetDescription)(const OrtModelMetadata *, OrtAllocator *, char **)
     * }
     */
    public static ModelMetadataGetDescription.Function ModelMetadataGetDescriptionFunction(MemorySegment struct) {
        return ModelMetadataGetDescription.function(ModelMetadataGetDescription(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataLookupCustomMetadataMap)(const OrtModelMetadata *, OrtAllocator *, const char *, char **)
     * }
     */
    public static class ModelMetadataLookupCustomMetadataMap {

        ModelMetadataLookupCustomMetadataMap() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(ModelMetadataLookupCustomMetadataMap.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ModelMetadataLookupCustomMetadataMap.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static ModelMetadataLookupCustomMetadataMap.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2, _x3) -> invoke(funcPtr, _x0, _x1, _x2, _x3);
        }
    }

    private static final AddressLayout ModelMetadataLookupCustomMetadataMap$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("ModelMetadataLookupCustomMetadataMap"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataLookupCustomMetadataMap)(const OrtModelMetadata *, OrtAllocator *, const char *, char **)
     * }
     */
    public static final AddressLayout ModelMetadataLookupCustomMetadataMap$layout() {
        return ModelMetadataLookupCustomMetadataMap$LAYOUT;
    }

    private static final long ModelMetadataLookupCustomMetadataMap$OFFSET = 928;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataLookupCustomMetadataMap)(const OrtModelMetadata *, OrtAllocator *, const char *, char **)
     * }
     */
    public static final long ModelMetadataLookupCustomMetadataMap$offset() {
        return ModelMetadataLookupCustomMetadataMap$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataLookupCustomMetadataMap)(const OrtModelMetadata *, OrtAllocator *, const char *, char **)
     * }
     */
    public static MemorySegment ModelMetadataLookupCustomMetadataMap(MemorySegment struct) {
        return struct.get(ModelMetadataLookupCustomMetadataMap$LAYOUT, ModelMetadataLookupCustomMetadataMap$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataLookupCustomMetadataMap)(const OrtModelMetadata *, OrtAllocator *, const char *, char **)
     * }
     */
    public static void ModelMetadataLookupCustomMetadataMap(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(
                ModelMetadataLookupCustomMetadataMap$LAYOUT, ModelMetadataLookupCustomMetadataMap$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataLookupCustomMetadataMap)(const OrtModelMetadata *, OrtAllocator *, const char *, char **)
     * }
     */
    public static ModelMetadataLookupCustomMetadataMap.Function ModelMetadataLookupCustomMetadataMapFunction(
            MemorySegment struct) {
        return ModelMetadataLookupCustomMetadataMap.function(ModelMetadataLookupCustomMetadataMap(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetVersion)(const OrtModelMetadata *, int64_t *)
     * }
     */
    public static class ModelMetadataGetVersion {

        ModelMetadataGetVersion() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(ModelMetadataGetVersion.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ModelMetadataGetVersion.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static ModelMetadataGetVersion.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout ModelMetadataGetVersion$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("ModelMetadataGetVersion"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetVersion)(const OrtModelMetadata *, int64_t *)
     * }
     */
    public static final AddressLayout ModelMetadataGetVersion$layout() {
        return ModelMetadataGetVersion$LAYOUT;
    }

    private static final long ModelMetadataGetVersion$OFFSET = 936;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetVersion)(const OrtModelMetadata *, int64_t *)
     * }
     */
    public static final long ModelMetadataGetVersion$offset() {
        return ModelMetadataGetVersion$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetVersion)(const OrtModelMetadata *, int64_t *)
     * }
     */
    public static MemorySegment ModelMetadataGetVersion(MemorySegment struct) {
        return struct.get(ModelMetadataGetVersion$LAYOUT, ModelMetadataGetVersion$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetVersion)(const OrtModelMetadata *, int64_t *)
     * }
     */
    public static void ModelMetadataGetVersion(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ModelMetadataGetVersion$LAYOUT, ModelMetadataGetVersion$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetVersion)(const OrtModelMetadata *, int64_t *)
     * }
     */
    public static ModelMetadataGetVersion.Function ModelMetadataGetVersionFunction(MemorySegment struct) {
        return ModelMetadataGetVersion.function(ModelMetadataGetVersion(struct));
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseModelMetadata)(OrtModelMetadata *)
     * }
     */
    public static class ReleaseModelMetadata {

        ReleaseModelMetadata() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(ReleaseModelMetadata.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleaseModelMetadata.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static ReleaseModelMetadata.Function function(MemorySegment funcPtr) {
            return (_x0) -> invoke(funcPtr, _x0);
        }
    }

    private static final AddressLayout ReleaseModelMetadata$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("ReleaseModelMetadata"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ReleaseModelMetadata)(OrtModelMetadata *)
     * }
     */
    public static final AddressLayout ReleaseModelMetadata$layout() {
        return ReleaseModelMetadata$LAYOUT;
    }

    private static final long ReleaseModelMetadata$OFFSET = 944;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ReleaseModelMetadata)(OrtModelMetadata *)
     * }
     */
    public static final long ReleaseModelMetadata$offset() {
        return ReleaseModelMetadata$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ReleaseModelMetadata)(OrtModelMetadata *)
     * }
     */
    public static MemorySegment ReleaseModelMetadata(MemorySegment struct) {
        return struct.get(ReleaseModelMetadata$LAYOUT, ReleaseModelMetadata$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ReleaseModelMetadata)(OrtModelMetadata *)
     * }
     */
    public static void ReleaseModelMetadata(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleaseModelMetadata$LAYOUT, ReleaseModelMetadata$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * void (*ReleaseModelMetadata)(OrtModelMetadata *)
     * }
     */
    public static ReleaseModelMetadata.Function ReleaseModelMetadataFunction(MemorySegment struct) {
        return ReleaseModelMetadata.function(ReleaseModelMetadata(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateEnvWithGlobalThreadPools)(OrtLoggingLevel, const char *, const OrtThreadingOptions *, OrtEnv **)
     * }
     */
    public static class CreateEnvWithGlobalThreadPools {

        CreateEnvWithGlobalThreadPools() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(int _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_INT,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(CreateEnvWithGlobalThreadPools.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateEnvWithGlobalThreadPools.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr, int _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static CreateEnvWithGlobalThreadPools.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2, _x3) -> invoke(funcPtr, _x0, _x1, _x2, _x3);
        }
    }

    private static final AddressLayout CreateEnvWithGlobalThreadPools$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("CreateEnvWithGlobalThreadPools"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateEnvWithGlobalThreadPools)(OrtLoggingLevel, const char *, const OrtThreadingOptions *, OrtEnv **)
     * }
     */
    public static final AddressLayout CreateEnvWithGlobalThreadPools$layout() {
        return CreateEnvWithGlobalThreadPools$LAYOUT;
    }

    private static final long CreateEnvWithGlobalThreadPools$OFFSET = 952;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateEnvWithGlobalThreadPools)(OrtLoggingLevel, const char *, const OrtThreadingOptions *, OrtEnv **)
     * }
     */
    public static final long CreateEnvWithGlobalThreadPools$offset() {
        return CreateEnvWithGlobalThreadPools$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateEnvWithGlobalThreadPools)(OrtLoggingLevel, const char *, const OrtThreadingOptions *, OrtEnv **)
     * }
     */
    public static MemorySegment CreateEnvWithGlobalThreadPools(MemorySegment struct) {
        return struct.get(CreateEnvWithGlobalThreadPools$LAYOUT, CreateEnvWithGlobalThreadPools$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateEnvWithGlobalThreadPools)(OrtLoggingLevel, const char *, const OrtThreadingOptions *, OrtEnv **)
     * }
     */
    public static void CreateEnvWithGlobalThreadPools(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateEnvWithGlobalThreadPools$LAYOUT, CreateEnvWithGlobalThreadPools$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateEnvWithGlobalThreadPools)(OrtLoggingLevel, const char *, const OrtThreadingOptions *, OrtEnv **)
     * }
     */
    public static CreateEnvWithGlobalThreadPools.Function CreateEnvWithGlobalThreadPoolsFunction(MemorySegment struct) {
        return CreateEnvWithGlobalThreadPools.function(CreateEnvWithGlobalThreadPools(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*DisablePerSessionThreads)(OrtSessionOptions *)
     * }
     */
    public static class DisablePerSessionThreads {

        DisablePerSessionThreads() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC =
                FunctionDescriptor.of(onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(DisablePerSessionThreads.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(DisablePerSessionThreads.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static DisablePerSessionThreads.Function function(MemorySegment funcPtr) {
            return (_x0) -> invoke(funcPtr, _x0);
        }
    }

    private static final AddressLayout DisablePerSessionThreads$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("DisablePerSessionThreads"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*DisablePerSessionThreads)(OrtSessionOptions *)
     * }
     */
    public static final AddressLayout DisablePerSessionThreads$layout() {
        return DisablePerSessionThreads$LAYOUT;
    }

    private static final long DisablePerSessionThreads$OFFSET = 960;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*DisablePerSessionThreads)(OrtSessionOptions *)
     * }
     */
    public static final long DisablePerSessionThreads$offset() {
        return DisablePerSessionThreads$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*DisablePerSessionThreads)(OrtSessionOptions *)
     * }
     */
    public static MemorySegment DisablePerSessionThreads(MemorySegment struct) {
        return struct.get(DisablePerSessionThreads$LAYOUT, DisablePerSessionThreads$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*DisablePerSessionThreads)(OrtSessionOptions *)
     * }
     */
    public static void DisablePerSessionThreads(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(DisablePerSessionThreads$LAYOUT, DisablePerSessionThreads$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*DisablePerSessionThreads)(OrtSessionOptions *)
     * }
     */
    public static DisablePerSessionThreads.Function DisablePerSessionThreadsFunction(MemorySegment struct) {
        return DisablePerSessionThreads.function(DisablePerSessionThreads(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateThreadingOptions)(OrtThreadingOptions **)
     * }
     */
    public static class CreateThreadingOptions {

        CreateThreadingOptions() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC =
                FunctionDescriptor.of(onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(CreateThreadingOptions.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateThreadingOptions.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static CreateThreadingOptions.Function function(MemorySegment funcPtr) {
            return (_x0) -> invoke(funcPtr, _x0);
        }
    }

    private static final AddressLayout CreateThreadingOptions$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("CreateThreadingOptions"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateThreadingOptions)(OrtThreadingOptions **)
     * }
     */
    public static final AddressLayout CreateThreadingOptions$layout() {
        return CreateThreadingOptions$LAYOUT;
    }

    private static final long CreateThreadingOptions$OFFSET = 968;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateThreadingOptions)(OrtThreadingOptions **)
     * }
     */
    public static final long CreateThreadingOptions$offset() {
        return CreateThreadingOptions$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateThreadingOptions)(OrtThreadingOptions **)
     * }
     */
    public static MemorySegment CreateThreadingOptions(MemorySegment struct) {
        return struct.get(CreateThreadingOptions$LAYOUT, CreateThreadingOptions$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateThreadingOptions)(OrtThreadingOptions **)
     * }
     */
    public static void CreateThreadingOptions(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateThreadingOptions$LAYOUT, CreateThreadingOptions$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateThreadingOptions)(OrtThreadingOptions **)
     * }
     */
    public static CreateThreadingOptions.Function CreateThreadingOptionsFunction(MemorySegment struct) {
        return CreateThreadingOptions.function(CreateThreadingOptions(struct));
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseThreadingOptions)(OrtThreadingOptions *)
     * }
     */
    public static class ReleaseThreadingOptions {

        ReleaseThreadingOptions() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(ReleaseThreadingOptions.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleaseThreadingOptions.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static ReleaseThreadingOptions.Function function(MemorySegment funcPtr) {
            return (_x0) -> invoke(funcPtr, _x0);
        }
    }

    private static final AddressLayout ReleaseThreadingOptions$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("ReleaseThreadingOptions"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ReleaseThreadingOptions)(OrtThreadingOptions *)
     * }
     */
    public static final AddressLayout ReleaseThreadingOptions$layout() {
        return ReleaseThreadingOptions$LAYOUT;
    }

    private static final long ReleaseThreadingOptions$OFFSET = 976;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ReleaseThreadingOptions)(OrtThreadingOptions *)
     * }
     */
    public static final long ReleaseThreadingOptions$offset() {
        return ReleaseThreadingOptions$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ReleaseThreadingOptions)(OrtThreadingOptions *)
     * }
     */
    public static MemorySegment ReleaseThreadingOptions(MemorySegment struct) {
        return struct.get(ReleaseThreadingOptions$LAYOUT, ReleaseThreadingOptions$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ReleaseThreadingOptions)(OrtThreadingOptions *)
     * }
     */
    public static void ReleaseThreadingOptions(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleaseThreadingOptions$LAYOUT, ReleaseThreadingOptions$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * void (*ReleaseThreadingOptions)(OrtThreadingOptions *)
     * }
     */
    public static ReleaseThreadingOptions.Function ReleaseThreadingOptionsFunction(MemorySegment struct) {
        return ReleaseThreadingOptions.function(ReleaseThreadingOptions(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetCustomMetadataMapKeys)(const OrtModelMetadata *, OrtAllocator *, char ***, int64_t *)
     * }
     */
    public static class ModelMetadataGetCustomMetadataMapKeys {

        ModelMetadataGetCustomMetadataMapKeys() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(ModelMetadataGetCustomMetadataMapKeys.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ModelMetadataGetCustomMetadataMapKeys.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static ModelMetadataGetCustomMetadataMapKeys.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2, _x3) -> invoke(funcPtr, _x0, _x1, _x2, _x3);
        }
    }

    private static final AddressLayout ModelMetadataGetCustomMetadataMapKeys$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("ModelMetadataGetCustomMetadataMapKeys"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetCustomMetadataMapKeys)(const OrtModelMetadata *, OrtAllocator *, char ***, int64_t *)
     * }
     */
    public static final AddressLayout ModelMetadataGetCustomMetadataMapKeys$layout() {
        return ModelMetadataGetCustomMetadataMapKeys$LAYOUT;
    }

    private static final long ModelMetadataGetCustomMetadataMapKeys$OFFSET = 984;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetCustomMetadataMapKeys)(const OrtModelMetadata *, OrtAllocator *, char ***, int64_t *)
     * }
     */
    public static final long ModelMetadataGetCustomMetadataMapKeys$offset() {
        return ModelMetadataGetCustomMetadataMapKeys$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetCustomMetadataMapKeys)(const OrtModelMetadata *, OrtAllocator *, char ***, int64_t *)
     * }
     */
    public static MemorySegment ModelMetadataGetCustomMetadataMapKeys(MemorySegment struct) {
        return struct.get(ModelMetadataGetCustomMetadataMapKeys$LAYOUT, ModelMetadataGetCustomMetadataMapKeys$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetCustomMetadataMapKeys)(const OrtModelMetadata *, OrtAllocator *, char ***, int64_t *)
     * }
     */
    public static void ModelMetadataGetCustomMetadataMapKeys(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(
                ModelMetadataGetCustomMetadataMapKeys$LAYOUT, ModelMetadataGetCustomMetadataMapKeys$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetCustomMetadataMapKeys)(const OrtModelMetadata *, OrtAllocator *, char ***, int64_t *)
     * }
     */
    public static ModelMetadataGetCustomMetadataMapKeys.Function ModelMetadataGetCustomMetadataMapKeysFunction(
            MemorySegment struct) {
        return ModelMetadataGetCustomMetadataMapKeys.function(ModelMetadataGetCustomMetadataMapKeys(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*AddFreeDimensionOverrideByName)(OrtSessionOptions *, const char *, int64_t)
     * }
     */
    public static class AddFreeDimensionOverrideByName {

        AddFreeDimensionOverrideByName() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_LONG_LONG);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(AddFreeDimensionOverrideByName.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(AddFreeDimensionOverrideByName.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, long _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static AddFreeDimensionOverrideByName.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2) -> invoke(funcPtr, _x0, _x1, _x2);
        }
    }

    private static final AddressLayout AddFreeDimensionOverrideByName$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("AddFreeDimensionOverrideByName"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddFreeDimensionOverrideByName)(OrtSessionOptions *, const char *, int64_t)
     * }
     */
    public static final AddressLayout AddFreeDimensionOverrideByName$layout() {
        return AddFreeDimensionOverrideByName$LAYOUT;
    }

    private static final long AddFreeDimensionOverrideByName$OFFSET = 992;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddFreeDimensionOverrideByName)(OrtSessionOptions *, const char *, int64_t)
     * }
     */
    public static final long AddFreeDimensionOverrideByName$offset() {
        return AddFreeDimensionOverrideByName$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddFreeDimensionOverrideByName)(OrtSessionOptions *, const char *, int64_t)
     * }
     */
    public static MemorySegment AddFreeDimensionOverrideByName(MemorySegment struct) {
        return struct.get(AddFreeDimensionOverrideByName$LAYOUT, AddFreeDimensionOverrideByName$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddFreeDimensionOverrideByName)(OrtSessionOptions *, const char *, int64_t)
     * }
     */
    public static void AddFreeDimensionOverrideByName(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(AddFreeDimensionOverrideByName$LAYOUT, AddFreeDimensionOverrideByName$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddFreeDimensionOverrideByName)(OrtSessionOptions *, const char *, int64_t)
     * }
     */
    public static AddFreeDimensionOverrideByName.Function AddFreeDimensionOverrideByNameFunction(MemorySegment struct) {
        return AddFreeDimensionOverrideByName.function(AddFreeDimensionOverrideByName(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetAvailableProviders)(char ***, int *)
     * }
     */
    public static class GetAvailableProviders {

        GetAvailableProviders() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(GetAvailableProviders.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetAvailableProviders.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static GetAvailableProviders.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout GetAvailableProviders$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("GetAvailableProviders"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetAvailableProviders)(char ***, int *)
     * }
     */
    public static final AddressLayout GetAvailableProviders$layout() {
        return GetAvailableProviders$LAYOUT;
    }

    private static final long GetAvailableProviders$OFFSET = 1000;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetAvailableProviders)(char ***, int *)
     * }
     */
    public static final long GetAvailableProviders$offset() {
        return GetAvailableProviders$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetAvailableProviders)(char ***, int *)
     * }
     */
    public static MemorySegment GetAvailableProviders(MemorySegment struct) {
        return struct.get(GetAvailableProviders$LAYOUT, GetAvailableProviders$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetAvailableProviders)(char ***, int *)
     * }
     */
    public static void GetAvailableProviders(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetAvailableProviders$LAYOUT, GetAvailableProviders$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetAvailableProviders)(char ***, int *)
     * }
     */
    public static GetAvailableProviders.Function GetAvailableProvidersFunction(MemorySegment struct) {
        return GetAvailableProviders.function(GetAvailableProviders(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*ReleaseAvailableProviders)(char **, int)
     * }
     */
    public static class ReleaseAvailableProviders {

        ReleaseAvailableProviders() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, int _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_INT);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(ReleaseAvailableProviders.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleaseAvailableProviders.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, int _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static ReleaseAvailableProviders.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout ReleaseAvailableProviders$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("ReleaseAvailableProviders"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ReleaseAvailableProviders)(char **, int)
     * }
     */
    public static final AddressLayout ReleaseAvailableProviders$layout() {
        return ReleaseAvailableProviders$LAYOUT;
    }

    private static final long ReleaseAvailableProviders$OFFSET = 1008;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ReleaseAvailableProviders)(char **, int)
     * }
     */
    public static final long ReleaseAvailableProviders$offset() {
        return ReleaseAvailableProviders$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ReleaseAvailableProviders)(char **, int)
     * }
     */
    public static MemorySegment ReleaseAvailableProviders(MemorySegment struct) {
        return struct.get(ReleaseAvailableProviders$LAYOUT, ReleaseAvailableProviders$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ReleaseAvailableProviders)(char **, int)
     * }
     */
    public static void ReleaseAvailableProviders(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleaseAvailableProviders$LAYOUT, ReleaseAvailableProviders$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ReleaseAvailableProviders)(char **, int)
     * }
     */
    public static ReleaseAvailableProviders.Function ReleaseAvailableProvidersFunction(MemorySegment struct) {
        return ReleaseAvailableProviders.function(ReleaseAvailableProviders(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetStringTensorElementLength)(const OrtValue *, size_t, size_t *)
     * }
     */
    public static class GetStringTensorElementLength {

        GetStringTensorElementLength() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, long _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_LONG,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(GetStringTensorElementLength.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetStringTensorElementLength.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, long _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static GetStringTensorElementLength.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2) -> invoke(funcPtr, _x0, _x1, _x2);
        }
    }

    private static final AddressLayout GetStringTensorElementLength$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("GetStringTensorElementLength"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetStringTensorElementLength)(const OrtValue *, size_t, size_t *)
     * }
     */
    public static final AddressLayout GetStringTensorElementLength$layout() {
        return GetStringTensorElementLength$LAYOUT;
    }

    private static final long GetStringTensorElementLength$OFFSET = 1016;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetStringTensorElementLength)(const OrtValue *, size_t, size_t *)
     * }
     */
    public static final long GetStringTensorElementLength$offset() {
        return GetStringTensorElementLength$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetStringTensorElementLength)(const OrtValue *, size_t, size_t *)
     * }
     */
    public static MemorySegment GetStringTensorElementLength(MemorySegment struct) {
        return struct.get(GetStringTensorElementLength$LAYOUT, GetStringTensorElementLength$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetStringTensorElementLength)(const OrtValue *, size_t, size_t *)
     * }
     */
    public static void GetStringTensorElementLength(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetStringTensorElementLength$LAYOUT, GetStringTensorElementLength$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetStringTensorElementLength)(const OrtValue *, size_t, size_t *)
     * }
     */
    public static GetStringTensorElementLength.Function GetStringTensorElementLengthFunction(MemorySegment struct) {
        return GetStringTensorElementLength.function(GetStringTensorElementLength(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetStringTensorElement)(const OrtValue *, size_t, size_t, void *)
     * }
     */
    public static class GetStringTensorElement {

        GetStringTensorElement() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, long _x1, long _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_LONG,
                onnxruntime_all_h.C_LONG,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(GetStringTensorElement.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetStringTensorElement.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr, MemorySegment _x0, long _x1, long _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static GetStringTensorElement.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2, _x3) -> invoke(funcPtr, _x0, _x1, _x2, _x3);
        }
    }

    private static final AddressLayout GetStringTensorElement$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("GetStringTensorElement"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetStringTensorElement)(const OrtValue *, size_t, size_t, void *)
     * }
     */
    public static final AddressLayout GetStringTensorElement$layout() {
        return GetStringTensorElement$LAYOUT;
    }

    private static final long GetStringTensorElement$OFFSET = 1024;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetStringTensorElement)(const OrtValue *, size_t, size_t, void *)
     * }
     */
    public static final long GetStringTensorElement$offset() {
        return GetStringTensorElement$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetStringTensorElement)(const OrtValue *, size_t, size_t, void *)
     * }
     */
    public static MemorySegment GetStringTensorElement(MemorySegment struct) {
        return struct.get(GetStringTensorElement$LAYOUT, GetStringTensorElement$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetStringTensorElement)(const OrtValue *, size_t, size_t, void *)
     * }
     */
    public static void GetStringTensorElement(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetStringTensorElement$LAYOUT, GetStringTensorElement$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetStringTensorElement)(const OrtValue *, size_t, size_t, void *)
     * }
     */
    public static GetStringTensorElement.Function GetStringTensorElementFunction(MemorySegment struct) {
        return GetStringTensorElement.function(GetStringTensorElement(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*FillStringTensorElement)(OrtValue *, const char *, size_t)
     * }
     */
    public static class FillStringTensorElement {

        FillStringTensorElement() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_LONG);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(FillStringTensorElement.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(FillStringTensorElement.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, long _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static FillStringTensorElement.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2) -> invoke(funcPtr, _x0, _x1, _x2);
        }
    }

    private static final AddressLayout FillStringTensorElement$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("FillStringTensorElement"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*FillStringTensorElement)(OrtValue *, const char *, size_t)
     * }
     */
    public static final AddressLayout FillStringTensorElement$layout() {
        return FillStringTensorElement$LAYOUT;
    }

    private static final long FillStringTensorElement$OFFSET = 1032;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*FillStringTensorElement)(OrtValue *, const char *, size_t)
     * }
     */
    public static final long FillStringTensorElement$offset() {
        return FillStringTensorElement$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*FillStringTensorElement)(OrtValue *, const char *, size_t)
     * }
     */
    public static MemorySegment FillStringTensorElement(MemorySegment struct) {
        return struct.get(FillStringTensorElement$LAYOUT, FillStringTensorElement$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*FillStringTensorElement)(OrtValue *, const char *, size_t)
     * }
     */
    public static void FillStringTensorElement(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(FillStringTensorElement$LAYOUT, FillStringTensorElement$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*FillStringTensorElement)(OrtValue *, const char *, size_t)
     * }
     */
    public static FillStringTensorElement.Function FillStringTensorElementFunction(MemorySegment struct) {
        return FillStringTensorElement.function(FillStringTensorElement(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*AddSessionConfigEntry)(OrtSessionOptions *, const char *, const char *)
     * }
     */
    public static class AddSessionConfigEntry {

        AddSessionConfigEntry() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(AddSessionConfigEntry.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(AddSessionConfigEntry.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static AddSessionConfigEntry.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2) -> invoke(funcPtr, _x0, _x1, _x2);
        }
    }

    private static final AddressLayout AddSessionConfigEntry$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("AddSessionConfigEntry"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddSessionConfigEntry)(OrtSessionOptions *, const char *, const char *)
     * }
     */
    public static final AddressLayout AddSessionConfigEntry$layout() {
        return AddSessionConfigEntry$LAYOUT;
    }

    private static final long AddSessionConfigEntry$OFFSET = 1040;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddSessionConfigEntry)(OrtSessionOptions *, const char *, const char *)
     * }
     */
    public static final long AddSessionConfigEntry$offset() {
        return AddSessionConfigEntry$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddSessionConfigEntry)(OrtSessionOptions *, const char *, const char *)
     * }
     */
    public static MemorySegment AddSessionConfigEntry(MemorySegment struct) {
        return struct.get(AddSessionConfigEntry$LAYOUT, AddSessionConfigEntry$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddSessionConfigEntry)(OrtSessionOptions *, const char *, const char *)
     * }
     */
    public static void AddSessionConfigEntry(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(AddSessionConfigEntry$LAYOUT, AddSessionConfigEntry$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddSessionConfigEntry)(OrtSessionOptions *, const char *, const char *)
     * }
     */
    public static AddSessionConfigEntry.Function AddSessionConfigEntryFunction(MemorySegment struct) {
        return AddSessionConfigEntry.function(AddSessionConfigEntry(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateAllocator)(const OrtSession *, const OrtMemoryInfo *, OrtAllocator **)
     * }
     */
    public static class CreateAllocator {

        CreateAllocator() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(CreateAllocator.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateAllocator.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static CreateAllocator.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2) -> invoke(funcPtr, _x0, _x1, _x2);
        }
    }

    private static final AddressLayout CreateAllocator$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("CreateAllocator"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateAllocator)(const OrtSession *, const OrtMemoryInfo *, OrtAllocator **)
     * }
     */
    public static final AddressLayout CreateAllocator$layout() {
        return CreateAllocator$LAYOUT;
    }

    private static final long CreateAllocator$OFFSET = 1048;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateAllocator)(const OrtSession *, const OrtMemoryInfo *, OrtAllocator **)
     * }
     */
    public static final long CreateAllocator$offset() {
        return CreateAllocator$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateAllocator)(const OrtSession *, const OrtMemoryInfo *, OrtAllocator **)
     * }
     */
    public static MemorySegment CreateAllocator(MemorySegment struct) {
        return struct.get(CreateAllocator$LAYOUT, CreateAllocator$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateAllocator)(const OrtSession *, const OrtMemoryInfo *, OrtAllocator **)
     * }
     */
    public static void CreateAllocator(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateAllocator$LAYOUT, CreateAllocator$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateAllocator)(const OrtSession *, const OrtMemoryInfo *, OrtAllocator **)
     * }
     */
    public static CreateAllocator.Function CreateAllocatorFunction(MemorySegment struct) {
        return CreateAllocator.function(CreateAllocator(struct));
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseAllocator)(OrtAllocator *)
     * }
     */
    public static class ReleaseAllocator {

        ReleaseAllocator() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(ReleaseAllocator.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleaseAllocator.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static ReleaseAllocator.Function function(MemorySegment funcPtr) {
            return (_x0) -> invoke(funcPtr, _x0);
        }
    }

    private static final AddressLayout ReleaseAllocator$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("ReleaseAllocator"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ReleaseAllocator)(OrtAllocator *)
     * }
     */
    public static final AddressLayout ReleaseAllocator$layout() {
        return ReleaseAllocator$LAYOUT;
    }

    private static final long ReleaseAllocator$OFFSET = 1056;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ReleaseAllocator)(OrtAllocator *)
     * }
     */
    public static final long ReleaseAllocator$offset() {
        return ReleaseAllocator$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ReleaseAllocator)(OrtAllocator *)
     * }
     */
    public static MemorySegment ReleaseAllocator(MemorySegment struct) {
        return struct.get(ReleaseAllocator$LAYOUT, ReleaseAllocator$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ReleaseAllocator)(OrtAllocator *)
     * }
     */
    public static void ReleaseAllocator(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleaseAllocator$LAYOUT, ReleaseAllocator$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * void (*ReleaseAllocator)(OrtAllocator *)
     * }
     */
    public static ReleaseAllocator.Function ReleaseAllocatorFunction(MemorySegment struct) {
        return ReleaseAllocator.function(ReleaseAllocator(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*RunWithBinding)(OrtSession *, const OrtRunOptions *, const OrtIoBinding *)
     * }
     */
    public static class RunWithBinding {

        RunWithBinding() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(RunWithBinding.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(RunWithBinding.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static RunWithBinding.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2) -> invoke(funcPtr, _x0, _x1, _x2);
        }
    }

    private static final AddressLayout RunWithBinding$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("RunWithBinding"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunWithBinding)(OrtSession *, const OrtRunOptions *, const OrtIoBinding *)
     * }
     */
    public static final AddressLayout RunWithBinding$layout() {
        return RunWithBinding$LAYOUT;
    }

    private static final long RunWithBinding$OFFSET = 1064;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunWithBinding)(OrtSession *, const OrtRunOptions *, const OrtIoBinding *)
     * }
     */
    public static final long RunWithBinding$offset() {
        return RunWithBinding$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunWithBinding)(OrtSession *, const OrtRunOptions *, const OrtIoBinding *)
     * }
     */
    public static MemorySegment RunWithBinding(MemorySegment struct) {
        return struct.get(RunWithBinding$LAYOUT, RunWithBinding$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunWithBinding)(OrtSession *, const OrtRunOptions *, const OrtIoBinding *)
     * }
     */
    public static void RunWithBinding(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(RunWithBinding$LAYOUT, RunWithBinding$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunWithBinding)(OrtSession *, const OrtRunOptions *, const OrtIoBinding *)
     * }
     */
    public static RunWithBinding.Function RunWithBindingFunction(MemorySegment struct) {
        return RunWithBinding.function(RunWithBinding(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateIoBinding)(OrtSession *, OrtIoBinding **)
     * }
     */
    public static class CreateIoBinding {

        CreateIoBinding() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(CreateIoBinding.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateIoBinding.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static CreateIoBinding.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout CreateIoBinding$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("CreateIoBinding"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateIoBinding)(OrtSession *, OrtIoBinding **)
     * }
     */
    public static final AddressLayout CreateIoBinding$layout() {
        return CreateIoBinding$LAYOUT;
    }

    private static final long CreateIoBinding$OFFSET = 1072;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateIoBinding)(OrtSession *, OrtIoBinding **)
     * }
     */
    public static final long CreateIoBinding$offset() {
        return CreateIoBinding$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateIoBinding)(OrtSession *, OrtIoBinding **)
     * }
     */
    public static MemorySegment CreateIoBinding(MemorySegment struct) {
        return struct.get(CreateIoBinding$LAYOUT, CreateIoBinding$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateIoBinding)(OrtSession *, OrtIoBinding **)
     * }
     */
    public static void CreateIoBinding(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateIoBinding$LAYOUT, CreateIoBinding$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateIoBinding)(OrtSession *, OrtIoBinding **)
     * }
     */
    public static CreateIoBinding.Function CreateIoBindingFunction(MemorySegment struct) {
        return CreateIoBinding.function(CreateIoBinding(struct));
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseIoBinding)(OrtIoBinding *)
     * }
     */
    public static class ReleaseIoBinding {

        ReleaseIoBinding() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(ReleaseIoBinding.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleaseIoBinding.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static ReleaseIoBinding.Function function(MemorySegment funcPtr) {
            return (_x0) -> invoke(funcPtr, _x0);
        }
    }

    private static final AddressLayout ReleaseIoBinding$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("ReleaseIoBinding"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ReleaseIoBinding)(OrtIoBinding *)
     * }
     */
    public static final AddressLayout ReleaseIoBinding$layout() {
        return ReleaseIoBinding$LAYOUT;
    }

    private static final long ReleaseIoBinding$OFFSET = 1080;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ReleaseIoBinding)(OrtIoBinding *)
     * }
     */
    public static final long ReleaseIoBinding$offset() {
        return ReleaseIoBinding$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ReleaseIoBinding)(OrtIoBinding *)
     * }
     */
    public static MemorySegment ReleaseIoBinding(MemorySegment struct) {
        return struct.get(ReleaseIoBinding$LAYOUT, ReleaseIoBinding$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ReleaseIoBinding)(OrtIoBinding *)
     * }
     */
    public static void ReleaseIoBinding(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleaseIoBinding$LAYOUT, ReleaseIoBinding$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * void (*ReleaseIoBinding)(OrtIoBinding *)
     * }
     */
    public static ReleaseIoBinding.Function ReleaseIoBindingFunction(MemorySegment struct) {
        return ReleaseIoBinding.function(ReleaseIoBinding(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*BindInput)(OrtIoBinding *, const char *, const OrtValue *)
     * }
     */
    public static class BindInput {

        BindInput() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(BindInput.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(BindInput.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static BindInput.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2) -> invoke(funcPtr, _x0, _x1, _x2);
        }
    }

    private static final AddressLayout BindInput$LAYOUT = (AddressLayout) $LAYOUT.select(groupElement("BindInput"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*BindInput)(OrtIoBinding *, const char *, const OrtValue *)
     * }
     */
    public static final AddressLayout BindInput$layout() {
        return BindInput$LAYOUT;
    }

    private static final long BindInput$OFFSET = 1088;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*BindInput)(OrtIoBinding *, const char *, const OrtValue *)
     * }
     */
    public static final long BindInput$offset() {
        return BindInput$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*BindInput)(OrtIoBinding *, const char *, const OrtValue *)
     * }
     */
    public static MemorySegment BindInput(MemorySegment struct) {
        return struct.get(BindInput$LAYOUT, BindInput$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*BindInput)(OrtIoBinding *, const char *, const OrtValue *)
     * }
     */
    public static void BindInput(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(BindInput$LAYOUT, BindInput$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*BindInput)(OrtIoBinding *, const char *, const OrtValue *)
     * }
     */
    public static BindInput.Function BindInputFunction(MemorySegment struct) {
        return BindInput.function(BindInput(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*BindOutput)(OrtIoBinding *, const char *, const OrtValue *)
     * }
     */
    public static class BindOutput {

        BindOutput() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(BindOutput.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(BindOutput.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static BindOutput.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2) -> invoke(funcPtr, _x0, _x1, _x2);
        }
    }

    private static final AddressLayout BindOutput$LAYOUT = (AddressLayout) $LAYOUT.select(groupElement("BindOutput"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*BindOutput)(OrtIoBinding *, const char *, const OrtValue *)
     * }
     */
    public static final AddressLayout BindOutput$layout() {
        return BindOutput$LAYOUT;
    }

    private static final long BindOutput$OFFSET = 1096;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*BindOutput)(OrtIoBinding *, const char *, const OrtValue *)
     * }
     */
    public static final long BindOutput$offset() {
        return BindOutput$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*BindOutput)(OrtIoBinding *, const char *, const OrtValue *)
     * }
     */
    public static MemorySegment BindOutput(MemorySegment struct) {
        return struct.get(BindOutput$LAYOUT, BindOutput$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*BindOutput)(OrtIoBinding *, const char *, const OrtValue *)
     * }
     */
    public static void BindOutput(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(BindOutput$LAYOUT, BindOutput$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*BindOutput)(OrtIoBinding *, const char *, const OrtValue *)
     * }
     */
    public static BindOutput.Function BindOutputFunction(MemorySegment struct) {
        return BindOutput.function(BindOutput(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*BindOutputToDevice)(OrtIoBinding *, const char *, const OrtMemoryInfo *)
     * }
     */
    public static class BindOutputToDevice {

        BindOutputToDevice() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(BindOutputToDevice.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(BindOutputToDevice.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static BindOutputToDevice.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2) -> invoke(funcPtr, _x0, _x1, _x2);
        }
    }

    private static final AddressLayout BindOutputToDevice$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("BindOutputToDevice"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*BindOutputToDevice)(OrtIoBinding *, const char *, const OrtMemoryInfo *)
     * }
     */
    public static final AddressLayout BindOutputToDevice$layout() {
        return BindOutputToDevice$LAYOUT;
    }

    private static final long BindOutputToDevice$OFFSET = 1104;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*BindOutputToDevice)(OrtIoBinding *, const char *, const OrtMemoryInfo *)
     * }
     */
    public static final long BindOutputToDevice$offset() {
        return BindOutputToDevice$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*BindOutputToDevice)(OrtIoBinding *, const char *, const OrtMemoryInfo *)
     * }
     */
    public static MemorySegment BindOutputToDevice(MemorySegment struct) {
        return struct.get(BindOutputToDevice$LAYOUT, BindOutputToDevice$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*BindOutputToDevice)(OrtIoBinding *, const char *, const OrtMemoryInfo *)
     * }
     */
    public static void BindOutputToDevice(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(BindOutputToDevice$LAYOUT, BindOutputToDevice$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*BindOutputToDevice)(OrtIoBinding *, const char *, const OrtMemoryInfo *)
     * }
     */
    public static BindOutputToDevice.Function BindOutputToDeviceFunction(MemorySegment struct) {
        return BindOutputToDevice.function(BindOutputToDevice(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetBoundOutputNames)(const OrtIoBinding *, OrtAllocator *, char **, size_t **, size_t *)
     * }
     */
    public static class GetBoundOutputNames {

        GetBoundOutputNames() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(
                    MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(GetBoundOutputNames.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetBoundOutputNames.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr,
                MemorySegment _x0,
                MemorySegment _x1,
                MemorySegment _x2,
                MemorySegment _x3,
                MemorySegment _x4) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static GetBoundOutputNames.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2, _x3, _x4) -> invoke(funcPtr, _x0, _x1, _x2, _x3, _x4);
        }
    }

    private static final AddressLayout GetBoundOutputNames$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("GetBoundOutputNames"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetBoundOutputNames)(const OrtIoBinding *, OrtAllocator *, char **, size_t **, size_t *)
     * }
     */
    public static final AddressLayout GetBoundOutputNames$layout() {
        return GetBoundOutputNames$LAYOUT;
    }

    private static final long GetBoundOutputNames$OFFSET = 1112;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetBoundOutputNames)(const OrtIoBinding *, OrtAllocator *, char **, size_t **, size_t *)
     * }
     */
    public static final long GetBoundOutputNames$offset() {
        return GetBoundOutputNames$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetBoundOutputNames)(const OrtIoBinding *, OrtAllocator *, char **, size_t **, size_t *)
     * }
     */
    public static MemorySegment GetBoundOutputNames(MemorySegment struct) {
        return struct.get(GetBoundOutputNames$LAYOUT, GetBoundOutputNames$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetBoundOutputNames)(const OrtIoBinding *, OrtAllocator *, char **, size_t **, size_t *)
     * }
     */
    public static void GetBoundOutputNames(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetBoundOutputNames$LAYOUT, GetBoundOutputNames$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetBoundOutputNames)(const OrtIoBinding *, OrtAllocator *, char **, size_t **, size_t *)
     * }
     */
    public static GetBoundOutputNames.Function GetBoundOutputNamesFunction(MemorySegment struct) {
        return GetBoundOutputNames.function(GetBoundOutputNames(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetBoundOutputValues)(const OrtIoBinding *, OrtAllocator *, OrtValue ***, size_t *)
     * }
     */
    public static class GetBoundOutputValues {

        GetBoundOutputValues() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(GetBoundOutputValues.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetBoundOutputValues.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static GetBoundOutputValues.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2, _x3) -> invoke(funcPtr, _x0, _x1, _x2, _x3);
        }
    }

    private static final AddressLayout GetBoundOutputValues$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("GetBoundOutputValues"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetBoundOutputValues)(const OrtIoBinding *, OrtAllocator *, OrtValue ***, size_t *)
     * }
     */
    public static final AddressLayout GetBoundOutputValues$layout() {
        return GetBoundOutputValues$LAYOUT;
    }

    private static final long GetBoundOutputValues$OFFSET = 1120;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetBoundOutputValues)(const OrtIoBinding *, OrtAllocator *, OrtValue ***, size_t *)
     * }
     */
    public static final long GetBoundOutputValues$offset() {
        return GetBoundOutputValues$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetBoundOutputValues)(const OrtIoBinding *, OrtAllocator *, OrtValue ***, size_t *)
     * }
     */
    public static MemorySegment GetBoundOutputValues(MemorySegment struct) {
        return struct.get(GetBoundOutputValues$LAYOUT, GetBoundOutputValues$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetBoundOutputValues)(const OrtIoBinding *, OrtAllocator *, OrtValue ***, size_t *)
     * }
     */
    public static void GetBoundOutputValues(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetBoundOutputValues$LAYOUT, GetBoundOutputValues$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetBoundOutputValues)(const OrtIoBinding *, OrtAllocator *, OrtValue ***, size_t *)
     * }
     */
    public static GetBoundOutputValues.Function GetBoundOutputValuesFunction(MemorySegment struct) {
        return GetBoundOutputValues.function(GetBoundOutputValues(struct));
    }

    /**
     * {@snippet lang=c :
     * void (*ClearBoundInputs)(OrtIoBinding *)
     * }
     */
    public static class ClearBoundInputs {

        ClearBoundInputs() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(ClearBoundInputs.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ClearBoundInputs.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static ClearBoundInputs.Function function(MemorySegment funcPtr) {
            return (_x0) -> invoke(funcPtr, _x0);
        }
    }

    private static final AddressLayout ClearBoundInputs$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("ClearBoundInputs"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ClearBoundInputs)(OrtIoBinding *)
     * }
     */
    public static final AddressLayout ClearBoundInputs$layout() {
        return ClearBoundInputs$LAYOUT;
    }

    private static final long ClearBoundInputs$OFFSET = 1128;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ClearBoundInputs)(OrtIoBinding *)
     * }
     */
    public static final long ClearBoundInputs$offset() {
        return ClearBoundInputs$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ClearBoundInputs)(OrtIoBinding *)
     * }
     */
    public static MemorySegment ClearBoundInputs(MemorySegment struct) {
        return struct.get(ClearBoundInputs$LAYOUT, ClearBoundInputs$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ClearBoundInputs)(OrtIoBinding *)
     * }
     */
    public static void ClearBoundInputs(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ClearBoundInputs$LAYOUT, ClearBoundInputs$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * void (*ClearBoundInputs)(OrtIoBinding *)
     * }
     */
    public static ClearBoundInputs.Function ClearBoundInputsFunction(MemorySegment struct) {
        return ClearBoundInputs.function(ClearBoundInputs(struct));
    }

    /**
     * {@snippet lang=c :
     * void (*ClearBoundOutputs)(OrtIoBinding *)
     * }
     */
    public static class ClearBoundOutputs {

        ClearBoundOutputs() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(ClearBoundOutputs.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ClearBoundOutputs.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static ClearBoundOutputs.Function function(MemorySegment funcPtr) {
            return (_x0) -> invoke(funcPtr, _x0);
        }
    }

    private static final AddressLayout ClearBoundOutputs$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("ClearBoundOutputs"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ClearBoundOutputs)(OrtIoBinding *)
     * }
     */
    public static final AddressLayout ClearBoundOutputs$layout() {
        return ClearBoundOutputs$LAYOUT;
    }

    private static final long ClearBoundOutputs$OFFSET = 1136;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ClearBoundOutputs)(OrtIoBinding *)
     * }
     */
    public static final long ClearBoundOutputs$offset() {
        return ClearBoundOutputs$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ClearBoundOutputs)(OrtIoBinding *)
     * }
     */
    public static MemorySegment ClearBoundOutputs(MemorySegment struct) {
        return struct.get(ClearBoundOutputs$LAYOUT, ClearBoundOutputs$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ClearBoundOutputs)(OrtIoBinding *)
     * }
     */
    public static void ClearBoundOutputs(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ClearBoundOutputs$LAYOUT, ClearBoundOutputs$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * void (*ClearBoundOutputs)(OrtIoBinding *)
     * }
     */
    public static ClearBoundOutputs.Function ClearBoundOutputsFunction(MemorySegment struct) {
        return ClearBoundOutputs.function(ClearBoundOutputs(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*TensorAt)(OrtValue *, const int64_t *, size_t, void **)
     * }
     */
    public static class TensorAt {

        TensorAt() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_LONG,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(TensorAt.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(TensorAt.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static TensorAt.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2, _x3) -> invoke(funcPtr, _x0, _x1, _x2, _x3);
        }
    }

    private static final AddressLayout TensorAt$LAYOUT = (AddressLayout) $LAYOUT.select(groupElement("TensorAt"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*TensorAt)(OrtValue *, const int64_t *, size_t, void **)
     * }
     */
    public static final AddressLayout TensorAt$layout() {
        return TensorAt$LAYOUT;
    }

    private static final long TensorAt$OFFSET = 1144;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*TensorAt)(OrtValue *, const int64_t *, size_t, void **)
     * }
     */
    public static final long TensorAt$offset() {
        return TensorAt$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*TensorAt)(OrtValue *, const int64_t *, size_t, void **)
     * }
     */
    public static MemorySegment TensorAt(MemorySegment struct) {
        return struct.get(TensorAt$LAYOUT, TensorAt$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*TensorAt)(OrtValue *, const int64_t *, size_t, void **)
     * }
     */
    public static void TensorAt(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(TensorAt$LAYOUT, TensorAt$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*TensorAt)(OrtValue *, const int64_t *, size_t, void **)
     * }
     */
    public static TensorAt.Function TensorAtFunction(MemorySegment struct) {
        return TensorAt.function(TensorAt(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateAndRegisterAllocator)(OrtEnv *, const OrtMemoryInfo *, const OrtArenaCfg *)
     * }
     */
    public static class CreateAndRegisterAllocator {

        CreateAndRegisterAllocator() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(CreateAndRegisterAllocator.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateAndRegisterAllocator.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static CreateAndRegisterAllocator.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2) -> invoke(funcPtr, _x0, _x1, _x2);
        }
    }

    private static final AddressLayout CreateAndRegisterAllocator$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("CreateAndRegisterAllocator"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateAndRegisterAllocator)(OrtEnv *, const OrtMemoryInfo *, const OrtArenaCfg *)
     * }
     */
    public static final AddressLayout CreateAndRegisterAllocator$layout() {
        return CreateAndRegisterAllocator$LAYOUT;
    }

    private static final long CreateAndRegisterAllocator$OFFSET = 1152;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateAndRegisterAllocator)(OrtEnv *, const OrtMemoryInfo *, const OrtArenaCfg *)
     * }
     */
    public static final long CreateAndRegisterAllocator$offset() {
        return CreateAndRegisterAllocator$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateAndRegisterAllocator)(OrtEnv *, const OrtMemoryInfo *, const OrtArenaCfg *)
     * }
     */
    public static MemorySegment CreateAndRegisterAllocator(MemorySegment struct) {
        return struct.get(CreateAndRegisterAllocator$LAYOUT, CreateAndRegisterAllocator$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateAndRegisterAllocator)(OrtEnv *, const OrtMemoryInfo *, const OrtArenaCfg *)
     * }
     */
    public static void CreateAndRegisterAllocator(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateAndRegisterAllocator$LAYOUT, CreateAndRegisterAllocator$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateAndRegisterAllocator)(OrtEnv *, const OrtMemoryInfo *, const OrtArenaCfg *)
     * }
     */
    public static CreateAndRegisterAllocator.Function CreateAndRegisterAllocatorFunction(MemorySegment struct) {
        return CreateAndRegisterAllocator.function(CreateAndRegisterAllocator(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SetLanguageProjection)(const OrtEnv *, OrtLanguageProjection)
     * }
     */
    public static class SetLanguageProjection {

        SetLanguageProjection() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, int _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_INT);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(SetLanguageProjection.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetLanguageProjection.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, int _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static SetLanguageProjection.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout SetLanguageProjection$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("SetLanguageProjection"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetLanguageProjection)(const OrtEnv *, OrtLanguageProjection)
     * }
     */
    public static final AddressLayout SetLanguageProjection$layout() {
        return SetLanguageProjection$LAYOUT;
    }

    private static final long SetLanguageProjection$OFFSET = 1160;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetLanguageProjection)(const OrtEnv *, OrtLanguageProjection)
     * }
     */
    public static final long SetLanguageProjection$offset() {
        return SetLanguageProjection$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetLanguageProjection)(const OrtEnv *, OrtLanguageProjection)
     * }
     */
    public static MemorySegment SetLanguageProjection(MemorySegment struct) {
        return struct.get(SetLanguageProjection$LAYOUT, SetLanguageProjection$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetLanguageProjection)(const OrtEnv *, OrtLanguageProjection)
     * }
     */
    public static void SetLanguageProjection(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetLanguageProjection$LAYOUT, SetLanguageProjection$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetLanguageProjection)(const OrtEnv *, OrtLanguageProjection)
     * }
     */
    public static SetLanguageProjection.Function SetLanguageProjectionFunction(MemorySegment struct) {
        return SetLanguageProjection.function(SetLanguageProjection(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetProfilingStartTimeNs)(const OrtSession *, uint64_t *)
     * }
     */
    public static class SessionGetProfilingStartTimeNs {

        SessionGetProfilingStartTimeNs() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(SessionGetProfilingStartTimeNs.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SessionGetProfilingStartTimeNs.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static SessionGetProfilingStartTimeNs.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout SessionGetProfilingStartTimeNs$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("SessionGetProfilingStartTimeNs"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetProfilingStartTimeNs)(const OrtSession *, uint64_t *)
     * }
     */
    public static final AddressLayout SessionGetProfilingStartTimeNs$layout() {
        return SessionGetProfilingStartTimeNs$LAYOUT;
    }

    private static final long SessionGetProfilingStartTimeNs$OFFSET = 1168;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetProfilingStartTimeNs)(const OrtSession *, uint64_t *)
     * }
     */
    public static final long SessionGetProfilingStartTimeNs$offset() {
        return SessionGetProfilingStartTimeNs$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetProfilingStartTimeNs)(const OrtSession *, uint64_t *)
     * }
     */
    public static MemorySegment SessionGetProfilingStartTimeNs(MemorySegment struct) {
        return struct.get(SessionGetProfilingStartTimeNs$LAYOUT, SessionGetProfilingStartTimeNs$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetProfilingStartTimeNs)(const OrtSession *, uint64_t *)
     * }
     */
    public static void SessionGetProfilingStartTimeNs(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SessionGetProfilingStartTimeNs$LAYOUT, SessionGetProfilingStartTimeNs$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionGetProfilingStartTimeNs)(const OrtSession *, uint64_t *)
     * }
     */
    public static SessionGetProfilingStartTimeNs.Function SessionGetProfilingStartTimeNsFunction(MemorySegment struct) {
        return SessionGetProfilingStartTimeNs.function(SessionGetProfilingStartTimeNs(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalIntraOpNumThreads)(OrtThreadingOptions *, int)
     * }
     */
    public static class SetGlobalIntraOpNumThreads {

        SetGlobalIntraOpNumThreads() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, int _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_INT);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(SetGlobalIntraOpNumThreads.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetGlobalIntraOpNumThreads.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, int _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static SetGlobalIntraOpNumThreads.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout SetGlobalIntraOpNumThreads$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("SetGlobalIntraOpNumThreads"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalIntraOpNumThreads)(OrtThreadingOptions *, int)
     * }
     */
    public static final AddressLayout SetGlobalIntraOpNumThreads$layout() {
        return SetGlobalIntraOpNumThreads$LAYOUT;
    }

    private static final long SetGlobalIntraOpNumThreads$OFFSET = 1176;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalIntraOpNumThreads)(OrtThreadingOptions *, int)
     * }
     */
    public static final long SetGlobalIntraOpNumThreads$offset() {
        return SetGlobalIntraOpNumThreads$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalIntraOpNumThreads)(OrtThreadingOptions *, int)
     * }
     */
    public static MemorySegment SetGlobalIntraOpNumThreads(MemorySegment struct) {
        return struct.get(SetGlobalIntraOpNumThreads$LAYOUT, SetGlobalIntraOpNumThreads$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalIntraOpNumThreads)(OrtThreadingOptions *, int)
     * }
     */
    public static void SetGlobalIntraOpNumThreads(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetGlobalIntraOpNumThreads$LAYOUT, SetGlobalIntraOpNumThreads$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalIntraOpNumThreads)(OrtThreadingOptions *, int)
     * }
     */
    public static SetGlobalIntraOpNumThreads.Function SetGlobalIntraOpNumThreadsFunction(MemorySegment struct) {
        return SetGlobalIntraOpNumThreads.function(SetGlobalIntraOpNumThreads(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalInterOpNumThreads)(OrtThreadingOptions *, int)
     * }
     */
    public static class SetGlobalInterOpNumThreads {

        SetGlobalInterOpNumThreads() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, int _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_INT);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(SetGlobalInterOpNumThreads.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetGlobalInterOpNumThreads.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, int _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static SetGlobalInterOpNumThreads.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout SetGlobalInterOpNumThreads$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("SetGlobalInterOpNumThreads"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalInterOpNumThreads)(OrtThreadingOptions *, int)
     * }
     */
    public static final AddressLayout SetGlobalInterOpNumThreads$layout() {
        return SetGlobalInterOpNumThreads$LAYOUT;
    }

    private static final long SetGlobalInterOpNumThreads$OFFSET = 1184;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalInterOpNumThreads)(OrtThreadingOptions *, int)
     * }
     */
    public static final long SetGlobalInterOpNumThreads$offset() {
        return SetGlobalInterOpNumThreads$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalInterOpNumThreads)(OrtThreadingOptions *, int)
     * }
     */
    public static MemorySegment SetGlobalInterOpNumThreads(MemorySegment struct) {
        return struct.get(SetGlobalInterOpNumThreads$LAYOUT, SetGlobalInterOpNumThreads$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalInterOpNumThreads)(OrtThreadingOptions *, int)
     * }
     */
    public static void SetGlobalInterOpNumThreads(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetGlobalInterOpNumThreads$LAYOUT, SetGlobalInterOpNumThreads$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalInterOpNumThreads)(OrtThreadingOptions *, int)
     * }
     */
    public static SetGlobalInterOpNumThreads.Function SetGlobalInterOpNumThreadsFunction(MemorySegment struct) {
        return SetGlobalInterOpNumThreads.function(SetGlobalInterOpNumThreads(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalSpinControl)(OrtThreadingOptions *, int)
     * }
     */
    public static class SetGlobalSpinControl {

        SetGlobalSpinControl() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, int _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_INT);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(SetGlobalSpinControl.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetGlobalSpinControl.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, int _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static SetGlobalSpinControl.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout SetGlobalSpinControl$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("SetGlobalSpinControl"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalSpinControl)(OrtThreadingOptions *, int)
     * }
     */
    public static final AddressLayout SetGlobalSpinControl$layout() {
        return SetGlobalSpinControl$LAYOUT;
    }

    private static final long SetGlobalSpinControl$OFFSET = 1192;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalSpinControl)(OrtThreadingOptions *, int)
     * }
     */
    public static final long SetGlobalSpinControl$offset() {
        return SetGlobalSpinControl$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalSpinControl)(OrtThreadingOptions *, int)
     * }
     */
    public static MemorySegment SetGlobalSpinControl(MemorySegment struct) {
        return struct.get(SetGlobalSpinControl$LAYOUT, SetGlobalSpinControl$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalSpinControl)(OrtThreadingOptions *, int)
     * }
     */
    public static void SetGlobalSpinControl(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetGlobalSpinControl$LAYOUT, SetGlobalSpinControl$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalSpinControl)(OrtThreadingOptions *, int)
     * }
     */
    public static SetGlobalSpinControl.Function SetGlobalSpinControlFunction(MemorySegment struct) {
        return SetGlobalSpinControl.function(SetGlobalSpinControl(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*AddInitializer)(OrtSessionOptions *, const char *, const OrtValue *)
     * }
     */
    public static class AddInitializer {

        AddInitializer() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(AddInitializer.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(AddInitializer.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static AddInitializer.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2) -> invoke(funcPtr, _x0, _x1, _x2);
        }
    }

    private static final AddressLayout AddInitializer$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("AddInitializer"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddInitializer)(OrtSessionOptions *, const char *, const OrtValue *)
     * }
     */
    public static final AddressLayout AddInitializer$layout() {
        return AddInitializer$LAYOUT;
    }

    private static final long AddInitializer$OFFSET = 1200;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddInitializer)(OrtSessionOptions *, const char *, const OrtValue *)
     * }
     */
    public static final long AddInitializer$offset() {
        return AddInitializer$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddInitializer)(OrtSessionOptions *, const char *, const OrtValue *)
     * }
     */
    public static MemorySegment AddInitializer(MemorySegment struct) {
        return struct.get(AddInitializer$LAYOUT, AddInitializer$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddInitializer)(OrtSessionOptions *, const char *, const OrtValue *)
     * }
     */
    public static void AddInitializer(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(AddInitializer$LAYOUT, AddInitializer$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddInitializer)(OrtSessionOptions *, const char *, const OrtValue *)
     * }
     */
    public static AddInitializer.Function AddInitializerFunction(MemorySegment struct) {
        return AddInitializer.function(AddInitializer(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateEnvWithCustomLoggerAndGlobalThreadPools)(OrtLoggingFunction, void *, OrtLoggingLevel, const char *, const struct OrtThreadingOptions *, OrtEnv **)
     * }
     */
    public static class CreateEnvWithCustomLoggerAndGlobalThreadPools {

        CreateEnvWithCustomLoggerAndGlobalThreadPools() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(
                    MemorySegment _x0,
                    MemorySegment _x1,
                    int _x2,
                    MemorySegment _x3,
                    MemorySegment _x4,
                    MemorySegment _x5);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_INT,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_all_h.upcallHandle(
                CreateEnvWithCustomLoggerAndGlobalThreadPools.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateEnvWithCustomLoggerAndGlobalThreadPools.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr,
                MemorySegment _x0,
                MemorySegment _x1,
                int _x2,
                MemorySegment _x3,
                MemorySegment _x4,
                MemorySegment _x5) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static CreateEnvWithCustomLoggerAndGlobalThreadPools.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2, _x3, _x4, _x5) -> invoke(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);
        }
    }

    private static final AddressLayout CreateEnvWithCustomLoggerAndGlobalThreadPools$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("CreateEnvWithCustomLoggerAndGlobalThreadPools"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateEnvWithCustomLoggerAndGlobalThreadPools)(OrtLoggingFunction, void *, OrtLoggingLevel, const char *, const struct OrtThreadingOptions *, OrtEnv **)
     * }
     */
    public static final AddressLayout CreateEnvWithCustomLoggerAndGlobalThreadPools$layout() {
        return CreateEnvWithCustomLoggerAndGlobalThreadPools$LAYOUT;
    }

    private static final long CreateEnvWithCustomLoggerAndGlobalThreadPools$OFFSET = 1208;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateEnvWithCustomLoggerAndGlobalThreadPools)(OrtLoggingFunction, void *, OrtLoggingLevel, const char *, const struct OrtThreadingOptions *, OrtEnv **)
     * }
     */
    public static final long CreateEnvWithCustomLoggerAndGlobalThreadPools$offset() {
        return CreateEnvWithCustomLoggerAndGlobalThreadPools$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateEnvWithCustomLoggerAndGlobalThreadPools)(OrtLoggingFunction, void *, OrtLoggingLevel, const char *, const struct OrtThreadingOptions *, OrtEnv **)
     * }
     */
    public static MemorySegment CreateEnvWithCustomLoggerAndGlobalThreadPools(MemorySegment struct) {
        return struct.get(
                CreateEnvWithCustomLoggerAndGlobalThreadPools$LAYOUT,
                CreateEnvWithCustomLoggerAndGlobalThreadPools$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateEnvWithCustomLoggerAndGlobalThreadPools)(OrtLoggingFunction, void *, OrtLoggingLevel, const char *, const struct OrtThreadingOptions *, OrtEnv **)
     * }
     */
    public static void CreateEnvWithCustomLoggerAndGlobalThreadPools(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(
                CreateEnvWithCustomLoggerAndGlobalThreadPools$LAYOUT,
                CreateEnvWithCustomLoggerAndGlobalThreadPools$OFFSET,
                fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateEnvWithCustomLoggerAndGlobalThreadPools)(OrtLoggingFunction, void *, OrtLoggingLevel, const char *, const struct OrtThreadingOptions *, OrtEnv **)
     * }
     */
    public static CreateEnvWithCustomLoggerAndGlobalThreadPools.Function
            CreateEnvWithCustomLoggerAndGlobalThreadPoolsFunction(MemorySegment struct) {
        return CreateEnvWithCustomLoggerAndGlobalThreadPools.function(
                CreateEnvWithCustomLoggerAndGlobalThreadPools(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_CUDA)(OrtSessionOptions *, const OrtCUDAProviderOptions *)
     * }
     */
    public static class SessionOptionsAppendExecutionProvider_CUDA {

        SessionOptionsAppendExecutionProvider_CUDA() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_all_h.upcallHandle(
                SessionOptionsAppendExecutionProvider_CUDA.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SessionOptionsAppendExecutionProvider_CUDA.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static SessionOptionsAppendExecutionProvider_CUDA.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout SessionOptionsAppendExecutionProvider_CUDA$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("SessionOptionsAppendExecutionProvider_CUDA"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_CUDA)(OrtSessionOptions *, const OrtCUDAProviderOptions *)
     * }
     */
    public static final AddressLayout SessionOptionsAppendExecutionProvider_CUDA$layout() {
        return SessionOptionsAppendExecutionProvider_CUDA$LAYOUT;
    }

    private static final long SessionOptionsAppendExecutionProvider_CUDA$OFFSET = 1216;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_CUDA)(OrtSessionOptions *, const OrtCUDAProviderOptions *)
     * }
     */
    public static final long SessionOptionsAppendExecutionProvider_CUDA$offset() {
        return SessionOptionsAppendExecutionProvider_CUDA$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_CUDA)(OrtSessionOptions *, const OrtCUDAProviderOptions *)
     * }
     */
    public static MemorySegment SessionOptionsAppendExecutionProvider_CUDA(MemorySegment struct) {
        return struct.get(
                SessionOptionsAppendExecutionProvider_CUDA$LAYOUT, SessionOptionsAppendExecutionProvider_CUDA$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_CUDA)(OrtSessionOptions *, const OrtCUDAProviderOptions *)
     * }
     */
    public static void SessionOptionsAppendExecutionProvider_CUDA(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(
                SessionOptionsAppendExecutionProvider_CUDA$LAYOUT,
                SessionOptionsAppendExecutionProvider_CUDA$OFFSET,
                fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_CUDA)(OrtSessionOptions *, const OrtCUDAProviderOptions *)
     * }
     */
    public static SessionOptionsAppendExecutionProvider_CUDA.Function
            SessionOptionsAppendExecutionProvider_CUDAFunction(MemorySegment struct) {
        return SessionOptionsAppendExecutionProvider_CUDA.function(SessionOptionsAppendExecutionProvider_CUDA(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_ROCM)(OrtSessionOptions *, const OrtROCMProviderOptions *)
     * }
     */
    public static class SessionOptionsAppendExecutionProvider_ROCM {

        SessionOptionsAppendExecutionProvider_ROCM() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_all_h.upcallHandle(
                SessionOptionsAppendExecutionProvider_ROCM.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SessionOptionsAppendExecutionProvider_ROCM.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static SessionOptionsAppendExecutionProvider_ROCM.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout SessionOptionsAppendExecutionProvider_ROCM$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("SessionOptionsAppendExecutionProvider_ROCM"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_ROCM)(OrtSessionOptions *, const OrtROCMProviderOptions *)
     * }
     */
    public static final AddressLayout SessionOptionsAppendExecutionProvider_ROCM$layout() {
        return SessionOptionsAppendExecutionProvider_ROCM$LAYOUT;
    }

    private static final long SessionOptionsAppendExecutionProvider_ROCM$OFFSET = 1224;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_ROCM)(OrtSessionOptions *, const OrtROCMProviderOptions *)
     * }
     */
    public static final long SessionOptionsAppendExecutionProvider_ROCM$offset() {
        return SessionOptionsAppendExecutionProvider_ROCM$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_ROCM)(OrtSessionOptions *, const OrtROCMProviderOptions *)
     * }
     */
    public static MemorySegment SessionOptionsAppendExecutionProvider_ROCM(MemorySegment struct) {
        return struct.get(
                SessionOptionsAppendExecutionProvider_ROCM$LAYOUT, SessionOptionsAppendExecutionProvider_ROCM$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_ROCM)(OrtSessionOptions *, const OrtROCMProviderOptions *)
     * }
     */
    public static void SessionOptionsAppendExecutionProvider_ROCM(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(
                SessionOptionsAppendExecutionProvider_ROCM$LAYOUT,
                SessionOptionsAppendExecutionProvider_ROCM$OFFSET,
                fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_ROCM)(OrtSessionOptions *, const OrtROCMProviderOptions *)
     * }
     */
    public static SessionOptionsAppendExecutionProvider_ROCM.Function
            SessionOptionsAppendExecutionProvider_ROCMFunction(MemorySegment struct) {
        return SessionOptionsAppendExecutionProvider_ROCM.function(SessionOptionsAppendExecutionProvider_ROCM(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_OpenVINO)(OrtSessionOptions *, const OrtOpenVINOProviderOptions *)
     * }
     */
    public static class SessionOptionsAppendExecutionProvider_OpenVINO {

        SessionOptionsAppendExecutionProvider_OpenVINO() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_all_h.upcallHandle(
                SessionOptionsAppendExecutionProvider_OpenVINO.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SessionOptionsAppendExecutionProvider_OpenVINO.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static SessionOptionsAppendExecutionProvider_OpenVINO.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout SessionOptionsAppendExecutionProvider_OpenVINO$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("SessionOptionsAppendExecutionProvider_OpenVINO"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_OpenVINO)(OrtSessionOptions *, const OrtOpenVINOProviderOptions *)
     * }
     */
    public static final AddressLayout SessionOptionsAppendExecutionProvider_OpenVINO$layout() {
        return SessionOptionsAppendExecutionProvider_OpenVINO$LAYOUT;
    }

    private static final long SessionOptionsAppendExecutionProvider_OpenVINO$OFFSET = 1232;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_OpenVINO)(OrtSessionOptions *, const OrtOpenVINOProviderOptions *)
     * }
     */
    public static final long SessionOptionsAppendExecutionProvider_OpenVINO$offset() {
        return SessionOptionsAppendExecutionProvider_OpenVINO$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_OpenVINO)(OrtSessionOptions *, const OrtOpenVINOProviderOptions *)
     * }
     */
    public static MemorySegment SessionOptionsAppendExecutionProvider_OpenVINO(MemorySegment struct) {
        return struct.get(
                SessionOptionsAppendExecutionProvider_OpenVINO$LAYOUT,
                SessionOptionsAppendExecutionProvider_OpenVINO$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_OpenVINO)(OrtSessionOptions *, const OrtOpenVINOProviderOptions *)
     * }
     */
    public static void SessionOptionsAppendExecutionProvider_OpenVINO(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(
                SessionOptionsAppendExecutionProvider_OpenVINO$LAYOUT,
                SessionOptionsAppendExecutionProvider_OpenVINO$OFFSET,
                fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_OpenVINO)(OrtSessionOptions *, const OrtOpenVINOProviderOptions *)
     * }
     */
    public static SessionOptionsAppendExecutionProvider_OpenVINO.Function
            SessionOptionsAppendExecutionProvider_OpenVINOFunction(MemorySegment struct) {
        return SessionOptionsAppendExecutionProvider_OpenVINO.function(
                SessionOptionsAppendExecutionProvider_OpenVINO(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalDenormalAsZero)(OrtThreadingOptions *)
     * }
     */
    public static class SetGlobalDenormalAsZero {

        SetGlobalDenormalAsZero() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC =
                FunctionDescriptor.of(onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(SetGlobalDenormalAsZero.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetGlobalDenormalAsZero.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static SetGlobalDenormalAsZero.Function function(MemorySegment funcPtr) {
            return (_x0) -> invoke(funcPtr, _x0);
        }
    }

    private static final AddressLayout SetGlobalDenormalAsZero$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("SetGlobalDenormalAsZero"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalDenormalAsZero)(OrtThreadingOptions *)
     * }
     */
    public static final AddressLayout SetGlobalDenormalAsZero$layout() {
        return SetGlobalDenormalAsZero$LAYOUT;
    }

    private static final long SetGlobalDenormalAsZero$OFFSET = 1240;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalDenormalAsZero)(OrtThreadingOptions *)
     * }
     */
    public static final long SetGlobalDenormalAsZero$offset() {
        return SetGlobalDenormalAsZero$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalDenormalAsZero)(OrtThreadingOptions *)
     * }
     */
    public static MemorySegment SetGlobalDenormalAsZero(MemorySegment struct) {
        return struct.get(SetGlobalDenormalAsZero$LAYOUT, SetGlobalDenormalAsZero$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalDenormalAsZero)(OrtThreadingOptions *)
     * }
     */
    public static void SetGlobalDenormalAsZero(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetGlobalDenormalAsZero$LAYOUT, SetGlobalDenormalAsZero$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalDenormalAsZero)(OrtThreadingOptions *)
     * }
     */
    public static SetGlobalDenormalAsZero.Function SetGlobalDenormalAsZeroFunction(MemorySegment struct) {
        return SetGlobalDenormalAsZero.function(SetGlobalDenormalAsZero(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateArenaCfg)(size_t, int, int, int, OrtArenaCfg **)
     * }
     */
    public static class CreateArenaCfg {

        CreateArenaCfg() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(long _x0, int _x1, int _x2, int _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_LONG,
                onnxruntime_all_h.C_INT,
                onnxruntime_all_h.C_INT,
                onnxruntime_all_h.C_INT,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(CreateArenaCfg.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateArenaCfg.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr, long _x0, int _x1, int _x2, int _x3, MemorySegment _x4) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static CreateArenaCfg.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2, _x3, _x4) -> invoke(funcPtr, _x0, _x1, _x2, _x3, _x4);
        }
    }

    private static final AddressLayout CreateArenaCfg$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("CreateArenaCfg"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateArenaCfg)(size_t, int, int, int, OrtArenaCfg **)
     * }
     */
    public static final AddressLayout CreateArenaCfg$layout() {
        return CreateArenaCfg$LAYOUT;
    }

    private static final long CreateArenaCfg$OFFSET = 1248;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateArenaCfg)(size_t, int, int, int, OrtArenaCfg **)
     * }
     */
    public static final long CreateArenaCfg$offset() {
        return CreateArenaCfg$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateArenaCfg)(size_t, int, int, int, OrtArenaCfg **)
     * }
     */
    public static MemorySegment CreateArenaCfg(MemorySegment struct) {
        return struct.get(CreateArenaCfg$LAYOUT, CreateArenaCfg$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateArenaCfg)(size_t, int, int, int, OrtArenaCfg **)
     * }
     */
    public static void CreateArenaCfg(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateArenaCfg$LAYOUT, CreateArenaCfg$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateArenaCfg)(size_t, int, int, int, OrtArenaCfg **)
     * }
     */
    public static CreateArenaCfg.Function CreateArenaCfgFunction(MemorySegment struct) {
        return CreateArenaCfg.function(CreateArenaCfg(struct));
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseArenaCfg)(OrtArenaCfg *)
     * }
     */
    public static class ReleaseArenaCfg {

        ReleaseArenaCfg() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(ReleaseArenaCfg.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleaseArenaCfg.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static ReleaseArenaCfg.Function function(MemorySegment funcPtr) {
            return (_x0) -> invoke(funcPtr, _x0);
        }
    }

    private static final AddressLayout ReleaseArenaCfg$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("ReleaseArenaCfg"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ReleaseArenaCfg)(OrtArenaCfg *)
     * }
     */
    public static final AddressLayout ReleaseArenaCfg$layout() {
        return ReleaseArenaCfg$LAYOUT;
    }

    private static final long ReleaseArenaCfg$OFFSET = 1256;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ReleaseArenaCfg)(OrtArenaCfg *)
     * }
     */
    public static final long ReleaseArenaCfg$offset() {
        return ReleaseArenaCfg$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ReleaseArenaCfg)(OrtArenaCfg *)
     * }
     */
    public static MemorySegment ReleaseArenaCfg(MemorySegment struct) {
        return struct.get(ReleaseArenaCfg$LAYOUT, ReleaseArenaCfg$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ReleaseArenaCfg)(OrtArenaCfg *)
     * }
     */
    public static void ReleaseArenaCfg(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleaseArenaCfg$LAYOUT, ReleaseArenaCfg$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * void (*ReleaseArenaCfg)(OrtArenaCfg *)
     * }
     */
    public static ReleaseArenaCfg.Function ReleaseArenaCfgFunction(MemorySegment struct) {
        return ReleaseArenaCfg.function(ReleaseArenaCfg(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetGraphDescription)(const OrtModelMetadata *, OrtAllocator *, char **)
     * }
     */
    public static class ModelMetadataGetGraphDescription {

        ModelMetadataGetGraphDescription() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(ModelMetadataGetGraphDescription.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ModelMetadataGetGraphDescription.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static ModelMetadataGetGraphDescription.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2) -> invoke(funcPtr, _x0, _x1, _x2);
        }
    }

    private static final AddressLayout ModelMetadataGetGraphDescription$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("ModelMetadataGetGraphDescription"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetGraphDescription)(const OrtModelMetadata *, OrtAllocator *, char **)
     * }
     */
    public static final AddressLayout ModelMetadataGetGraphDescription$layout() {
        return ModelMetadataGetGraphDescription$LAYOUT;
    }

    private static final long ModelMetadataGetGraphDescription$OFFSET = 1264;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetGraphDescription)(const OrtModelMetadata *, OrtAllocator *, char **)
     * }
     */
    public static final long ModelMetadataGetGraphDescription$offset() {
        return ModelMetadataGetGraphDescription$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetGraphDescription)(const OrtModelMetadata *, OrtAllocator *, char **)
     * }
     */
    public static MemorySegment ModelMetadataGetGraphDescription(MemorySegment struct) {
        return struct.get(ModelMetadataGetGraphDescription$LAYOUT, ModelMetadataGetGraphDescription$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetGraphDescription)(const OrtModelMetadata *, OrtAllocator *, char **)
     * }
     */
    public static void ModelMetadataGetGraphDescription(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ModelMetadataGetGraphDescription$LAYOUT, ModelMetadataGetGraphDescription$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ModelMetadataGetGraphDescription)(const OrtModelMetadata *, OrtAllocator *, char **)
     * }
     */
    public static ModelMetadataGetGraphDescription.Function ModelMetadataGetGraphDescriptionFunction(
            MemorySegment struct) {
        return ModelMetadataGetGraphDescription.function(ModelMetadataGetGraphDescription(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_TensorRT)(OrtSessionOptions *, const OrtTensorRTProviderOptions *)
     * }
     */
    public static class SessionOptionsAppendExecutionProvider_TensorRT {

        SessionOptionsAppendExecutionProvider_TensorRT() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_all_h.upcallHandle(
                SessionOptionsAppendExecutionProvider_TensorRT.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SessionOptionsAppendExecutionProvider_TensorRT.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static SessionOptionsAppendExecutionProvider_TensorRT.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout SessionOptionsAppendExecutionProvider_TensorRT$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("SessionOptionsAppendExecutionProvider_TensorRT"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_TensorRT)(OrtSessionOptions *, const OrtTensorRTProviderOptions *)
     * }
     */
    public static final AddressLayout SessionOptionsAppendExecutionProvider_TensorRT$layout() {
        return SessionOptionsAppendExecutionProvider_TensorRT$LAYOUT;
    }

    private static final long SessionOptionsAppendExecutionProvider_TensorRT$OFFSET = 1272;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_TensorRT)(OrtSessionOptions *, const OrtTensorRTProviderOptions *)
     * }
     */
    public static final long SessionOptionsAppendExecutionProvider_TensorRT$offset() {
        return SessionOptionsAppendExecutionProvider_TensorRT$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_TensorRT)(OrtSessionOptions *, const OrtTensorRTProviderOptions *)
     * }
     */
    public static MemorySegment SessionOptionsAppendExecutionProvider_TensorRT(MemorySegment struct) {
        return struct.get(
                SessionOptionsAppendExecutionProvider_TensorRT$LAYOUT,
                SessionOptionsAppendExecutionProvider_TensorRT$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_TensorRT)(OrtSessionOptions *, const OrtTensorRTProviderOptions *)
     * }
     */
    public static void SessionOptionsAppendExecutionProvider_TensorRT(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(
                SessionOptionsAppendExecutionProvider_TensorRT$LAYOUT,
                SessionOptionsAppendExecutionProvider_TensorRT$OFFSET,
                fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_TensorRT)(OrtSessionOptions *, const OrtTensorRTProviderOptions *)
     * }
     */
    public static SessionOptionsAppendExecutionProvider_TensorRT.Function
            SessionOptionsAppendExecutionProvider_TensorRTFunction(MemorySegment struct) {
        return SessionOptionsAppendExecutionProvider_TensorRT.function(
                SessionOptionsAppendExecutionProvider_TensorRT(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SetCurrentGpuDeviceId)(int)
     * }
     */
    public static class SetCurrentGpuDeviceId {

        SetCurrentGpuDeviceId() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(int _x0);
        }

        private static final FunctionDescriptor $DESC =
                FunctionDescriptor.of(onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_INT);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(SetCurrentGpuDeviceId.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetCurrentGpuDeviceId.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, int _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static SetCurrentGpuDeviceId.Function function(MemorySegment funcPtr) {
            return (_x0) -> invoke(funcPtr, _x0);
        }
    }

    private static final AddressLayout SetCurrentGpuDeviceId$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("SetCurrentGpuDeviceId"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetCurrentGpuDeviceId)(int)
     * }
     */
    public static final AddressLayout SetCurrentGpuDeviceId$layout() {
        return SetCurrentGpuDeviceId$LAYOUT;
    }

    private static final long SetCurrentGpuDeviceId$OFFSET = 1280;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetCurrentGpuDeviceId)(int)
     * }
     */
    public static final long SetCurrentGpuDeviceId$offset() {
        return SetCurrentGpuDeviceId$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetCurrentGpuDeviceId)(int)
     * }
     */
    public static MemorySegment SetCurrentGpuDeviceId(MemorySegment struct) {
        return struct.get(SetCurrentGpuDeviceId$LAYOUT, SetCurrentGpuDeviceId$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetCurrentGpuDeviceId)(int)
     * }
     */
    public static void SetCurrentGpuDeviceId(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetCurrentGpuDeviceId$LAYOUT, SetCurrentGpuDeviceId$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetCurrentGpuDeviceId)(int)
     * }
     */
    public static SetCurrentGpuDeviceId.Function SetCurrentGpuDeviceIdFunction(MemorySegment struct) {
        return SetCurrentGpuDeviceId.function(SetCurrentGpuDeviceId(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetCurrentGpuDeviceId)(int *)
     * }
     */
    public static class GetCurrentGpuDeviceId {

        GetCurrentGpuDeviceId() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC =
                FunctionDescriptor.of(onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(GetCurrentGpuDeviceId.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetCurrentGpuDeviceId.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static GetCurrentGpuDeviceId.Function function(MemorySegment funcPtr) {
            return (_x0) -> invoke(funcPtr, _x0);
        }
    }

    private static final AddressLayout GetCurrentGpuDeviceId$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("GetCurrentGpuDeviceId"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetCurrentGpuDeviceId)(int *)
     * }
     */
    public static final AddressLayout GetCurrentGpuDeviceId$layout() {
        return GetCurrentGpuDeviceId$LAYOUT;
    }

    private static final long GetCurrentGpuDeviceId$OFFSET = 1288;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetCurrentGpuDeviceId)(int *)
     * }
     */
    public static final long GetCurrentGpuDeviceId$offset() {
        return GetCurrentGpuDeviceId$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetCurrentGpuDeviceId)(int *)
     * }
     */
    public static MemorySegment GetCurrentGpuDeviceId(MemorySegment struct) {
        return struct.get(GetCurrentGpuDeviceId$LAYOUT, GetCurrentGpuDeviceId$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetCurrentGpuDeviceId)(int *)
     * }
     */
    public static void GetCurrentGpuDeviceId(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetCurrentGpuDeviceId$LAYOUT, GetCurrentGpuDeviceId$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetCurrentGpuDeviceId)(int *)
     * }
     */
    public static GetCurrentGpuDeviceId.Function GetCurrentGpuDeviceIdFunction(MemorySegment struct) {
        return GetCurrentGpuDeviceId.function(GetCurrentGpuDeviceId(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAttributeArray_float)(const OrtKernelInfo *, const char *, float *, size_t *)
     * }
     */
    public static class KernelInfoGetAttributeArray_float {

        KernelInfoGetAttributeArray_float() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(KernelInfoGetAttributeArray_float.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(KernelInfoGetAttributeArray_float.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static KernelInfoGetAttributeArray_float.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2, _x3) -> invoke(funcPtr, _x0, _x1, _x2, _x3);
        }
    }

    private static final AddressLayout KernelInfoGetAttributeArray_float$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("KernelInfoGetAttributeArray_float"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAttributeArray_float)(const OrtKernelInfo *, const char *, float *, size_t *)
     * }
     */
    public static final AddressLayout KernelInfoGetAttributeArray_float$layout() {
        return KernelInfoGetAttributeArray_float$LAYOUT;
    }

    private static final long KernelInfoGetAttributeArray_float$OFFSET = 1296;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAttributeArray_float)(const OrtKernelInfo *, const char *, float *, size_t *)
     * }
     */
    public static final long KernelInfoGetAttributeArray_float$offset() {
        return KernelInfoGetAttributeArray_float$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAttributeArray_float)(const OrtKernelInfo *, const char *, float *, size_t *)
     * }
     */
    public static MemorySegment KernelInfoGetAttributeArray_float(MemorySegment struct) {
        return struct.get(KernelInfoGetAttributeArray_float$LAYOUT, KernelInfoGetAttributeArray_float$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAttributeArray_float)(const OrtKernelInfo *, const char *, float *, size_t *)
     * }
     */
    public static void KernelInfoGetAttributeArray_float(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(KernelInfoGetAttributeArray_float$LAYOUT, KernelInfoGetAttributeArray_float$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAttributeArray_float)(const OrtKernelInfo *, const char *, float *, size_t *)
     * }
     */
    public static KernelInfoGetAttributeArray_float.Function KernelInfoGetAttributeArray_floatFunction(
            MemorySegment struct) {
        return KernelInfoGetAttributeArray_float.function(KernelInfoGetAttributeArray_float(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAttributeArray_int64)(const OrtKernelInfo *, const char *, int64_t *, size_t *)
     * }
     */
    public static class KernelInfoGetAttributeArray_int64 {

        KernelInfoGetAttributeArray_int64() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(KernelInfoGetAttributeArray_int64.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(KernelInfoGetAttributeArray_int64.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static KernelInfoGetAttributeArray_int64.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2, _x3) -> invoke(funcPtr, _x0, _x1, _x2, _x3);
        }
    }

    private static final AddressLayout KernelInfoGetAttributeArray_int64$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("KernelInfoGetAttributeArray_int64"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAttributeArray_int64)(const OrtKernelInfo *, const char *, int64_t *, size_t *)
     * }
     */
    public static final AddressLayout KernelInfoGetAttributeArray_int64$layout() {
        return KernelInfoGetAttributeArray_int64$LAYOUT;
    }

    private static final long KernelInfoGetAttributeArray_int64$OFFSET = 1304;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAttributeArray_int64)(const OrtKernelInfo *, const char *, int64_t *, size_t *)
     * }
     */
    public static final long KernelInfoGetAttributeArray_int64$offset() {
        return KernelInfoGetAttributeArray_int64$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAttributeArray_int64)(const OrtKernelInfo *, const char *, int64_t *, size_t *)
     * }
     */
    public static MemorySegment KernelInfoGetAttributeArray_int64(MemorySegment struct) {
        return struct.get(KernelInfoGetAttributeArray_int64$LAYOUT, KernelInfoGetAttributeArray_int64$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAttributeArray_int64)(const OrtKernelInfo *, const char *, int64_t *, size_t *)
     * }
     */
    public static void KernelInfoGetAttributeArray_int64(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(KernelInfoGetAttributeArray_int64$LAYOUT, KernelInfoGetAttributeArray_int64$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAttributeArray_int64)(const OrtKernelInfo *, const char *, int64_t *, size_t *)
     * }
     */
    public static KernelInfoGetAttributeArray_int64.Function KernelInfoGetAttributeArray_int64Function(
            MemorySegment struct) {
        return KernelInfoGetAttributeArray_int64.function(KernelInfoGetAttributeArray_int64(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateArenaCfgV2)(const char *const *, const size_t *, size_t, OrtArenaCfg **)
     * }
     */
    public static class CreateArenaCfgV2 {

        CreateArenaCfgV2() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_LONG,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(CreateArenaCfgV2.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateArenaCfgV2.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static CreateArenaCfgV2.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2, _x3) -> invoke(funcPtr, _x0, _x1, _x2, _x3);
        }
    }

    private static final AddressLayout CreateArenaCfgV2$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("CreateArenaCfgV2"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateArenaCfgV2)(const char *const *, const size_t *, size_t, OrtArenaCfg **)
     * }
     */
    public static final AddressLayout CreateArenaCfgV2$layout() {
        return CreateArenaCfgV2$LAYOUT;
    }

    private static final long CreateArenaCfgV2$OFFSET = 1312;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateArenaCfgV2)(const char *const *, const size_t *, size_t, OrtArenaCfg **)
     * }
     */
    public static final long CreateArenaCfgV2$offset() {
        return CreateArenaCfgV2$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateArenaCfgV2)(const char *const *, const size_t *, size_t, OrtArenaCfg **)
     * }
     */
    public static MemorySegment CreateArenaCfgV2(MemorySegment struct) {
        return struct.get(CreateArenaCfgV2$LAYOUT, CreateArenaCfgV2$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateArenaCfgV2)(const char *const *, const size_t *, size_t, OrtArenaCfg **)
     * }
     */
    public static void CreateArenaCfgV2(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateArenaCfgV2$LAYOUT, CreateArenaCfgV2$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateArenaCfgV2)(const char *const *, const size_t *, size_t, OrtArenaCfg **)
     * }
     */
    public static CreateArenaCfgV2.Function CreateArenaCfgV2Function(MemorySegment struct) {
        return CreateArenaCfgV2.function(CreateArenaCfgV2(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*AddRunConfigEntry)(OrtRunOptions *, const char *, const char *)
     * }
     */
    public static class AddRunConfigEntry {

        AddRunConfigEntry() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(AddRunConfigEntry.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(AddRunConfigEntry.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static AddRunConfigEntry.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2) -> invoke(funcPtr, _x0, _x1, _x2);
        }
    }

    private static final AddressLayout AddRunConfigEntry$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("AddRunConfigEntry"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddRunConfigEntry)(OrtRunOptions *, const char *, const char *)
     * }
     */
    public static final AddressLayout AddRunConfigEntry$layout() {
        return AddRunConfigEntry$LAYOUT;
    }

    private static final long AddRunConfigEntry$OFFSET = 1320;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddRunConfigEntry)(OrtRunOptions *, const char *, const char *)
     * }
     */
    public static final long AddRunConfigEntry$offset() {
        return AddRunConfigEntry$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddRunConfigEntry)(OrtRunOptions *, const char *, const char *)
     * }
     */
    public static MemorySegment AddRunConfigEntry(MemorySegment struct) {
        return struct.get(AddRunConfigEntry$LAYOUT, AddRunConfigEntry$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddRunConfigEntry)(OrtRunOptions *, const char *, const char *)
     * }
     */
    public static void AddRunConfigEntry(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(AddRunConfigEntry$LAYOUT, AddRunConfigEntry$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddRunConfigEntry)(OrtRunOptions *, const char *, const char *)
     * }
     */
    public static AddRunConfigEntry.Function AddRunConfigEntryFunction(MemorySegment struct) {
        return AddRunConfigEntry.function(AddRunConfigEntry(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreatePrepackedWeightsContainer)(OrtPrepackedWeightsContainer **)
     * }
     */
    public static class CreatePrepackedWeightsContainer {

        CreatePrepackedWeightsContainer() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC =
                FunctionDescriptor.of(onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(CreatePrepackedWeightsContainer.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreatePrepackedWeightsContainer.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static CreatePrepackedWeightsContainer.Function function(MemorySegment funcPtr) {
            return (_x0) -> invoke(funcPtr, _x0);
        }
    }

    private static final AddressLayout CreatePrepackedWeightsContainer$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("CreatePrepackedWeightsContainer"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreatePrepackedWeightsContainer)(OrtPrepackedWeightsContainer **)
     * }
     */
    public static final AddressLayout CreatePrepackedWeightsContainer$layout() {
        return CreatePrepackedWeightsContainer$LAYOUT;
    }

    private static final long CreatePrepackedWeightsContainer$OFFSET = 1328;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreatePrepackedWeightsContainer)(OrtPrepackedWeightsContainer **)
     * }
     */
    public static final long CreatePrepackedWeightsContainer$offset() {
        return CreatePrepackedWeightsContainer$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreatePrepackedWeightsContainer)(OrtPrepackedWeightsContainer **)
     * }
     */
    public static MemorySegment CreatePrepackedWeightsContainer(MemorySegment struct) {
        return struct.get(CreatePrepackedWeightsContainer$LAYOUT, CreatePrepackedWeightsContainer$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreatePrepackedWeightsContainer)(OrtPrepackedWeightsContainer **)
     * }
     */
    public static void CreatePrepackedWeightsContainer(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreatePrepackedWeightsContainer$LAYOUT, CreatePrepackedWeightsContainer$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreatePrepackedWeightsContainer)(OrtPrepackedWeightsContainer **)
     * }
     */
    public static CreatePrepackedWeightsContainer.Function CreatePrepackedWeightsContainerFunction(
            MemorySegment struct) {
        return CreatePrepackedWeightsContainer.function(CreatePrepackedWeightsContainer(struct));
    }

    /**
     * {@snippet lang=c :
     * void (*ReleasePrepackedWeightsContainer)(OrtPrepackedWeightsContainer *)
     * }
     */
    public static class ReleasePrepackedWeightsContainer {

        ReleasePrepackedWeightsContainer() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(ReleasePrepackedWeightsContainer.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleasePrepackedWeightsContainer.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static ReleasePrepackedWeightsContainer.Function function(MemorySegment funcPtr) {
            return (_x0) -> invoke(funcPtr, _x0);
        }
    }

    private static final AddressLayout ReleasePrepackedWeightsContainer$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("ReleasePrepackedWeightsContainer"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ReleasePrepackedWeightsContainer)(OrtPrepackedWeightsContainer *)
     * }
     */
    public static final AddressLayout ReleasePrepackedWeightsContainer$layout() {
        return ReleasePrepackedWeightsContainer$LAYOUT;
    }

    private static final long ReleasePrepackedWeightsContainer$OFFSET = 1336;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ReleasePrepackedWeightsContainer)(OrtPrepackedWeightsContainer *)
     * }
     */
    public static final long ReleasePrepackedWeightsContainer$offset() {
        return ReleasePrepackedWeightsContainer$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ReleasePrepackedWeightsContainer)(OrtPrepackedWeightsContainer *)
     * }
     */
    public static MemorySegment ReleasePrepackedWeightsContainer(MemorySegment struct) {
        return struct.get(ReleasePrepackedWeightsContainer$LAYOUT, ReleasePrepackedWeightsContainer$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ReleasePrepackedWeightsContainer)(OrtPrepackedWeightsContainer *)
     * }
     */
    public static void ReleasePrepackedWeightsContainer(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleasePrepackedWeightsContainer$LAYOUT, ReleasePrepackedWeightsContainer$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * void (*ReleasePrepackedWeightsContainer)(OrtPrepackedWeightsContainer *)
     * }
     */
    public static ReleasePrepackedWeightsContainer.Function ReleasePrepackedWeightsContainerFunction(
            MemorySegment struct) {
        return ReleasePrepackedWeightsContainer.function(ReleasePrepackedWeightsContainer(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSessionWithPrepackedWeightsContainer)(const OrtEnv *, const char *, const OrtSessionOptions *, OrtPrepackedWeightsContainer *, OrtSession **)
     * }
     */
    public static class CreateSessionWithPrepackedWeightsContainer {

        CreateSessionWithPrepackedWeightsContainer() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(
                    MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_all_h.upcallHandle(
                CreateSessionWithPrepackedWeightsContainer.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateSessionWithPrepackedWeightsContainer.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr,
                MemorySegment _x0,
                MemorySegment _x1,
                MemorySegment _x2,
                MemorySegment _x3,
                MemorySegment _x4) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static CreateSessionWithPrepackedWeightsContainer.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2, _x3, _x4) -> invoke(funcPtr, _x0, _x1, _x2, _x3, _x4);
        }
    }

    private static final AddressLayout CreateSessionWithPrepackedWeightsContainer$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("CreateSessionWithPrepackedWeightsContainer"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSessionWithPrepackedWeightsContainer)(const OrtEnv *, const char *, const OrtSessionOptions *, OrtPrepackedWeightsContainer *, OrtSession **)
     * }
     */
    public static final AddressLayout CreateSessionWithPrepackedWeightsContainer$layout() {
        return CreateSessionWithPrepackedWeightsContainer$LAYOUT;
    }

    private static final long CreateSessionWithPrepackedWeightsContainer$OFFSET = 1344;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSessionWithPrepackedWeightsContainer)(const OrtEnv *, const char *, const OrtSessionOptions *, OrtPrepackedWeightsContainer *, OrtSession **)
     * }
     */
    public static final long CreateSessionWithPrepackedWeightsContainer$offset() {
        return CreateSessionWithPrepackedWeightsContainer$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSessionWithPrepackedWeightsContainer)(const OrtEnv *, const char *, const OrtSessionOptions *, OrtPrepackedWeightsContainer *, OrtSession **)
     * }
     */
    public static MemorySegment CreateSessionWithPrepackedWeightsContainer(MemorySegment struct) {
        return struct.get(
                CreateSessionWithPrepackedWeightsContainer$LAYOUT, CreateSessionWithPrepackedWeightsContainer$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSessionWithPrepackedWeightsContainer)(const OrtEnv *, const char *, const OrtSessionOptions *, OrtPrepackedWeightsContainer *, OrtSession **)
     * }
     */
    public static void CreateSessionWithPrepackedWeightsContainer(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(
                CreateSessionWithPrepackedWeightsContainer$LAYOUT,
                CreateSessionWithPrepackedWeightsContainer$OFFSET,
                fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSessionWithPrepackedWeightsContainer)(const OrtEnv *, const char *, const OrtSessionOptions *, OrtPrepackedWeightsContainer *, OrtSession **)
     * }
     */
    public static CreateSessionWithPrepackedWeightsContainer.Function
            CreateSessionWithPrepackedWeightsContainerFunction(MemorySegment struct) {
        return CreateSessionWithPrepackedWeightsContainer.function(CreateSessionWithPrepackedWeightsContainer(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSessionFromArrayWithPrepackedWeightsContainer)(const OrtEnv *, const void *, size_t, const OrtSessionOptions *, OrtPrepackedWeightsContainer *, OrtSession **)
     * }
     */
    public static class CreateSessionFromArrayWithPrepackedWeightsContainer {

        CreateSessionFromArrayWithPrepackedWeightsContainer() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(
                    MemorySegment _x0,
                    MemorySegment _x1,
                    long _x2,
                    MemorySegment _x3,
                    MemorySegment _x4,
                    MemorySegment _x5);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_LONG,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_all_h.upcallHandle(
                CreateSessionFromArrayWithPrepackedWeightsContainer.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(
                CreateSessionFromArrayWithPrepackedWeightsContainer.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr,
                MemorySegment _x0,
                MemorySegment _x1,
                long _x2,
                MemorySegment _x3,
                MemorySegment _x4,
                MemorySegment _x5) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static CreateSessionFromArrayWithPrepackedWeightsContainer.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2, _x3, _x4, _x5) -> invoke(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);
        }
    }

    private static final AddressLayout CreateSessionFromArrayWithPrepackedWeightsContainer$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("CreateSessionFromArrayWithPrepackedWeightsContainer"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSessionFromArrayWithPrepackedWeightsContainer)(const OrtEnv *, const void *, size_t, const OrtSessionOptions *, OrtPrepackedWeightsContainer *, OrtSession **)
     * }
     */
    public static final AddressLayout CreateSessionFromArrayWithPrepackedWeightsContainer$layout() {
        return CreateSessionFromArrayWithPrepackedWeightsContainer$LAYOUT;
    }

    private static final long CreateSessionFromArrayWithPrepackedWeightsContainer$OFFSET = 1352;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSessionFromArrayWithPrepackedWeightsContainer)(const OrtEnv *, const void *, size_t, const OrtSessionOptions *, OrtPrepackedWeightsContainer *, OrtSession **)
     * }
     */
    public static final long CreateSessionFromArrayWithPrepackedWeightsContainer$offset() {
        return CreateSessionFromArrayWithPrepackedWeightsContainer$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSessionFromArrayWithPrepackedWeightsContainer)(const OrtEnv *, const void *, size_t, const OrtSessionOptions *, OrtPrepackedWeightsContainer *, OrtSession **)
     * }
     */
    public static MemorySegment CreateSessionFromArrayWithPrepackedWeightsContainer(MemorySegment struct) {
        return struct.get(
                CreateSessionFromArrayWithPrepackedWeightsContainer$LAYOUT,
                CreateSessionFromArrayWithPrepackedWeightsContainer$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSessionFromArrayWithPrepackedWeightsContainer)(const OrtEnv *, const void *, size_t, const OrtSessionOptions *, OrtPrepackedWeightsContainer *, OrtSession **)
     * }
     */
    public static void CreateSessionFromArrayWithPrepackedWeightsContainer(
            MemorySegment struct, MemorySegment fieldValue) {
        struct.set(
                CreateSessionFromArrayWithPrepackedWeightsContainer$LAYOUT,
                CreateSessionFromArrayWithPrepackedWeightsContainer$OFFSET,
                fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSessionFromArrayWithPrepackedWeightsContainer)(const OrtEnv *, const void *, size_t, const OrtSessionOptions *, OrtPrepackedWeightsContainer *, OrtSession **)
     * }
     */
    public static CreateSessionFromArrayWithPrepackedWeightsContainer.Function
            CreateSessionFromArrayWithPrepackedWeightsContainerFunction(MemorySegment struct) {
        return CreateSessionFromArrayWithPrepackedWeightsContainer.function(
                CreateSessionFromArrayWithPrepackedWeightsContainer(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_TensorRT_V2)(OrtSessionOptions *, const OrtTensorRTProviderOptionsV2 *)
     * }
     */
    public static class SessionOptionsAppendExecutionProvider_TensorRT_V2 {

        SessionOptionsAppendExecutionProvider_TensorRT_V2() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_all_h.upcallHandle(
                SessionOptionsAppendExecutionProvider_TensorRT_V2.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(
                SessionOptionsAppendExecutionProvider_TensorRT_V2.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static SessionOptionsAppendExecutionProvider_TensorRT_V2.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout SessionOptionsAppendExecutionProvider_TensorRT_V2$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("SessionOptionsAppendExecutionProvider_TensorRT_V2"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_TensorRT_V2)(OrtSessionOptions *, const OrtTensorRTProviderOptionsV2 *)
     * }
     */
    public static final AddressLayout SessionOptionsAppendExecutionProvider_TensorRT_V2$layout() {
        return SessionOptionsAppendExecutionProvider_TensorRT_V2$LAYOUT;
    }

    private static final long SessionOptionsAppendExecutionProvider_TensorRT_V2$OFFSET = 1360;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_TensorRT_V2)(OrtSessionOptions *, const OrtTensorRTProviderOptionsV2 *)
     * }
     */
    public static final long SessionOptionsAppendExecutionProvider_TensorRT_V2$offset() {
        return SessionOptionsAppendExecutionProvider_TensorRT_V2$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_TensorRT_V2)(OrtSessionOptions *, const OrtTensorRTProviderOptionsV2 *)
     * }
     */
    public static MemorySegment SessionOptionsAppendExecutionProvider_TensorRT_V2(MemorySegment struct) {
        return struct.get(
                SessionOptionsAppendExecutionProvider_TensorRT_V2$LAYOUT,
                SessionOptionsAppendExecutionProvider_TensorRT_V2$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_TensorRT_V2)(OrtSessionOptions *, const OrtTensorRTProviderOptionsV2 *)
     * }
     */
    public static void SessionOptionsAppendExecutionProvider_TensorRT_V2(
            MemorySegment struct, MemorySegment fieldValue) {
        struct.set(
                SessionOptionsAppendExecutionProvider_TensorRT_V2$LAYOUT,
                SessionOptionsAppendExecutionProvider_TensorRT_V2$OFFSET,
                fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_TensorRT_V2)(OrtSessionOptions *, const OrtTensorRTProviderOptionsV2 *)
     * }
     */
    public static SessionOptionsAppendExecutionProvider_TensorRT_V2.Function
            SessionOptionsAppendExecutionProvider_TensorRT_V2Function(MemorySegment struct) {
        return SessionOptionsAppendExecutionProvider_TensorRT_V2.function(
                SessionOptionsAppendExecutionProvider_TensorRT_V2(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateTensorRTProviderOptions)(OrtTensorRTProviderOptionsV2 **)
     * }
     */
    public static class CreateTensorRTProviderOptions {

        CreateTensorRTProviderOptions() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC =
                FunctionDescriptor.of(onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(CreateTensorRTProviderOptions.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateTensorRTProviderOptions.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static CreateTensorRTProviderOptions.Function function(MemorySegment funcPtr) {
            return (_x0) -> invoke(funcPtr, _x0);
        }
    }

    private static final AddressLayout CreateTensorRTProviderOptions$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("CreateTensorRTProviderOptions"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateTensorRTProviderOptions)(OrtTensorRTProviderOptionsV2 **)
     * }
     */
    public static final AddressLayout CreateTensorRTProviderOptions$layout() {
        return CreateTensorRTProviderOptions$LAYOUT;
    }

    private static final long CreateTensorRTProviderOptions$OFFSET = 1368;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateTensorRTProviderOptions)(OrtTensorRTProviderOptionsV2 **)
     * }
     */
    public static final long CreateTensorRTProviderOptions$offset() {
        return CreateTensorRTProviderOptions$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateTensorRTProviderOptions)(OrtTensorRTProviderOptionsV2 **)
     * }
     */
    public static MemorySegment CreateTensorRTProviderOptions(MemorySegment struct) {
        return struct.get(CreateTensorRTProviderOptions$LAYOUT, CreateTensorRTProviderOptions$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateTensorRTProviderOptions)(OrtTensorRTProviderOptionsV2 **)
     * }
     */
    public static void CreateTensorRTProviderOptions(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateTensorRTProviderOptions$LAYOUT, CreateTensorRTProviderOptions$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateTensorRTProviderOptions)(OrtTensorRTProviderOptionsV2 **)
     * }
     */
    public static CreateTensorRTProviderOptions.Function CreateTensorRTProviderOptionsFunction(MemorySegment struct) {
        return CreateTensorRTProviderOptions.function(CreateTensorRTProviderOptions(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateTensorRTProviderOptions)(OrtTensorRTProviderOptionsV2 *, const char *const *, const char *const *, size_t)
     * }
     */
    public static class UpdateTensorRTProviderOptions {

        UpdateTensorRTProviderOptions() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_LONG);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(UpdateTensorRTProviderOptions.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(UpdateTensorRTProviderOptions.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static UpdateTensorRTProviderOptions.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2, _x3) -> invoke(funcPtr, _x0, _x1, _x2, _x3);
        }
    }

    private static final AddressLayout UpdateTensorRTProviderOptions$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("UpdateTensorRTProviderOptions"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateTensorRTProviderOptions)(OrtTensorRTProviderOptionsV2 *, const char *const *, const char *const *, size_t)
     * }
     */
    public static final AddressLayout UpdateTensorRTProviderOptions$layout() {
        return UpdateTensorRTProviderOptions$LAYOUT;
    }

    private static final long UpdateTensorRTProviderOptions$OFFSET = 1376;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateTensorRTProviderOptions)(OrtTensorRTProviderOptionsV2 *, const char *const *, const char *const *, size_t)
     * }
     */
    public static final long UpdateTensorRTProviderOptions$offset() {
        return UpdateTensorRTProviderOptions$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateTensorRTProviderOptions)(OrtTensorRTProviderOptionsV2 *, const char *const *, const char *const *, size_t)
     * }
     */
    public static MemorySegment UpdateTensorRTProviderOptions(MemorySegment struct) {
        return struct.get(UpdateTensorRTProviderOptions$LAYOUT, UpdateTensorRTProviderOptions$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateTensorRTProviderOptions)(OrtTensorRTProviderOptionsV2 *, const char *const *, const char *const *, size_t)
     * }
     */
    public static void UpdateTensorRTProviderOptions(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(UpdateTensorRTProviderOptions$LAYOUT, UpdateTensorRTProviderOptions$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateTensorRTProviderOptions)(OrtTensorRTProviderOptionsV2 *, const char *const *, const char *const *, size_t)
     * }
     */
    public static UpdateTensorRTProviderOptions.Function UpdateTensorRTProviderOptionsFunction(MemorySegment struct) {
        return UpdateTensorRTProviderOptions.function(UpdateTensorRTProviderOptions(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorRTProviderOptionsAsString)(const OrtTensorRTProviderOptionsV2 *, OrtAllocator *, char **)
     * }
     */
    public static class GetTensorRTProviderOptionsAsString {

        GetTensorRTProviderOptionsAsString() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(GetTensorRTProviderOptionsAsString.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetTensorRTProviderOptionsAsString.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static GetTensorRTProviderOptionsAsString.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2) -> invoke(funcPtr, _x0, _x1, _x2);
        }
    }

    private static final AddressLayout GetTensorRTProviderOptionsAsString$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("GetTensorRTProviderOptionsAsString"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorRTProviderOptionsAsString)(const OrtTensorRTProviderOptionsV2 *, OrtAllocator *, char **)
     * }
     */
    public static final AddressLayout GetTensorRTProviderOptionsAsString$layout() {
        return GetTensorRTProviderOptionsAsString$LAYOUT;
    }

    private static final long GetTensorRTProviderOptionsAsString$OFFSET = 1384;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorRTProviderOptionsAsString)(const OrtTensorRTProviderOptionsV2 *, OrtAllocator *, char **)
     * }
     */
    public static final long GetTensorRTProviderOptionsAsString$offset() {
        return GetTensorRTProviderOptionsAsString$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorRTProviderOptionsAsString)(const OrtTensorRTProviderOptionsV2 *, OrtAllocator *, char **)
     * }
     */
    public static MemorySegment GetTensorRTProviderOptionsAsString(MemorySegment struct) {
        return struct.get(GetTensorRTProviderOptionsAsString$LAYOUT, GetTensorRTProviderOptionsAsString$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorRTProviderOptionsAsString)(const OrtTensorRTProviderOptionsV2 *, OrtAllocator *, char **)
     * }
     */
    public static void GetTensorRTProviderOptionsAsString(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetTensorRTProviderOptionsAsString$LAYOUT, GetTensorRTProviderOptionsAsString$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorRTProviderOptionsAsString)(const OrtTensorRTProviderOptionsV2 *, OrtAllocator *, char **)
     * }
     */
    public static GetTensorRTProviderOptionsAsString.Function GetTensorRTProviderOptionsAsStringFunction(
            MemorySegment struct) {
        return GetTensorRTProviderOptionsAsString.function(GetTensorRTProviderOptionsAsString(struct));
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseTensorRTProviderOptions)(OrtTensorRTProviderOptionsV2 *)
     * }
     */
    public static class ReleaseTensorRTProviderOptions {

        ReleaseTensorRTProviderOptions() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(ReleaseTensorRTProviderOptions.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleaseTensorRTProviderOptions.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static ReleaseTensorRTProviderOptions.Function function(MemorySegment funcPtr) {
            return (_x0) -> invoke(funcPtr, _x0);
        }
    }

    private static final AddressLayout ReleaseTensorRTProviderOptions$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("ReleaseTensorRTProviderOptions"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ReleaseTensorRTProviderOptions)(OrtTensorRTProviderOptionsV2 *)
     * }
     */
    public static final AddressLayout ReleaseTensorRTProviderOptions$layout() {
        return ReleaseTensorRTProviderOptions$LAYOUT;
    }

    private static final long ReleaseTensorRTProviderOptions$OFFSET = 1392;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ReleaseTensorRTProviderOptions)(OrtTensorRTProviderOptionsV2 *)
     * }
     */
    public static final long ReleaseTensorRTProviderOptions$offset() {
        return ReleaseTensorRTProviderOptions$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ReleaseTensorRTProviderOptions)(OrtTensorRTProviderOptionsV2 *)
     * }
     */
    public static MemorySegment ReleaseTensorRTProviderOptions(MemorySegment struct) {
        return struct.get(ReleaseTensorRTProviderOptions$LAYOUT, ReleaseTensorRTProviderOptions$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ReleaseTensorRTProviderOptions)(OrtTensorRTProviderOptionsV2 *)
     * }
     */
    public static void ReleaseTensorRTProviderOptions(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleaseTensorRTProviderOptions$LAYOUT, ReleaseTensorRTProviderOptions$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * void (*ReleaseTensorRTProviderOptions)(OrtTensorRTProviderOptionsV2 *)
     * }
     */
    public static ReleaseTensorRTProviderOptions.Function ReleaseTensorRTProviderOptionsFunction(MemorySegment struct) {
        return ReleaseTensorRTProviderOptions.function(ReleaseTensorRTProviderOptions(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*EnableOrtCustomOps)(OrtSessionOptions *)
     * }
     */
    public static class EnableOrtCustomOps {

        EnableOrtCustomOps() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC =
                FunctionDescriptor.of(onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(EnableOrtCustomOps.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(EnableOrtCustomOps.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static EnableOrtCustomOps.Function function(MemorySegment funcPtr) {
            return (_x0) -> invoke(funcPtr, _x0);
        }
    }

    private static final AddressLayout EnableOrtCustomOps$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("EnableOrtCustomOps"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*EnableOrtCustomOps)(OrtSessionOptions *)
     * }
     */
    public static final AddressLayout EnableOrtCustomOps$layout() {
        return EnableOrtCustomOps$LAYOUT;
    }

    private static final long EnableOrtCustomOps$OFFSET = 1400;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*EnableOrtCustomOps)(OrtSessionOptions *)
     * }
     */
    public static final long EnableOrtCustomOps$offset() {
        return EnableOrtCustomOps$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*EnableOrtCustomOps)(OrtSessionOptions *)
     * }
     */
    public static MemorySegment EnableOrtCustomOps(MemorySegment struct) {
        return struct.get(EnableOrtCustomOps$LAYOUT, EnableOrtCustomOps$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*EnableOrtCustomOps)(OrtSessionOptions *)
     * }
     */
    public static void EnableOrtCustomOps(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(EnableOrtCustomOps$LAYOUT, EnableOrtCustomOps$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*EnableOrtCustomOps)(OrtSessionOptions *)
     * }
     */
    public static EnableOrtCustomOps.Function EnableOrtCustomOpsFunction(MemorySegment struct) {
        return EnableOrtCustomOps.function(EnableOrtCustomOps(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*RegisterAllocator)(OrtEnv *, OrtAllocator *)
     * }
     */
    public static class RegisterAllocator {

        RegisterAllocator() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(RegisterAllocator.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(RegisterAllocator.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static RegisterAllocator.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout RegisterAllocator$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("RegisterAllocator"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RegisterAllocator)(OrtEnv *, OrtAllocator *)
     * }
     */
    public static final AddressLayout RegisterAllocator$layout() {
        return RegisterAllocator$LAYOUT;
    }

    private static final long RegisterAllocator$OFFSET = 1408;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RegisterAllocator)(OrtEnv *, OrtAllocator *)
     * }
     */
    public static final long RegisterAllocator$offset() {
        return RegisterAllocator$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RegisterAllocator)(OrtEnv *, OrtAllocator *)
     * }
     */
    public static MemorySegment RegisterAllocator(MemorySegment struct) {
        return struct.get(RegisterAllocator$LAYOUT, RegisterAllocator$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RegisterAllocator)(OrtEnv *, OrtAllocator *)
     * }
     */
    public static void RegisterAllocator(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(RegisterAllocator$LAYOUT, RegisterAllocator$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RegisterAllocator)(OrtEnv *, OrtAllocator *)
     * }
     */
    public static RegisterAllocator.Function RegisterAllocatorFunction(MemorySegment struct) {
        return RegisterAllocator.function(RegisterAllocator(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*UnregisterAllocator)(OrtEnv *, const OrtMemoryInfo *)
     * }
     */
    public static class UnregisterAllocator {

        UnregisterAllocator() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(UnregisterAllocator.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(UnregisterAllocator.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static UnregisterAllocator.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout UnregisterAllocator$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("UnregisterAllocator"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UnregisterAllocator)(OrtEnv *, const OrtMemoryInfo *)
     * }
     */
    public static final AddressLayout UnregisterAllocator$layout() {
        return UnregisterAllocator$LAYOUT;
    }

    private static final long UnregisterAllocator$OFFSET = 1416;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UnregisterAllocator)(OrtEnv *, const OrtMemoryInfo *)
     * }
     */
    public static final long UnregisterAllocator$offset() {
        return UnregisterAllocator$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UnregisterAllocator)(OrtEnv *, const OrtMemoryInfo *)
     * }
     */
    public static MemorySegment UnregisterAllocator(MemorySegment struct) {
        return struct.get(UnregisterAllocator$LAYOUT, UnregisterAllocator$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UnregisterAllocator)(OrtEnv *, const OrtMemoryInfo *)
     * }
     */
    public static void UnregisterAllocator(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(UnregisterAllocator$LAYOUT, UnregisterAllocator$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UnregisterAllocator)(OrtEnv *, const OrtMemoryInfo *)
     * }
     */
    public static UnregisterAllocator.Function UnregisterAllocatorFunction(MemorySegment struct) {
        return UnregisterAllocator.function(UnregisterAllocator(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*IsSparseTensor)(const OrtValue *, int *)
     * }
     */
    public static class IsSparseTensor {

        IsSparseTensor() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(IsSparseTensor.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(IsSparseTensor.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static IsSparseTensor.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout IsSparseTensor$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("IsSparseTensor"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*IsSparseTensor)(const OrtValue *, int *)
     * }
     */
    public static final AddressLayout IsSparseTensor$layout() {
        return IsSparseTensor$LAYOUT;
    }

    private static final long IsSparseTensor$OFFSET = 1424;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*IsSparseTensor)(const OrtValue *, int *)
     * }
     */
    public static final long IsSparseTensor$offset() {
        return IsSparseTensor$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*IsSparseTensor)(const OrtValue *, int *)
     * }
     */
    public static MemorySegment IsSparseTensor(MemorySegment struct) {
        return struct.get(IsSparseTensor$LAYOUT, IsSparseTensor$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*IsSparseTensor)(const OrtValue *, int *)
     * }
     */
    public static void IsSparseTensor(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(IsSparseTensor$LAYOUT, IsSparseTensor$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*IsSparseTensor)(const OrtValue *, int *)
     * }
     */
    public static IsSparseTensor.Function IsSparseTensorFunction(MemorySegment struct) {
        return IsSparseTensor.function(IsSparseTensor(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSparseTensorAsOrtValue)(OrtAllocator *, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)
     * }
     */
    public static class CreateSparseTensorAsOrtValue {

        CreateSparseTensorAsOrtValue() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2, int _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_LONG,
                onnxruntime_all_h.C_INT,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(CreateSparseTensorAsOrtValue.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateSparseTensorAsOrtValue.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, long _x2, int _x3, MemorySegment _x4) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static CreateSparseTensorAsOrtValue.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2, _x3, _x4) -> invoke(funcPtr, _x0, _x1, _x2, _x3, _x4);
        }
    }

    private static final AddressLayout CreateSparseTensorAsOrtValue$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("CreateSparseTensorAsOrtValue"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSparseTensorAsOrtValue)(OrtAllocator *, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)
     * }
     */
    public static final AddressLayout CreateSparseTensorAsOrtValue$layout() {
        return CreateSparseTensorAsOrtValue$LAYOUT;
    }

    private static final long CreateSparseTensorAsOrtValue$OFFSET = 1432;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSparseTensorAsOrtValue)(OrtAllocator *, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)
     * }
     */
    public static final long CreateSparseTensorAsOrtValue$offset() {
        return CreateSparseTensorAsOrtValue$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSparseTensorAsOrtValue)(OrtAllocator *, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)
     * }
     */
    public static MemorySegment CreateSparseTensorAsOrtValue(MemorySegment struct) {
        return struct.get(CreateSparseTensorAsOrtValue$LAYOUT, CreateSparseTensorAsOrtValue$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSparseTensorAsOrtValue)(OrtAllocator *, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)
     * }
     */
    public static void CreateSparseTensorAsOrtValue(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateSparseTensorAsOrtValue$LAYOUT, CreateSparseTensorAsOrtValue$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSparseTensorAsOrtValue)(OrtAllocator *, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)
     * }
     */
    public static CreateSparseTensorAsOrtValue.Function CreateSparseTensorAsOrtValueFunction(MemorySegment struct) {
        return CreateSparseTensorAsOrtValue.function(CreateSparseTensorAsOrtValue(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*FillSparseTensorCoo)(OrtValue *, const OrtMemoryInfo *, const int64_t *, size_t, const void *, const int64_t *, size_t)
     * }
     */
    public static class FillSparseTensorCoo {

        FillSparseTensorCoo() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(
                    MemorySegment _x0,
                    MemorySegment _x1,
                    MemorySegment _x2,
                    long _x3,
                    MemorySegment _x4,
                    MemorySegment _x5,
                    long _x6);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_LONG,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_LONG);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(FillSparseTensorCoo.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(FillSparseTensorCoo.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr,
                MemorySegment _x0,
                MemorySegment _x1,
                MemorySegment _x2,
                long _x3,
                MemorySegment _x4,
                MemorySegment _x5,
                long _x6) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static FillSparseTensorCoo.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2, _x3, _x4, _x5, _x6) -> invoke(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6);
        }
    }

    private static final AddressLayout FillSparseTensorCoo$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("FillSparseTensorCoo"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*FillSparseTensorCoo)(OrtValue *, const OrtMemoryInfo *, const int64_t *, size_t, const void *, const int64_t *, size_t)
     * }
     */
    public static final AddressLayout FillSparseTensorCoo$layout() {
        return FillSparseTensorCoo$LAYOUT;
    }

    private static final long FillSparseTensorCoo$OFFSET = 1440;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*FillSparseTensorCoo)(OrtValue *, const OrtMemoryInfo *, const int64_t *, size_t, const void *, const int64_t *, size_t)
     * }
     */
    public static final long FillSparseTensorCoo$offset() {
        return FillSparseTensorCoo$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*FillSparseTensorCoo)(OrtValue *, const OrtMemoryInfo *, const int64_t *, size_t, const void *, const int64_t *, size_t)
     * }
     */
    public static MemorySegment FillSparseTensorCoo(MemorySegment struct) {
        return struct.get(FillSparseTensorCoo$LAYOUT, FillSparseTensorCoo$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*FillSparseTensorCoo)(OrtValue *, const OrtMemoryInfo *, const int64_t *, size_t, const void *, const int64_t *, size_t)
     * }
     */
    public static void FillSparseTensorCoo(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(FillSparseTensorCoo$LAYOUT, FillSparseTensorCoo$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*FillSparseTensorCoo)(OrtValue *, const OrtMemoryInfo *, const int64_t *, size_t, const void *, const int64_t *, size_t)
     * }
     */
    public static FillSparseTensorCoo.Function FillSparseTensorCooFunction(MemorySegment struct) {
        return FillSparseTensorCoo.function(FillSparseTensorCoo(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*FillSparseTensorCsr)(OrtValue *, const OrtMemoryInfo *, const int64_t *, size_t, const void *, const int64_t *, size_t, const int64_t *, size_t)
     * }
     */
    public static class FillSparseTensorCsr {

        FillSparseTensorCsr() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(
                    MemorySegment _x0,
                    MemorySegment _x1,
                    MemorySegment _x2,
                    long _x3,
                    MemorySegment _x4,
                    MemorySegment _x5,
                    long _x6,
                    MemorySegment _x7,
                    long _x8);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_LONG,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_LONG,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_LONG);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(FillSparseTensorCsr.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(FillSparseTensorCsr.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr,
                MemorySegment _x0,
                MemorySegment _x1,
                MemorySegment _x2,
                long _x3,
                MemorySegment _x4,
                MemorySegment _x5,
                long _x6,
                MemorySegment _x7,
                long _x8) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7, _x8);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static FillSparseTensorCsr.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7, _x8) ->
                    invoke(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7, _x8);
        }
    }

    private static final AddressLayout FillSparseTensorCsr$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("FillSparseTensorCsr"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*FillSparseTensorCsr)(OrtValue *, const OrtMemoryInfo *, const int64_t *, size_t, const void *, const int64_t *, size_t, const int64_t *, size_t)
     * }
     */
    public static final AddressLayout FillSparseTensorCsr$layout() {
        return FillSparseTensorCsr$LAYOUT;
    }

    private static final long FillSparseTensorCsr$OFFSET = 1448;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*FillSparseTensorCsr)(OrtValue *, const OrtMemoryInfo *, const int64_t *, size_t, const void *, const int64_t *, size_t, const int64_t *, size_t)
     * }
     */
    public static final long FillSparseTensorCsr$offset() {
        return FillSparseTensorCsr$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*FillSparseTensorCsr)(OrtValue *, const OrtMemoryInfo *, const int64_t *, size_t, const void *, const int64_t *, size_t, const int64_t *, size_t)
     * }
     */
    public static MemorySegment FillSparseTensorCsr(MemorySegment struct) {
        return struct.get(FillSparseTensorCsr$LAYOUT, FillSparseTensorCsr$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*FillSparseTensorCsr)(OrtValue *, const OrtMemoryInfo *, const int64_t *, size_t, const void *, const int64_t *, size_t, const int64_t *, size_t)
     * }
     */
    public static void FillSparseTensorCsr(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(FillSparseTensorCsr$LAYOUT, FillSparseTensorCsr$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*FillSparseTensorCsr)(OrtValue *, const OrtMemoryInfo *, const int64_t *, size_t, const void *, const int64_t *, size_t, const int64_t *, size_t)
     * }
     */
    public static FillSparseTensorCsr.Function FillSparseTensorCsrFunction(MemorySegment struct) {
        return FillSparseTensorCsr.function(FillSparseTensorCsr(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*FillSparseTensorBlockSparse)(OrtValue *, const OrtMemoryInfo *, const int64_t *, size_t, const void *, const int64_t *, size_t, const int32_t *)
     * }
     */
    public static class FillSparseTensorBlockSparse {

        FillSparseTensorBlockSparse() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(
                    MemorySegment _x0,
                    MemorySegment _x1,
                    MemorySegment _x2,
                    long _x3,
                    MemorySegment _x4,
                    MemorySegment _x5,
                    long _x6,
                    MemorySegment _x7);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_LONG,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_LONG,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(FillSparseTensorBlockSparse.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(FillSparseTensorBlockSparse.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr,
                MemorySegment _x0,
                MemorySegment _x1,
                MemorySegment _x2,
                long _x3,
                MemorySegment _x4,
                MemorySegment _x5,
                long _x6,
                MemorySegment _x7) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static FillSparseTensorBlockSparse.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7) -> invoke(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7);
        }
    }

    private static final AddressLayout FillSparseTensorBlockSparse$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("FillSparseTensorBlockSparse"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*FillSparseTensorBlockSparse)(OrtValue *, const OrtMemoryInfo *, const int64_t *, size_t, const void *, const int64_t *, size_t, const int32_t *)
     * }
     */
    public static final AddressLayout FillSparseTensorBlockSparse$layout() {
        return FillSparseTensorBlockSparse$LAYOUT;
    }

    private static final long FillSparseTensorBlockSparse$OFFSET = 1456;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*FillSparseTensorBlockSparse)(OrtValue *, const OrtMemoryInfo *, const int64_t *, size_t, const void *, const int64_t *, size_t, const int32_t *)
     * }
     */
    public static final long FillSparseTensorBlockSparse$offset() {
        return FillSparseTensorBlockSparse$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*FillSparseTensorBlockSparse)(OrtValue *, const OrtMemoryInfo *, const int64_t *, size_t, const void *, const int64_t *, size_t, const int32_t *)
     * }
     */
    public static MemorySegment FillSparseTensorBlockSparse(MemorySegment struct) {
        return struct.get(FillSparseTensorBlockSparse$LAYOUT, FillSparseTensorBlockSparse$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*FillSparseTensorBlockSparse)(OrtValue *, const OrtMemoryInfo *, const int64_t *, size_t, const void *, const int64_t *, size_t, const int32_t *)
     * }
     */
    public static void FillSparseTensorBlockSparse(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(FillSparseTensorBlockSparse$LAYOUT, FillSparseTensorBlockSparse$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*FillSparseTensorBlockSparse)(OrtValue *, const OrtMemoryInfo *, const int64_t *, size_t, const void *, const int64_t *, size_t, const int32_t *)
     * }
     */
    public static FillSparseTensorBlockSparse.Function FillSparseTensorBlockSparseFunction(MemorySegment struct) {
        return FillSparseTensorBlockSparse.function(FillSparseTensorBlockSparse(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSparseTensorWithValuesAsOrtValue)(const OrtMemoryInfo *, void *, const int64_t *, size_t, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)
     * }
     */
    public static class CreateSparseTensorWithValuesAsOrtValue {

        CreateSparseTensorWithValuesAsOrtValue() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(
                    MemorySegment _x0,
                    MemorySegment _x1,
                    MemorySegment _x2,
                    long _x3,
                    MemorySegment _x4,
                    long _x5,
                    int _x6,
                    MemorySegment _x7);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_LONG,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_LONG,
                onnxruntime_all_h.C_INT,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(CreateSparseTensorWithValuesAsOrtValue.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateSparseTensorWithValuesAsOrtValue.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr,
                MemorySegment _x0,
                MemorySegment _x1,
                MemorySegment _x2,
                long _x3,
                MemorySegment _x4,
                long _x5,
                int _x6,
                MemorySegment _x7) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static CreateSparseTensorWithValuesAsOrtValue.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7) -> invoke(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7);
        }
    }

    private static final AddressLayout CreateSparseTensorWithValuesAsOrtValue$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("CreateSparseTensorWithValuesAsOrtValue"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSparseTensorWithValuesAsOrtValue)(const OrtMemoryInfo *, void *, const int64_t *, size_t, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)
     * }
     */
    public static final AddressLayout CreateSparseTensorWithValuesAsOrtValue$layout() {
        return CreateSparseTensorWithValuesAsOrtValue$LAYOUT;
    }

    private static final long CreateSparseTensorWithValuesAsOrtValue$OFFSET = 1464;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSparseTensorWithValuesAsOrtValue)(const OrtMemoryInfo *, void *, const int64_t *, size_t, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)
     * }
     */
    public static final long CreateSparseTensorWithValuesAsOrtValue$offset() {
        return CreateSparseTensorWithValuesAsOrtValue$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSparseTensorWithValuesAsOrtValue)(const OrtMemoryInfo *, void *, const int64_t *, size_t, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)
     * }
     */
    public static MemorySegment CreateSparseTensorWithValuesAsOrtValue(MemorySegment struct) {
        return struct.get(CreateSparseTensorWithValuesAsOrtValue$LAYOUT, CreateSparseTensorWithValuesAsOrtValue$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSparseTensorWithValuesAsOrtValue)(const OrtMemoryInfo *, void *, const int64_t *, size_t, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)
     * }
     */
    public static void CreateSparseTensorWithValuesAsOrtValue(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(
                CreateSparseTensorWithValuesAsOrtValue$LAYOUT,
                CreateSparseTensorWithValuesAsOrtValue$OFFSET,
                fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateSparseTensorWithValuesAsOrtValue)(const OrtMemoryInfo *, void *, const int64_t *, size_t, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)
     * }
     */
    public static CreateSparseTensorWithValuesAsOrtValue.Function CreateSparseTensorWithValuesAsOrtValueFunction(
            MemorySegment struct) {
        return CreateSparseTensorWithValuesAsOrtValue.function(CreateSparseTensorWithValuesAsOrtValue(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*UseCooIndices)(OrtValue *, int64_t *, size_t)
     * }
     */
    public static class UseCooIndices {

        UseCooIndices() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_LONG);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(UseCooIndices.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(UseCooIndices.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, long _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static UseCooIndices.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2) -> invoke(funcPtr, _x0, _x1, _x2);
        }
    }

    private static final AddressLayout UseCooIndices$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("UseCooIndices"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UseCooIndices)(OrtValue *, int64_t *, size_t)
     * }
     */
    public static final AddressLayout UseCooIndices$layout() {
        return UseCooIndices$LAYOUT;
    }

    private static final long UseCooIndices$OFFSET = 1472;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UseCooIndices)(OrtValue *, int64_t *, size_t)
     * }
     */
    public static final long UseCooIndices$offset() {
        return UseCooIndices$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UseCooIndices)(OrtValue *, int64_t *, size_t)
     * }
     */
    public static MemorySegment UseCooIndices(MemorySegment struct) {
        return struct.get(UseCooIndices$LAYOUT, UseCooIndices$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UseCooIndices)(OrtValue *, int64_t *, size_t)
     * }
     */
    public static void UseCooIndices(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(UseCooIndices$LAYOUT, UseCooIndices$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UseCooIndices)(OrtValue *, int64_t *, size_t)
     * }
     */
    public static UseCooIndices.Function UseCooIndicesFunction(MemorySegment struct) {
        return UseCooIndices.function(UseCooIndices(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*UseCsrIndices)(OrtValue *, int64_t *, size_t, int64_t *, size_t)
     * }
     */
    public static class UseCsrIndices {

        UseCsrIndices() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3, long _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_LONG,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_LONG);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(UseCsrIndices.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(UseCsrIndices.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3, long _x4) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static UseCsrIndices.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2, _x3, _x4) -> invoke(funcPtr, _x0, _x1, _x2, _x3, _x4);
        }
    }

    private static final AddressLayout UseCsrIndices$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("UseCsrIndices"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UseCsrIndices)(OrtValue *, int64_t *, size_t, int64_t *, size_t)
     * }
     */
    public static final AddressLayout UseCsrIndices$layout() {
        return UseCsrIndices$LAYOUT;
    }

    private static final long UseCsrIndices$OFFSET = 1480;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UseCsrIndices)(OrtValue *, int64_t *, size_t, int64_t *, size_t)
     * }
     */
    public static final long UseCsrIndices$offset() {
        return UseCsrIndices$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UseCsrIndices)(OrtValue *, int64_t *, size_t, int64_t *, size_t)
     * }
     */
    public static MemorySegment UseCsrIndices(MemorySegment struct) {
        return struct.get(UseCsrIndices$LAYOUT, UseCsrIndices$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UseCsrIndices)(OrtValue *, int64_t *, size_t, int64_t *, size_t)
     * }
     */
    public static void UseCsrIndices(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(UseCsrIndices$LAYOUT, UseCsrIndices$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UseCsrIndices)(OrtValue *, int64_t *, size_t, int64_t *, size_t)
     * }
     */
    public static UseCsrIndices.Function UseCsrIndicesFunction(MemorySegment struct) {
        return UseCsrIndices.function(UseCsrIndices(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*UseBlockSparseIndices)(OrtValue *, const int64_t *, size_t, int32_t *)
     * }
     */
    public static class UseBlockSparseIndices {

        UseBlockSparseIndices() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_LONG,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(UseBlockSparseIndices.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(UseBlockSparseIndices.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static UseBlockSparseIndices.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2, _x3) -> invoke(funcPtr, _x0, _x1, _x2, _x3);
        }
    }

    private static final AddressLayout UseBlockSparseIndices$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("UseBlockSparseIndices"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UseBlockSparseIndices)(OrtValue *, const int64_t *, size_t, int32_t *)
     * }
     */
    public static final AddressLayout UseBlockSparseIndices$layout() {
        return UseBlockSparseIndices$LAYOUT;
    }

    private static final long UseBlockSparseIndices$OFFSET = 1488;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UseBlockSparseIndices)(OrtValue *, const int64_t *, size_t, int32_t *)
     * }
     */
    public static final long UseBlockSparseIndices$offset() {
        return UseBlockSparseIndices$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UseBlockSparseIndices)(OrtValue *, const int64_t *, size_t, int32_t *)
     * }
     */
    public static MemorySegment UseBlockSparseIndices(MemorySegment struct) {
        return struct.get(UseBlockSparseIndices$LAYOUT, UseBlockSparseIndices$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UseBlockSparseIndices)(OrtValue *, const int64_t *, size_t, int32_t *)
     * }
     */
    public static void UseBlockSparseIndices(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(UseBlockSparseIndices$LAYOUT, UseBlockSparseIndices$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UseBlockSparseIndices)(OrtValue *, const int64_t *, size_t, int32_t *)
     * }
     */
    public static UseBlockSparseIndices.Function UseBlockSparseIndicesFunction(MemorySegment struct) {
        return UseBlockSparseIndices.function(UseBlockSparseIndices(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSparseTensorFormat)(const OrtValue *, enum OrtSparseFormat *)
     * }
     */
    public static class GetSparseTensorFormat {

        GetSparseTensorFormat() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(GetSparseTensorFormat.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetSparseTensorFormat.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static GetSparseTensorFormat.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout GetSparseTensorFormat$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("GetSparseTensorFormat"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSparseTensorFormat)(const OrtValue *, enum OrtSparseFormat *)
     * }
     */
    public static final AddressLayout GetSparseTensorFormat$layout() {
        return GetSparseTensorFormat$LAYOUT;
    }

    private static final long GetSparseTensorFormat$OFFSET = 1496;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSparseTensorFormat)(const OrtValue *, enum OrtSparseFormat *)
     * }
     */
    public static final long GetSparseTensorFormat$offset() {
        return GetSparseTensorFormat$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSparseTensorFormat)(const OrtValue *, enum OrtSparseFormat *)
     * }
     */
    public static MemorySegment GetSparseTensorFormat(MemorySegment struct) {
        return struct.get(GetSparseTensorFormat$LAYOUT, GetSparseTensorFormat$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSparseTensorFormat)(const OrtValue *, enum OrtSparseFormat *)
     * }
     */
    public static void GetSparseTensorFormat(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetSparseTensorFormat$LAYOUT, GetSparseTensorFormat$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSparseTensorFormat)(const OrtValue *, enum OrtSparseFormat *)
     * }
     */
    public static GetSparseTensorFormat.Function GetSparseTensorFormatFunction(MemorySegment struct) {
        return GetSparseTensorFormat.function(GetSparseTensorFormat(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSparseTensorValuesTypeAndShape)(const OrtValue *, OrtTensorTypeAndShapeInfo **)
     * }
     */
    public static class GetSparseTensorValuesTypeAndShape {

        GetSparseTensorValuesTypeAndShape() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(GetSparseTensorValuesTypeAndShape.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetSparseTensorValuesTypeAndShape.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static GetSparseTensorValuesTypeAndShape.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout GetSparseTensorValuesTypeAndShape$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("GetSparseTensorValuesTypeAndShape"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSparseTensorValuesTypeAndShape)(const OrtValue *, OrtTensorTypeAndShapeInfo **)
     * }
     */
    public static final AddressLayout GetSparseTensorValuesTypeAndShape$layout() {
        return GetSparseTensorValuesTypeAndShape$LAYOUT;
    }

    private static final long GetSparseTensorValuesTypeAndShape$OFFSET = 1504;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSparseTensorValuesTypeAndShape)(const OrtValue *, OrtTensorTypeAndShapeInfo **)
     * }
     */
    public static final long GetSparseTensorValuesTypeAndShape$offset() {
        return GetSparseTensorValuesTypeAndShape$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSparseTensorValuesTypeAndShape)(const OrtValue *, OrtTensorTypeAndShapeInfo **)
     * }
     */
    public static MemorySegment GetSparseTensorValuesTypeAndShape(MemorySegment struct) {
        return struct.get(GetSparseTensorValuesTypeAndShape$LAYOUT, GetSparseTensorValuesTypeAndShape$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSparseTensorValuesTypeAndShape)(const OrtValue *, OrtTensorTypeAndShapeInfo **)
     * }
     */
    public static void GetSparseTensorValuesTypeAndShape(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetSparseTensorValuesTypeAndShape$LAYOUT, GetSparseTensorValuesTypeAndShape$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSparseTensorValuesTypeAndShape)(const OrtValue *, OrtTensorTypeAndShapeInfo **)
     * }
     */
    public static GetSparseTensorValuesTypeAndShape.Function GetSparseTensorValuesTypeAndShapeFunction(
            MemorySegment struct) {
        return GetSparseTensorValuesTypeAndShape.function(GetSparseTensorValuesTypeAndShape(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSparseTensorValues)(const OrtValue *, const void **)
     * }
     */
    public static class GetSparseTensorValues {

        GetSparseTensorValues() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(GetSparseTensorValues.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetSparseTensorValues.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static GetSparseTensorValues.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout GetSparseTensorValues$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("GetSparseTensorValues"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSparseTensorValues)(const OrtValue *, const void **)
     * }
     */
    public static final AddressLayout GetSparseTensorValues$layout() {
        return GetSparseTensorValues$LAYOUT;
    }

    private static final long GetSparseTensorValues$OFFSET = 1512;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSparseTensorValues)(const OrtValue *, const void **)
     * }
     */
    public static final long GetSparseTensorValues$offset() {
        return GetSparseTensorValues$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSparseTensorValues)(const OrtValue *, const void **)
     * }
     */
    public static MemorySegment GetSparseTensorValues(MemorySegment struct) {
        return struct.get(GetSparseTensorValues$LAYOUT, GetSparseTensorValues$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSparseTensorValues)(const OrtValue *, const void **)
     * }
     */
    public static void GetSparseTensorValues(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetSparseTensorValues$LAYOUT, GetSparseTensorValues$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSparseTensorValues)(const OrtValue *, const void **)
     * }
     */
    public static GetSparseTensorValues.Function GetSparseTensorValuesFunction(MemorySegment struct) {
        return GetSparseTensorValues.function(GetSparseTensorValues(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSparseTensorIndicesTypeShape)(const OrtValue *, enum OrtSparseIndicesFormat, OrtTensorTypeAndShapeInfo **)
     * }
     */
    public static class GetSparseTensorIndicesTypeShape {

        GetSparseTensorIndicesTypeShape() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, int _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_INT,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(GetSparseTensorIndicesTypeShape.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetSparseTensorIndicesTypeShape.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, int _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static GetSparseTensorIndicesTypeShape.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2) -> invoke(funcPtr, _x0, _x1, _x2);
        }
    }

    private static final AddressLayout GetSparseTensorIndicesTypeShape$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("GetSparseTensorIndicesTypeShape"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSparseTensorIndicesTypeShape)(const OrtValue *, enum OrtSparseIndicesFormat, OrtTensorTypeAndShapeInfo **)
     * }
     */
    public static final AddressLayout GetSparseTensorIndicesTypeShape$layout() {
        return GetSparseTensorIndicesTypeShape$LAYOUT;
    }

    private static final long GetSparseTensorIndicesTypeShape$OFFSET = 1520;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSparseTensorIndicesTypeShape)(const OrtValue *, enum OrtSparseIndicesFormat, OrtTensorTypeAndShapeInfo **)
     * }
     */
    public static final long GetSparseTensorIndicesTypeShape$offset() {
        return GetSparseTensorIndicesTypeShape$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSparseTensorIndicesTypeShape)(const OrtValue *, enum OrtSparseIndicesFormat, OrtTensorTypeAndShapeInfo **)
     * }
     */
    public static MemorySegment GetSparseTensorIndicesTypeShape(MemorySegment struct) {
        return struct.get(GetSparseTensorIndicesTypeShape$LAYOUT, GetSparseTensorIndicesTypeShape$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSparseTensorIndicesTypeShape)(const OrtValue *, enum OrtSparseIndicesFormat, OrtTensorTypeAndShapeInfo **)
     * }
     */
    public static void GetSparseTensorIndicesTypeShape(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetSparseTensorIndicesTypeShape$LAYOUT, GetSparseTensorIndicesTypeShape$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSparseTensorIndicesTypeShape)(const OrtValue *, enum OrtSparseIndicesFormat, OrtTensorTypeAndShapeInfo **)
     * }
     */
    public static GetSparseTensorIndicesTypeShape.Function GetSparseTensorIndicesTypeShapeFunction(
            MemorySegment struct) {
        return GetSparseTensorIndicesTypeShape.function(GetSparseTensorIndicesTypeShape(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSparseTensorIndices)(const OrtValue *, enum OrtSparseIndicesFormat, size_t *, const void **)
     * }
     */
    public static class GetSparseTensorIndices {

        GetSparseTensorIndices() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_INT,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(GetSparseTensorIndices.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetSparseTensorIndices.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr, MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static GetSparseTensorIndices.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2, _x3) -> invoke(funcPtr, _x0, _x1, _x2, _x3);
        }
    }

    private static final AddressLayout GetSparseTensorIndices$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("GetSparseTensorIndices"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSparseTensorIndices)(const OrtValue *, enum OrtSparseIndicesFormat, size_t *, const void **)
     * }
     */
    public static final AddressLayout GetSparseTensorIndices$layout() {
        return GetSparseTensorIndices$LAYOUT;
    }

    private static final long GetSparseTensorIndices$OFFSET = 1528;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSparseTensorIndices)(const OrtValue *, enum OrtSparseIndicesFormat, size_t *, const void **)
     * }
     */
    public static final long GetSparseTensorIndices$offset() {
        return GetSparseTensorIndices$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSparseTensorIndices)(const OrtValue *, enum OrtSparseIndicesFormat, size_t *, const void **)
     * }
     */
    public static MemorySegment GetSparseTensorIndices(MemorySegment struct) {
        return struct.get(GetSparseTensorIndices$LAYOUT, GetSparseTensorIndices$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSparseTensorIndices)(const OrtValue *, enum OrtSparseIndicesFormat, size_t *, const void **)
     * }
     */
    public static void GetSparseTensorIndices(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetSparseTensorIndices$LAYOUT, GetSparseTensorIndices$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSparseTensorIndices)(const OrtValue *, enum OrtSparseIndicesFormat, size_t *, const void **)
     * }
     */
    public static GetSparseTensorIndices.Function GetSparseTensorIndicesFunction(MemorySegment struct) {
        return GetSparseTensorIndices.function(GetSparseTensorIndices(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*HasValue)(const OrtValue *, int *)
     * }
     */
    public static class HasValue {

        HasValue() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(HasValue.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(HasValue.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static HasValue.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout HasValue$LAYOUT = (AddressLayout) $LAYOUT.select(groupElement("HasValue"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*HasValue)(const OrtValue *, int *)
     * }
     */
    public static final AddressLayout HasValue$layout() {
        return HasValue$LAYOUT;
    }

    private static final long HasValue$OFFSET = 1536;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*HasValue)(const OrtValue *, int *)
     * }
     */
    public static final long HasValue$offset() {
        return HasValue$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*HasValue)(const OrtValue *, int *)
     * }
     */
    public static MemorySegment HasValue(MemorySegment struct) {
        return struct.get(HasValue$LAYOUT, HasValue$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*HasValue)(const OrtValue *, int *)
     * }
     */
    public static void HasValue(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(HasValue$LAYOUT, HasValue$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*HasValue)(const OrtValue *, int *)
     * }
     */
    public static HasValue.Function HasValueFunction(MemorySegment struct) {
        return HasValue.function(HasValue(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetGPUComputeStream)(const OrtKernelContext *, void **)
     * }
     */
    public static class KernelContext_GetGPUComputeStream {

        KernelContext_GetGPUComputeStream() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(KernelContext_GetGPUComputeStream.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(KernelContext_GetGPUComputeStream.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static KernelContext_GetGPUComputeStream.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout KernelContext_GetGPUComputeStream$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("KernelContext_GetGPUComputeStream"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetGPUComputeStream)(const OrtKernelContext *, void **)
     * }
     */
    public static final AddressLayout KernelContext_GetGPUComputeStream$layout() {
        return KernelContext_GetGPUComputeStream$LAYOUT;
    }

    private static final long KernelContext_GetGPUComputeStream$OFFSET = 1544;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetGPUComputeStream)(const OrtKernelContext *, void **)
     * }
     */
    public static final long KernelContext_GetGPUComputeStream$offset() {
        return KernelContext_GetGPUComputeStream$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetGPUComputeStream)(const OrtKernelContext *, void **)
     * }
     */
    public static MemorySegment KernelContext_GetGPUComputeStream(MemorySegment struct) {
        return struct.get(KernelContext_GetGPUComputeStream$LAYOUT, KernelContext_GetGPUComputeStream$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetGPUComputeStream)(const OrtKernelContext *, void **)
     * }
     */
    public static void KernelContext_GetGPUComputeStream(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(KernelContext_GetGPUComputeStream$LAYOUT, KernelContext_GetGPUComputeStream$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetGPUComputeStream)(const OrtKernelContext *, void **)
     * }
     */
    public static KernelContext_GetGPUComputeStream.Function KernelContext_GetGPUComputeStreamFunction(
            MemorySegment struct) {
        return KernelContext_GetGPUComputeStream.function(KernelContext_GetGPUComputeStream(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorMemoryInfo)(const OrtValue *, const OrtMemoryInfo **)
     * }
     */
    public static class GetTensorMemoryInfo {

        GetTensorMemoryInfo() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(GetTensorMemoryInfo.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetTensorMemoryInfo.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static GetTensorMemoryInfo.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout GetTensorMemoryInfo$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("GetTensorMemoryInfo"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorMemoryInfo)(const OrtValue *, const OrtMemoryInfo **)
     * }
     */
    public static final AddressLayout GetTensorMemoryInfo$layout() {
        return GetTensorMemoryInfo$LAYOUT;
    }

    private static final long GetTensorMemoryInfo$OFFSET = 1552;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorMemoryInfo)(const OrtValue *, const OrtMemoryInfo **)
     * }
     */
    public static final long GetTensorMemoryInfo$offset() {
        return GetTensorMemoryInfo$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorMemoryInfo)(const OrtValue *, const OrtMemoryInfo **)
     * }
     */
    public static MemorySegment GetTensorMemoryInfo(MemorySegment struct) {
        return struct.get(GetTensorMemoryInfo$LAYOUT, GetTensorMemoryInfo$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorMemoryInfo)(const OrtValue *, const OrtMemoryInfo **)
     * }
     */
    public static void GetTensorMemoryInfo(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetTensorMemoryInfo$LAYOUT, GetTensorMemoryInfo$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorMemoryInfo)(const OrtValue *, const OrtMemoryInfo **)
     * }
     */
    public static GetTensorMemoryInfo.Function GetTensorMemoryInfoFunction(MemorySegment struct) {
        return GetTensorMemoryInfo.function(GetTensorMemoryInfo(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetExecutionProviderApi)(const char *, uint32_t, const void **)
     * }
     */
    public static class GetExecutionProviderApi {

        GetExecutionProviderApi() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, int _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_INT,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(GetExecutionProviderApi.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetExecutionProviderApi.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, int _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static GetExecutionProviderApi.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2) -> invoke(funcPtr, _x0, _x1, _x2);
        }
    }

    private static final AddressLayout GetExecutionProviderApi$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("GetExecutionProviderApi"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetExecutionProviderApi)(const char *, uint32_t, const void **)
     * }
     */
    public static final AddressLayout GetExecutionProviderApi$layout() {
        return GetExecutionProviderApi$LAYOUT;
    }

    private static final long GetExecutionProviderApi$OFFSET = 1560;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetExecutionProviderApi)(const char *, uint32_t, const void **)
     * }
     */
    public static final long GetExecutionProviderApi$offset() {
        return GetExecutionProviderApi$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetExecutionProviderApi)(const char *, uint32_t, const void **)
     * }
     */
    public static MemorySegment GetExecutionProviderApi(MemorySegment struct) {
        return struct.get(GetExecutionProviderApi$LAYOUT, GetExecutionProviderApi$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetExecutionProviderApi)(const char *, uint32_t, const void **)
     * }
     */
    public static void GetExecutionProviderApi(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetExecutionProviderApi$LAYOUT, GetExecutionProviderApi$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetExecutionProviderApi)(const char *, uint32_t, const void **)
     * }
     */
    public static GetExecutionProviderApi.Function GetExecutionProviderApiFunction(MemorySegment struct) {
        return GetExecutionProviderApi.function(GetExecutionProviderApi(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsSetCustomCreateThreadFn)(OrtSessionOptions *, OrtCustomCreateThreadFn)
     * }
     */
    public static class SessionOptionsSetCustomCreateThreadFn {

        SessionOptionsSetCustomCreateThreadFn() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(SessionOptionsSetCustomCreateThreadFn.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SessionOptionsSetCustomCreateThreadFn.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static SessionOptionsSetCustomCreateThreadFn.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout SessionOptionsSetCustomCreateThreadFn$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("SessionOptionsSetCustomCreateThreadFn"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsSetCustomCreateThreadFn)(OrtSessionOptions *, OrtCustomCreateThreadFn)
     * }
     */
    public static final AddressLayout SessionOptionsSetCustomCreateThreadFn$layout() {
        return SessionOptionsSetCustomCreateThreadFn$LAYOUT;
    }

    private static final long SessionOptionsSetCustomCreateThreadFn$OFFSET = 1568;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsSetCustomCreateThreadFn)(OrtSessionOptions *, OrtCustomCreateThreadFn)
     * }
     */
    public static final long SessionOptionsSetCustomCreateThreadFn$offset() {
        return SessionOptionsSetCustomCreateThreadFn$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsSetCustomCreateThreadFn)(OrtSessionOptions *, OrtCustomCreateThreadFn)
     * }
     */
    public static MemorySegment SessionOptionsSetCustomCreateThreadFn(MemorySegment struct) {
        return struct.get(SessionOptionsSetCustomCreateThreadFn$LAYOUT, SessionOptionsSetCustomCreateThreadFn$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsSetCustomCreateThreadFn)(OrtSessionOptions *, OrtCustomCreateThreadFn)
     * }
     */
    public static void SessionOptionsSetCustomCreateThreadFn(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(
                SessionOptionsSetCustomCreateThreadFn$LAYOUT, SessionOptionsSetCustomCreateThreadFn$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsSetCustomCreateThreadFn)(OrtSessionOptions *, OrtCustomCreateThreadFn)
     * }
     */
    public static SessionOptionsSetCustomCreateThreadFn.Function SessionOptionsSetCustomCreateThreadFnFunction(
            MemorySegment struct) {
        return SessionOptionsSetCustomCreateThreadFn.function(SessionOptionsSetCustomCreateThreadFn(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsSetCustomThreadCreationOptions)(OrtSessionOptions *, void *)
     * }
     */
    public static class SessionOptionsSetCustomThreadCreationOptions {

        SessionOptionsSetCustomThreadCreationOptions() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_all_h.upcallHandle(
                SessionOptionsSetCustomThreadCreationOptions.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SessionOptionsSetCustomThreadCreationOptions.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static SessionOptionsSetCustomThreadCreationOptions.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout SessionOptionsSetCustomThreadCreationOptions$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("SessionOptionsSetCustomThreadCreationOptions"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsSetCustomThreadCreationOptions)(OrtSessionOptions *, void *)
     * }
     */
    public static final AddressLayout SessionOptionsSetCustomThreadCreationOptions$layout() {
        return SessionOptionsSetCustomThreadCreationOptions$LAYOUT;
    }

    private static final long SessionOptionsSetCustomThreadCreationOptions$OFFSET = 1576;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsSetCustomThreadCreationOptions)(OrtSessionOptions *, void *)
     * }
     */
    public static final long SessionOptionsSetCustomThreadCreationOptions$offset() {
        return SessionOptionsSetCustomThreadCreationOptions$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsSetCustomThreadCreationOptions)(OrtSessionOptions *, void *)
     * }
     */
    public static MemorySegment SessionOptionsSetCustomThreadCreationOptions(MemorySegment struct) {
        return struct.get(
                SessionOptionsSetCustomThreadCreationOptions$LAYOUT,
                SessionOptionsSetCustomThreadCreationOptions$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsSetCustomThreadCreationOptions)(OrtSessionOptions *, void *)
     * }
     */
    public static void SessionOptionsSetCustomThreadCreationOptions(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(
                SessionOptionsSetCustomThreadCreationOptions$LAYOUT,
                SessionOptionsSetCustomThreadCreationOptions$OFFSET,
                fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsSetCustomThreadCreationOptions)(OrtSessionOptions *, void *)
     * }
     */
    public static SessionOptionsSetCustomThreadCreationOptions.Function
            SessionOptionsSetCustomThreadCreationOptionsFunction(MemorySegment struct) {
        return SessionOptionsSetCustomThreadCreationOptions.function(
                SessionOptionsSetCustomThreadCreationOptions(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsSetCustomJoinThreadFn)(OrtSessionOptions *, OrtCustomJoinThreadFn)
     * }
     */
    public static class SessionOptionsSetCustomJoinThreadFn {

        SessionOptionsSetCustomJoinThreadFn() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(SessionOptionsSetCustomJoinThreadFn.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SessionOptionsSetCustomJoinThreadFn.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static SessionOptionsSetCustomJoinThreadFn.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout SessionOptionsSetCustomJoinThreadFn$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("SessionOptionsSetCustomJoinThreadFn"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsSetCustomJoinThreadFn)(OrtSessionOptions *, OrtCustomJoinThreadFn)
     * }
     */
    public static final AddressLayout SessionOptionsSetCustomJoinThreadFn$layout() {
        return SessionOptionsSetCustomJoinThreadFn$LAYOUT;
    }

    private static final long SessionOptionsSetCustomJoinThreadFn$OFFSET = 1584;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsSetCustomJoinThreadFn)(OrtSessionOptions *, OrtCustomJoinThreadFn)
     * }
     */
    public static final long SessionOptionsSetCustomJoinThreadFn$offset() {
        return SessionOptionsSetCustomJoinThreadFn$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsSetCustomJoinThreadFn)(OrtSessionOptions *, OrtCustomJoinThreadFn)
     * }
     */
    public static MemorySegment SessionOptionsSetCustomJoinThreadFn(MemorySegment struct) {
        return struct.get(SessionOptionsSetCustomJoinThreadFn$LAYOUT, SessionOptionsSetCustomJoinThreadFn$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsSetCustomJoinThreadFn)(OrtSessionOptions *, OrtCustomJoinThreadFn)
     * }
     */
    public static void SessionOptionsSetCustomJoinThreadFn(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SessionOptionsSetCustomJoinThreadFn$LAYOUT, SessionOptionsSetCustomJoinThreadFn$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsSetCustomJoinThreadFn)(OrtSessionOptions *, OrtCustomJoinThreadFn)
     * }
     */
    public static SessionOptionsSetCustomJoinThreadFn.Function SessionOptionsSetCustomJoinThreadFnFunction(
            MemorySegment struct) {
        return SessionOptionsSetCustomJoinThreadFn.function(SessionOptionsSetCustomJoinThreadFn(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalCustomCreateThreadFn)(OrtThreadingOptions *, OrtCustomCreateThreadFn)
     * }
     */
    public static class SetGlobalCustomCreateThreadFn {

        SetGlobalCustomCreateThreadFn() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(SetGlobalCustomCreateThreadFn.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetGlobalCustomCreateThreadFn.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static SetGlobalCustomCreateThreadFn.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout SetGlobalCustomCreateThreadFn$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("SetGlobalCustomCreateThreadFn"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalCustomCreateThreadFn)(OrtThreadingOptions *, OrtCustomCreateThreadFn)
     * }
     */
    public static final AddressLayout SetGlobalCustomCreateThreadFn$layout() {
        return SetGlobalCustomCreateThreadFn$LAYOUT;
    }

    private static final long SetGlobalCustomCreateThreadFn$OFFSET = 1592;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalCustomCreateThreadFn)(OrtThreadingOptions *, OrtCustomCreateThreadFn)
     * }
     */
    public static final long SetGlobalCustomCreateThreadFn$offset() {
        return SetGlobalCustomCreateThreadFn$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalCustomCreateThreadFn)(OrtThreadingOptions *, OrtCustomCreateThreadFn)
     * }
     */
    public static MemorySegment SetGlobalCustomCreateThreadFn(MemorySegment struct) {
        return struct.get(SetGlobalCustomCreateThreadFn$LAYOUT, SetGlobalCustomCreateThreadFn$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalCustomCreateThreadFn)(OrtThreadingOptions *, OrtCustomCreateThreadFn)
     * }
     */
    public static void SetGlobalCustomCreateThreadFn(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetGlobalCustomCreateThreadFn$LAYOUT, SetGlobalCustomCreateThreadFn$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalCustomCreateThreadFn)(OrtThreadingOptions *, OrtCustomCreateThreadFn)
     * }
     */
    public static SetGlobalCustomCreateThreadFn.Function SetGlobalCustomCreateThreadFnFunction(MemorySegment struct) {
        return SetGlobalCustomCreateThreadFn.function(SetGlobalCustomCreateThreadFn(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalCustomThreadCreationOptions)(OrtThreadingOptions *, void *)
     * }
     */
    public static class SetGlobalCustomThreadCreationOptions {

        SetGlobalCustomThreadCreationOptions() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(SetGlobalCustomThreadCreationOptions.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetGlobalCustomThreadCreationOptions.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static SetGlobalCustomThreadCreationOptions.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout SetGlobalCustomThreadCreationOptions$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("SetGlobalCustomThreadCreationOptions"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalCustomThreadCreationOptions)(OrtThreadingOptions *, void *)
     * }
     */
    public static final AddressLayout SetGlobalCustomThreadCreationOptions$layout() {
        return SetGlobalCustomThreadCreationOptions$LAYOUT;
    }

    private static final long SetGlobalCustomThreadCreationOptions$OFFSET = 1600;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalCustomThreadCreationOptions)(OrtThreadingOptions *, void *)
     * }
     */
    public static final long SetGlobalCustomThreadCreationOptions$offset() {
        return SetGlobalCustomThreadCreationOptions$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalCustomThreadCreationOptions)(OrtThreadingOptions *, void *)
     * }
     */
    public static MemorySegment SetGlobalCustomThreadCreationOptions(MemorySegment struct) {
        return struct.get(SetGlobalCustomThreadCreationOptions$LAYOUT, SetGlobalCustomThreadCreationOptions$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalCustomThreadCreationOptions)(OrtThreadingOptions *, void *)
     * }
     */
    public static void SetGlobalCustomThreadCreationOptions(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(
                SetGlobalCustomThreadCreationOptions$LAYOUT, SetGlobalCustomThreadCreationOptions$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalCustomThreadCreationOptions)(OrtThreadingOptions *, void *)
     * }
     */
    public static SetGlobalCustomThreadCreationOptions.Function SetGlobalCustomThreadCreationOptionsFunction(
            MemorySegment struct) {
        return SetGlobalCustomThreadCreationOptions.function(SetGlobalCustomThreadCreationOptions(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalCustomJoinThreadFn)(OrtThreadingOptions *, OrtCustomJoinThreadFn)
     * }
     */
    public static class SetGlobalCustomJoinThreadFn {

        SetGlobalCustomJoinThreadFn() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(SetGlobalCustomJoinThreadFn.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetGlobalCustomJoinThreadFn.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static SetGlobalCustomJoinThreadFn.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout SetGlobalCustomJoinThreadFn$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("SetGlobalCustomJoinThreadFn"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalCustomJoinThreadFn)(OrtThreadingOptions *, OrtCustomJoinThreadFn)
     * }
     */
    public static final AddressLayout SetGlobalCustomJoinThreadFn$layout() {
        return SetGlobalCustomJoinThreadFn$LAYOUT;
    }

    private static final long SetGlobalCustomJoinThreadFn$OFFSET = 1608;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalCustomJoinThreadFn)(OrtThreadingOptions *, OrtCustomJoinThreadFn)
     * }
     */
    public static final long SetGlobalCustomJoinThreadFn$offset() {
        return SetGlobalCustomJoinThreadFn$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalCustomJoinThreadFn)(OrtThreadingOptions *, OrtCustomJoinThreadFn)
     * }
     */
    public static MemorySegment SetGlobalCustomJoinThreadFn(MemorySegment struct) {
        return struct.get(SetGlobalCustomJoinThreadFn$LAYOUT, SetGlobalCustomJoinThreadFn$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalCustomJoinThreadFn)(OrtThreadingOptions *, OrtCustomJoinThreadFn)
     * }
     */
    public static void SetGlobalCustomJoinThreadFn(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetGlobalCustomJoinThreadFn$LAYOUT, SetGlobalCustomJoinThreadFn$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalCustomJoinThreadFn)(OrtThreadingOptions *, OrtCustomJoinThreadFn)
     * }
     */
    public static SetGlobalCustomJoinThreadFn.Function SetGlobalCustomJoinThreadFnFunction(MemorySegment struct) {
        return SetGlobalCustomJoinThreadFn.function(SetGlobalCustomJoinThreadFn(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SynchronizeBoundInputs)(OrtIoBinding *)
     * }
     */
    public static class SynchronizeBoundInputs {

        SynchronizeBoundInputs() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC =
                FunctionDescriptor.of(onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(SynchronizeBoundInputs.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SynchronizeBoundInputs.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static SynchronizeBoundInputs.Function function(MemorySegment funcPtr) {
            return (_x0) -> invoke(funcPtr, _x0);
        }
    }

    private static final AddressLayout SynchronizeBoundInputs$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("SynchronizeBoundInputs"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SynchronizeBoundInputs)(OrtIoBinding *)
     * }
     */
    public static final AddressLayout SynchronizeBoundInputs$layout() {
        return SynchronizeBoundInputs$LAYOUT;
    }

    private static final long SynchronizeBoundInputs$OFFSET = 1616;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SynchronizeBoundInputs)(OrtIoBinding *)
     * }
     */
    public static final long SynchronizeBoundInputs$offset() {
        return SynchronizeBoundInputs$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SynchronizeBoundInputs)(OrtIoBinding *)
     * }
     */
    public static MemorySegment SynchronizeBoundInputs(MemorySegment struct) {
        return struct.get(SynchronizeBoundInputs$LAYOUT, SynchronizeBoundInputs$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SynchronizeBoundInputs)(OrtIoBinding *)
     * }
     */
    public static void SynchronizeBoundInputs(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SynchronizeBoundInputs$LAYOUT, SynchronizeBoundInputs$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SynchronizeBoundInputs)(OrtIoBinding *)
     * }
     */
    public static SynchronizeBoundInputs.Function SynchronizeBoundInputsFunction(MemorySegment struct) {
        return SynchronizeBoundInputs.function(SynchronizeBoundInputs(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SynchronizeBoundOutputs)(OrtIoBinding *)
     * }
     */
    public static class SynchronizeBoundOutputs {

        SynchronizeBoundOutputs() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC =
                FunctionDescriptor.of(onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(SynchronizeBoundOutputs.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SynchronizeBoundOutputs.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static SynchronizeBoundOutputs.Function function(MemorySegment funcPtr) {
            return (_x0) -> invoke(funcPtr, _x0);
        }
    }

    private static final AddressLayout SynchronizeBoundOutputs$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("SynchronizeBoundOutputs"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SynchronizeBoundOutputs)(OrtIoBinding *)
     * }
     */
    public static final AddressLayout SynchronizeBoundOutputs$layout() {
        return SynchronizeBoundOutputs$LAYOUT;
    }

    private static final long SynchronizeBoundOutputs$OFFSET = 1624;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SynchronizeBoundOutputs)(OrtIoBinding *)
     * }
     */
    public static final long SynchronizeBoundOutputs$offset() {
        return SynchronizeBoundOutputs$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SynchronizeBoundOutputs)(OrtIoBinding *)
     * }
     */
    public static MemorySegment SynchronizeBoundOutputs(MemorySegment struct) {
        return struct.get(SynchronizeBoundOutputs$LAYOUT, SynchronizeBoundOutputs$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SynchronizeBoundOutputs)(OrtIoBinding *)
     * }
     */
    public static void SynchronizeBoundOutputs(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SynchronizeBoundOutputs$LAYOUT, SynchronizeBoundOutputs$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SynchronizeBoundOutputs)(OrtIoBinding *)
     * }
     */
    public static SynchronizeBoundOutputs.Function SynchronizeBoundOutputsFunction(MemorySegment struct) {
        return SynchronizeBoundOutputs.function(SynchronizeBoundOutputs(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_CUDA_V2)(OrtSessionOptions *, const OrtCUDAProviderOptionsV2 *)
     * }
     */
    public static class SessionOptionsAppendExecutionProvider_CUDA_V2 {

        SessionOptionsAppendExecutionProvider_CUDA_V2() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_all_h.upcallHandle(
                SessionOptionsAppendExecutionProvider_CUDA_V2.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SessionOptionsAppendExecutionProvider_CUDA_V2.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static SessionOptionsAppendExecutionProvider_CUDA_V2.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout SessionOptionsAppendExecutionProvider_CUDA_V2$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("SessionOptionsAppendExecutionProvider_CUDA_V2"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_CUDA_V2)(OrtSessionOptions *, const OrtCUDAProviderOptionsV2 *)
     * }
     */
    public static final AddressLayout SessionOptionsAppendExecutionProvider_CUDA_V2$layout() {
        return SessionOptionsAppendExecutionProvider_CUDA_V2$LAYOUT;
    }

    private static final long SessionOptionsAppendExecutionProvider_CUDA_V2$OFFSET = 1632;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_CUDA_V2)(OrtSessionOptions *, const OrtCUDAProviderOptionsV2 *)
     * }
     */
    public static final long SessionOptionsAppendExecutionProvider_CUDA_V2$offset() {
        return SessionOptionsAppendExecutionProvider_CUDA_V2$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_CUDA_V2)(OrtSessionOptions *, const OrtCUDAProviderOptionsV2 *)
     * }
     */
    public static MemorySegment SessionOptionsAppendExecutionProvider_CUDA_V2(MemorySegment struct) {
        return struct.get(
                SessionOptionsAppendExecutionProvider_CUDA_V2$LAYOUT,
                SessionOptionsAppendExecutionProvider_CUDA_V2$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_CUDA_V2)(OrtSessionOptions *, const OrtCUDAProviderOptionsV2 *)
     * }
     */
    public static void SessionOptionsAppendExecutionProvider_CUDA_V2(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(
                SessionOptionsAppendExecutionProvider_CUDA_V2$LAYOUT,
                SessionOptionsAppendExecutionProvider_CUDA_V2$OFFSET,
                fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_CUDA_V2)(OrtSessionOptions *, const OrtCUDAProviderOptionsV2 *)
     * }
     */
    public static SessionOptionsAppendExecutionProvider_CUDA_V2.Function
            SessionOptionsAppendExecutionProvider_CUDA_V2Function(MemorySegment struct) {
        return SessionOptionsAppendExecutionProvider_CUDA_V2.function(
                SessionOptionsAppendExecutionProvider_CUDA_V2(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateCUDAProviderOptions)(OrtCUDAProviderOptionsV2 **)
     * }
     */
    public static class CreateCUDAProviderOptions {

        CreateCUDAProviderOptions() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC =
                FunctionDescriptor.of(onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(CreateCUDAProviderOptions.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateCUDAProviderOptions.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static CreateCUDAProviderOptions.Function function(MemorySegment funcPtr) {
            return (_x0) -> invoke(funcPtr, _x0);
        }
    }

    private static final AddressLayout CreateCUDAProviderOptions$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("CreateCUDAProviderOptions"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateCUDAProviderOptions)(OrtCUDAProviderOptionsV2 **)
     * }
     */
    public static final AddressLayout CreateCUDAProviderOptions$layout() {
        return CreateCUDAProviderOptions$LAYOUT;
    }

    private static final long CreateCUDAProviderOptions$OFFSET = 1640;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateCUDAProviderOptions)(OrtCUDAProviderOptionsV2 **)
     * }
     */
    public static final long CreateCUDAProviderOptions$offset() {
        return CreateCUDAProviderOptions$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateCUDAProviderOptions)(OrtCUDAProviderOptionsV2 **)
     * }
     */
    public static MemorySegment CreateCUDAProviderOptions(MemorySegment struct) {
        return struct.get(CreateCUDAProviderOptions$LAYOUT, CreateCUDAProviderOptions$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateCUDAProviderOptions)(OrtCUDAProviderOptionsV2 **)
     * }
     */
    public static void CreateCUDAProviderOptions(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateCUDAProviderOptions$LAYOUT, CreateCUDAProviderOptions$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateCUDAProviderOptions)(OrtCUDAProviderOptionsV2 **)
     * }
     */
    public static CreateCUDAProviderOptions.Function CreateCUDAProviderOptionsFunction(MemorySegment struct) {
        return CreateCUDAProviderOptions.function(CreateCUDAProviderOptions(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateCUDAProviderOptions)(OrtCUDAProviderOptionsV2 *, const char *const *, const char *const *, size_t)
     * }
     */
    public static class UpdateCUDAProviderOptions {

        UpdateCUDAProviderOptions() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_LONG);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(UpdateCUDAProviderOptions.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(UpdateCUDAProviderOptions.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static UpdateCUDAProviderOptions.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2, _x3) -> invoke(funcPtr, _x0, _x1, _x2, _x3);
        }
    }

    private static final AddressLayout UpdateCUDAProviderOptions$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("UpdateCUDAProviderOptions"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateCUDAProviderOptions)(OrtCUDAProviderOptionsV2 *, const char *const *, const char *const *, size_t)
     * }
     */
    public static final AddressLayout UpdateCUDAProviderOptions$layout() {
        return UpdateCUDAProviderOptions$LAYOUT;
    }

    private static final long UpdateCUDAProviderOptions$OFFSET = 1648;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateCUDAProviderOptions)(OrtCUDAProviderOptionsV2 *, const char *const *, const char *const *, size_t)
     * }
     */
    public static final long UpdateCUDAProviderOptions$offset() {
        return UpdateCUDAProviderOptions$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateCUDAProviderOptions)(OrtCUDAProviderOptionsV2 *, const char *const *, const char *const *, size_t)
     * }
     */
    public static MemorySegment UpdateCUDAProviderOptions(MemorySegment struct) {
        return struct.get(UpdateCUDAProviderOptions$LAYOUT, UpdateCUDAProviderOptions$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateCUDAProviderOptions)(OrtCUDAProviderOptionsV2 *, const char *const *, const char *const *, size_t)
     * }
     */
    public static void UpdateCUDAProviderOptions(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(UpdateCUDAProviderOptions$LAYOUT, UpdateCUDAProviderOptions$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateCUDAProviderOptions)(OrtCUDAProviderOptionsV2 *, const char *const *, const char *const *, size_t)
     * }
     */
    public static UpdateCUDAProviderOptions.Function UpdateCUDAProviderOptionsFunction(MemorySegment struct) {
        return UpdateCUDAProviderOptions.function(UpdateCUDAProviderOptions(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetCUDAProviderOptionsAsString)(const OrtCUDAProviderOptionsV2 *, OrtAllocator *, char **)
     * }
     */
    public static class GetCUDAProviderOptionsAsString {

        GetCUDAProviderOptionsAsString() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(GetCUDAProviderOptionsAsString.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetCUDAProviderOptionsAsString.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static GetCUDAProviderOptionsAsString.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2) -> invoke(funcPtr, _x0, _x1, _x2);
        }
    }

    private static final AddressLayout GetCUDAProviderOptionsAsString$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("GetCUDAProviderOptionsAsString"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetCUDAProviderOptionsAsString)(const OrtCUDAProviderOptionsV2 *, OrtAllocator *, char **)
     * }
     */
    public static final AddressLayout GetCUDAProviderOptionsAsString$layout() {
        return GetCUDAProviderOptionsAsString$LAYOUT;
    }

    private static final long GetCUDAProviderOptionsAsString$OFFSET = 1656;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetCUDAProviderOptionsAsString)(const OrtCUDAProviderOptionsV2 *, OrtAllocator *, char **)
     * }
     */
    public static final long GetCUDAProviderOptionsAsString$offset() {
        return GetCUDAProviderOptionsAsString$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetCUDAProviderOptionsAsString)(const OrtCUDAProviderOptionsV2 *, OrtAllocator *, char **)
     * }
     */
    public static MemorySegment GetCUDAProviderOptionsAsString(MemorySegment struct) {
        return struct.get(GetCUDAProviderOptionsAsString$LAYOUT, GetCUDAProviderOptionsAsString$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetCUDAProviderOptionsAsString)(const OrtCUDAProviderOptionsV2 *, OrtAllocator *, char **)
     * }
     */
    public static void GetCUDAProviderOptionsAsString(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetCUDAProviderOptionsAsString$LAYOUT, GetCUDAProviderOptionsAsString$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetCUDAProviderOptionsAsString)(const OrtCUDAProviderOptionsV2 *, OrtAllocator *, char **)
     * }
     */
    public static GetCUDAProviderOptionsAsString.Function GetCUDAProviderOptionsAsStringFunction(MemorySegment struct) {
        return GetCUDAProviderOptionsAsString.function(GetCUDAProviderOptionsAsString(struct));
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseCUDAProviderOptions)(OrtCUDAProviderOptionsV2 *)
     * }
     */
    public static class ReleaseCUDAProviderOptions {

        ReleaseCUDAProviderOptions() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(ReleaseCUDAProviderOptions.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleaseCUDAProviderOptions.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static ReleaseCUDAProviderOptions.Function function(MemorySegment funcPtr) {
            return (_x0) -> invoke(funcPtr, _x0);
        }
    }

    private static final AddressLayout ReleaseCUDAProviderOptions$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("ReleaseCUDAProviderOptions"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ReleaseCUDAProviderOptions)(OrtCUDAProviderOptionsV2 *)
     * }
     */
    public static final AddressLayout ReleaseCUDAProviderOptions$layout() {
        return ReleaseCUDAProviderOptions$LAYOUT;
    }

    private static final long ReleaseCUDAProviderOptions$OFFSET = 1664;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ReleaseCUDAProviderOptions)(OrtCUDAProviderOptionsV2 *)
     * }
     */
    public static final long ReleaseCUDAProviderOptions$offset() {
        return ReleaseCUDAProviderOptions$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ReleaseCUDAProviderOptions)(OrtCUDAProviderOptionsV2 *)
     * }
     */
    public static MemorySegment ReleaseCUDAProviderOptions(MemorySegment struct) {
        return struct.get(ReleaseCUDAProviderOptions$LAYOUT, ReleaseCUDAProviderOptions$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ReleaseCUDAProviderOptions)(OrtCUDAProviderOptionsV2 *)
     * }
     */
    public static void ReleaseCUDAProviderOptions(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleaseCUDAProviderOptions$LAYOUT, ReleaseCUDAProviderOptions$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * void (*ReleaseCUDAProviderOptions)(OrtCUDAProviderOptionsV2 *)
     * }
     */
    public static ReleaseCUDAProviderOptions.Function ReleaseCUDAProviderOptionsFunction(MemorySegment struct) {
        return ReleaseCUDAProviderOptions.function(ReleaseCUDAProviderOptions(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_MIGraphX)(OrtSessionOptions *, const OrtMIGraphXProviderOptions *)
     * }
     */
    public static class SessionOptionsAppendExecutionProvider_MIGraphX {

        SessionOptionsAppendExecutionProvider_MIGraphX() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_all_h.upcallHandle(
                SessionOptionsAppendExecutionProvider_MIGraphX.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SessionOptionsAppendExecutionProvider_MIGraphX.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static SessionOptionsAppendExecutionProvider_MIGraphX.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout SessionOptionsAppendExecutionProvider_MIGraphX$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("SessionOptionsAppendExecutionProvider_MIGraphX"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_MIGraphX)(OrtSessionOptions *, const OrtMIGraphXProviderOptions *)
     * }
     */
    public static final AddressLayout SessionOptionsAppendExecutionProvider_MIGraphX$layout() {
        return SessionOptionsAppendExecutionProvider_MIGraphX$LAYOUT;
    }

    private static final long SessionOptionsAppendExecutionProvider_MIGraphX$OFFSET = 1672;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_MIGraphX)(OrtSessionOptions *, const OrtMIGraphXProviderOptions *)
     * }
     */
    public static final long SessionOptionsAppendExecutionProvider_MIGraphX$offset() {
        return SessionOptionsAppendExecutionProvider_MIGraphX$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_MIGraphX)(OrtSessionOptions *, const OrtMIGraphXProviderOptions *)
     * }
     */
    public static MemorySegment SessionOptionsAppendExecutionProvider_MIGraphX(MemorySegment struct) {
        return struct.get(
                SessionOptionsAppendExecutionProvider_MIGraphX$LAYOUT,
                SessionOptionsAppendExecutionProvider_MIGraphX$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_MIGraphX)(OrtSessionOptions *, const OrtMIGraphXProviderOptions *)
     * }
     */
    public static void SessionOptionsAppendExecutionProvider_MIGraphX(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(
                SessionOptionsAppendExecutionProvider_MIGraphX$LAYOUT,
                SessionOptionsAppendExecutionProvider_MIGraphX$OFFSET,
                fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_MIGraphX)(OrtSessionOptions *, const OrtMIGraphXProviderOptions *)
     * }
     */
    public static SessionOptionsAppendExecutionProvider_MIGraphX.Function
            SessionOptionsAppendExecutionProvider_MIGraphXFunction(MemorySegment struct) {
        return SessionOptionsAppendExecutionProvider_MIGraphX.function(
                SessionOptionsAppendExecutionProvider_MIGraphX(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*AddExternalInitializers)(OrtSessionOptions *, const char *const *, const OrtValue *const *, size_t)
     * }
     */
    public static class AddExternalInitializers {

        AddExternalInitializers() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_LONG);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(AddExternalInitializers.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(AddExternalInitializers.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static AddExternalInitializers.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2, _x3) -> invoke(funcPtr, _x0, _x1, _x2, _x3);
        }
    }

    private static final AddressLayout AddExternalInitializers$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("AddExternalInitializers"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddExternalInitializers)(OrtSessionOptions *, const char *const *, const OrtValue *const *, size_t)
     * }
     */
    public static final AddressLayout AddExternalInitializers$layout() {
        return AddExternalInitializers$LAYOUT;
    }

    private static final long AddExternalInitializers$OFFSET = 1680;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddExternalInitializers)(OrtSessionOptions *, const char *const *, const OrtValue *const *, size_t)
     * }
     */
    public static final long AddExternalInitializers$offset() {
        return AddExternalInitializers$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddExternalInitializers)(OrtSessionOptions *, const char *const *, const OrtValue *const *, size_t)
     * }
     */
    public static MemorySegment AddExternalInitializers(MemorySegment struct) {
        return struct.get(AddExternalInitializers$LAYOUT, AddExternalInitializers$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddExternalInitializers)(OrtSessionOptions *, const char *const *, const OrtValue *const *, size_t)
     * }
     */
    public static void AddExternalInitializers(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(AddExternalInitializers$LAYOUT, AddExternalInitializers$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddExternalInitializers)(OrtSessionOptions *, const char *const *, const OrtValue *const *, size_t)
     * }
     */
    public static AddExternalInitializers.Function AddExternalInitializersFunction(MemorySegment struct) {
        return AddExternalInitializers.function(AddExternalInitializers(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateOpAttr)(const char *, const void *, int, OrtOpAttrType, OrtOpAttr **)
     * }
     */
    public static class CreateOpAttr {

        CreateOpAttr() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_INT,
                onnxruntime_all_h.C_INT,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(CreateOpAttr.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateOpAttr.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, MemorySegment _x4) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static CreateOpAttr.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2, _x3, _x4) -> invoke(funcPtr, _x0, _x1, _x2, _x3, _x4);
        }
    }

    private static final AddressLayout CreateOpAttr$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("CreateOpAttr"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateOpAttr)(const char *, const void *, int, OrtOpAttrType, OrtOpAttr **)
     * }
     */
    public static final AddressLayout CreateOpAttr$layout() {
        return CreateOpAttr$LAYOUT;
    }

    private static final long CreateOpAttr$OFFSET = 1688;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateOpAttr)(const char *, const void *, int, OrtOpAttrType, OrtOpAttr **)
     * }
     */
    public static final long CreateOpAttr$offset() {
        return CreateOpAttr$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateOpAttr)(const char *, const void *, int, OrtOpAttrType, OrtOpAttr **)
     * }
     */
    public static MemorySegment CreateOpAttr(MemorySegment struct) {
        return struct.get(CreateOpAttr$LAYOUT, CreateOpAttr$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateOpAttr)(const char *, const void *, int, OrtOpAttrType, OrtOpAttr **)
     * }
     */
    public static void CreateOpAttr(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateOpAttr$LAYOUT, CreateOpAttr$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateOpAttr)(const char *, const void *, int, OrtOpAttrType, OrtOpAttr **)
     * }
     */
    public static CreateOpAttr.Function CreateOpAttrFunction(MemorySegment struct) {
        return CreateOpAttr.function(CreateOpAttr(struct));
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseOpAttr)(OrtOpAttr *)
     * }
     */
    public static class ReleaseOpAttr {

        ReleaseOpAttr() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(ReleaseOpAttr.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleaseOpAttr.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static ReleaseOpAttr.Function function(MemorySegment funcPtr) {
            return (_x0) -> invoke(funcPtr, _x0);
        }
    }

    private static final AddressLayout ReleaseOpAttr$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("ReleaseOpAttr"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ReleaseOpAttr)(OrtOpAttr *)
     * }
     */
    public static final AddressLayout ReleaseOpAttr$layout() {
        return ReleaseOpAttr$LAYOUT;
    }

    private static final long ReleaseOpAttr$OFFSET = 1696;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ReleaseOpAttr)(OrtOpAttr *)
     * }
     */
    public static final long ReleaseOpAttr$offset() {
        return ReleaseOpAttr$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ReleaseOpAttr)(OrtOpAttr *)
     * }
     */
    public static MemorySegment ReleaseOpAttr(MemorySegment struct) {
        return struct.get(ReleaseOpAttr$LAYOUT, ReleaseOpAttr$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ReleaseOpAttr)(OrtOpAttr *)
     * }
     */
    public static void ReleaseOpAttr(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleaseOpAttr$LAYOUT, ReleaseOpAttr$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * void (*ReleaseOpAttr)(OrtOpAttr *)
     * }
     */
    public static ReleaseOpAttr.Function ReleaseOpAttrFunction(MemorySegment struct) {
        return ReleaseOpAttr.function(ReleaseOpAttr(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateOp)(const OrtKernelInfo *, const char *, const char *, int, const char **, const ONNXTensorElementDataType *, int, const OrtOpAttr *const *, int, int, int, OrtOp **)
     * }
     */
    public static class CreateOp {

        CreateOp() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(
                    MemorySegment _x0,
                    MemorySegment _x1,
                    MemorySegment _x2,
                    int _x3,
                    MemorySegment _x4,
                    MemorySegment _x5,
                    int _x6,
                    MemorySegment _x7,
                    int _x8,
                    int _x9,
                    int _x10,
                    MemorySegment _x11);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_INT,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_INT,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_INT,
                onnxruntime_all_h.C_INT,
                onnxruntime_all_h.C_INT,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(CreateOp.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateOp.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr,
                MemorySegment _x0,
                MemorySegment _x1,
                MemorySegment _x2,
                int _x3,
                MemorySegment _x4,
                MemorySegment _x5,
                int _x6,
                MemorySegment _x7,
                int _x8,
                int _x9,
                int _x10,
                MemorySegment _x11) {
            try {
                return (MemorySegment)
                        DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7, _x8, _x9, _x10, _x11);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static CreateOp.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7, _x8, _x9, _x10, _x11) ->
                    invoke(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7, _x8, _x9, _x10, _x11);
        }
    }

    private static final AddressLayout CreateOp$LAYOUT = (AddressLayout) $LAYOUT.select(groupElement("CreateOp"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateOp)(const OrtKernelInfo *, const char *, const char *, int, const char **, const ONNXTensorElementDataType *, int, const OrtOpAttr *const *, int, int, int, OrtOp **)
     * }
     */
    public static final AddressLayout CreateOp$layout() {
        return CreateOp$LAYOUT;
    }

    private static final long CreateOp$OFFSET = 1704;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateOp)(const OrtKernelInfo *, const char *, const char *, int, const char **, const ONNXTensorElementDataType *, int, const OrtOpAttr *const *, int, int, int, OrtOp **)
     * }
     */
    public static final long CreateOp$offset() {
        return CreateOp$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateOp)(const OrtKernelInfo *, const char *, const char *, int, const char **, const ONNXTensorElementDataType *, int, const OrtOpAttr *const *, int, int, int, OrtOp **)
     * }
     */
    public static MemorySegment CreateOp(MemorySegment struct) {
        return struct.get(CreateOp$LAYOUT, CreateOp$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateOp)(const OrtKernelInfo *, const char *, const char *, int, const char **, const ONNXTensorElementDataType *, int, const OrtOpAttr *const *, int, int, int, OrtOp **)
     * }
     */
    public static void CreateOp(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateOp$LAYOUT, CreateOp$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateOp)(const OrtKernelInfo *, const char *, const char *, int, const char **, const ONNXTensorElementDataType *, int, const OrtOpAttr *const *, int, int, int, OrtOp **)
     * }
     */
    public static CreateOp.Function CreateOpFunction(MemorySegment struct) {
        return CreateOp.function(CreateOp(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*InvokeOp)(const OrtKernelContext *, const OrtOp *, const OrtValue *const *, int, OrtValue *const *, int)
     * }
     */
    public static class InvokeOp {

        InvokeOp() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(
                    MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, int _x3, MemorySegment _x4, int _x5);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_INT,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_INT);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(InvokeOp.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(InvokeOp.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr,
                MemorySegment _x0,
                MemorySegment _x1,
                MemorySegment _x2,
                int _x3,
                MemorySegment _x4,
                int _x5) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static InvokeOp.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2, _x3, _x4, _x5) -> invoke(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);
        }
    }

    private static final AddressLayout InvokeOp$LAYOUT = (AddressLayout) $LAYOUT.select(groupElement("InvokeOp"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*InvokeOp)(const OrtKernelContext *, const OrtOp *, const OrtValue *const *, int, OrtValue *const *, int)
     * }
     */
    public static final AddressLayout InvokeOp$layout() {
        return InvokeOp$LAYOUT;
    }

    private static final long InvokeOp$OFFSET = 1712;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*InvokeOp)(const OrtKernelContext *, const OrtOp *, const OrtValue *const *, int, OrtValue *const *, int)
     * }
     */
    public static final long InvokeOp$offset() {
        return InvokeOp$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*InvokeOp)(const OrtKernelContext *, const OrtOp *, const OrtValue *const *, int, OrtValue *const *, int)
     * }
     */
    public static MemorySegment InvokeOp(MemorySegment struct) {
        return struct.get(InvokeOp$LAYOUT, InvokeOp$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*InvokeOp)(const OrtKernelContext *, const OrtOp *, const OrtValue *const *, int, OrtValue *const *, int)
     * }
     */
    public static void InvokeOp(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(InvokeOp$LAYOUT, InvokeOp$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*InvokeOp)(const OrtKernelContext *, const OrtOp *, const OrtValue *const *, int, OrtValue *const *, int)
     * }
     */
    public static InvokeOp.Function InvokeOpFunction(MemorySegment struct) {
        return InvokeOp.function(InvokeOp(struct));
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseOp)(OrtOp *)
     * }
     */
    public static class ReleaseOp {

        ReleaseOp() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(ReleaseOp.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleaseOp.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static ReleaseOp.Function function(MemorySegment funcPtr) {
            return (_x0) -> invoke(funcPtr, _x0);
        }
    }

    private static final AddressLayout ReleaseOp$LAYOUT = (AddressLayout) $LAYOUT.select(groupElement("ReleaseOp"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ReleaseOp)(OrtOp *)
     * }
     */
    public static final AddressLayout ReleaseOp$layout() {
        return ReleaseOp$LAYOUT;
    }

    private static final long ReleaseOp$OFFSET = 1720;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ReleaseOp)(OrtOp *)
     * }
     */
    public static final long ReleaseOp$offset() {
        return ReleaseOp$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ReleaseOp)(OrtOp *)
     * }
     */
    public static MemorySegment ReleaseOp(MemorySegment struct) {
        return struct.get(ReleaseOp$LAYOUT, ReleaseOp$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ReleaseOp)(OrtOp *)
     * }
     */
    public static void ReleaseOp(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleaseOp$LAYOUT, ReleaseOp$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * void (*ReleaseOp)(OrtOp *)
     * }
     */
    public static ReleaseOp.Function ReleaseOpFunction(MemorySegment struct) {
        return ReleaseOp.function(ReleaseOp(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider)(OrtSessionOptions *, const char *, const char *const *, const char *const *, size_t)
     * }
     */
    public static class SessionOptionsAppendExecutionProvider {

        SessionOptionsAppendExecutionProvider() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, long _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_LONG);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(SessionOptionsAppendExecutionProvider.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SessionOptionsAppendExecutionProvider.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr,
                MemorySegment _x0,
                MemorySegment _x1,
                MemorySegment _x2,
                MemorySegment _x3,
                long _x4) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static SessionOptionsAppendExecutionProvider.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2, _x3, _x4) -> invoke(funcPtr, _x0, _x1, _x2, _x3, _x4);
        }
    }

    private static final AddressLayout SessionOptionsAppendExecutionProvider$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("SessionOptionsAppendExecutionProvider"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider)(OrtSessionOptions *, const char *, const char *const *, const char *const *, size_t)
     * }
     */
    public static final AddressLayout SessionOptionsAppendExecutionProvider$layout() {
        return SessionOptionsAppendExecutionProvider$LAYOUT;
    }

    private static final long SessionOptionsAppendExecutionProvider$OFFSET = 1728;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider)(OrtSessionOptions *, const char *, const char *const *, const char *const *, size_t)
     * }
     */
    public static final long SessionOptionsAppendExecutionProvider$offset() {
        return SessionOptionsAppendExecutionProvider$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider)(OrtSessionOptions *, const char *, const char *const *, const char *const *, size_t)
     * }
     */
    public static MemorySegment SessionOptionsAppendExecutionProvider(MemorySegment struct) {
        return struct.get(SessionOptionsAppendExecutionProvider$LAYOUT, SessionOptionsAppendExecutionProvider$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider)(OrtSessionOptions *, const char *, const char *const *, const char *const *, size_t)
     * }
     */
    public static void SessionOptionsAppendExecutionProvider(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(
                SessionOptionsAppendExecutionProvider$LAYOUT, SessionOptionsAppendExecutionProvider$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider)(OrtSessionOptions *, const char *, const char *const *, const char *const *, size_t)
     * }
     */
    public static SessionOptionsAppendExecutionProvider.Function SessionOptionsAppendExecutionProviderFunction(
            MemorySegment struct) {
        return SessionOptionsAppendExecutionProvider.function(SessionOptionsAppendExecutionProvider(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CopyKernelInfo)(const OrtKernelInfo *, OrtKernelInfo **)
     * }
     */
    public static class CopyKernelInfo {

        CopyKernelInfo() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(CopyKernelInfo.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CopyKernelInfo.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static CopyKernelInfo.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout CopyKernelInfo$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("CopyKernelInfo"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CopyKernelInfo)(const OrtKernelInfo *, OrtKernelInfo **)
     * }
     */
    public static final AddressLayout CopyKernelInfo$layout() {
        return CopyKernelInfo$LAYOUT;
    }

    private static final long CopyKernelInfo$OFFSET = 1736;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CopyKernelInfo)(const OrtKernelInfo *, OrtKernelInfo **)
     * }
     */
    public static final long CopyKernelInfo$offset() {
        return CopyKernelInfo$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CopyKernelInfo)(const OrtKernelInfo *, OrtKernelInfo **)
     * }
     */
    public static MemorySegment CopyKernelInfo(MemorySegment struct) {
        return struct.get(CopyKernelInfo$LAYOUT, CopyKernelInfo$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CopyKernelInfo)(const OrtKernelInfo *, OrtKernelInfo **)
     * }
     */
    public static void CopyKernelInfo(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CopyKernelInfo$LAYOUT, CopyKernelInfo$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CopyKernelInfo)(const OrtKernelInfo *, OrtKernelInfo **)
     * }
     */
    public static CopyKernelInfo.Function CopyKernelInfoFunction(MemorySegment struct) {
        return CopyKernelInfo.function(CopyKernelInfo(struct));
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseKernelInfo)(OrtKernelInfo *)
     * }
     */
    public static class ReleaseKernelInfo {

        ReleaseKernelInfo() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(ReleaseKernelInfo.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleaseKernelInfo.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static ReleaseKernelInfo.Function function(MemorySegment funcPtr) {
            return (_x0) -> invoke(funcPtr, _x0);
        }
    }

    private static final AddressLayout ReleaseKernelInfo$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("ReleaseKernelInfo"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ReleaseKernelInfo)(OrtKernelInfo *)
     * }
     */
    public static final AddressLayout ReleaseKernelInfo$layout() {
        return ReleaseKernelInfo$LAYOUT;
    }

    private static final long ReleaseKernelInfo$OFFSET = 1744;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ReleaseKernelInfo)(OrtKernelInfo *)
     * }
     */
    public static final long ReleaseKernelInfo$offset() {
        return ReleaseKernelInfo$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ReleaseKernelInfo)(OrtKernelInfo *)
     * }
     */
    public static MemorySegment ReleaseKernelInfo(MemorySegment struct) {
        return struct.get(ReleaseKernelInfo$LAYOUT, ReleaseKernelInfo$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ReleaseKernelInfo)(OrtKernelInfo *)
     * }
     */
    public static void ReleaseKernelInfo(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleaseKernelInfo$LAYOUT, ReleaseKernelInfo$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * void (*ReleaseKernelInfo)(OrtKernelInfo *)
     * }
     */
    public static ReleaseKernelInfo.Function ReleaseKernelInfoFunction(MemorySegment struct) {
        return ReleaseKernelInfo.function(ReleaseKernelInfo(struct));
    }

    /**
     * {@snippet lang=c :
     * const OrtTrainingApi *(*GetTrainingApi)(uint32_t)
     * }
     */
    public static class GetTrainingApi {

        GetTrainingApi() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(int _x0);
        }

        private static final FunctionDescriptor $DESC =
                FunctionDescriptor.of(onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_INT);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(GetTrainingApi.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetTrainingApi.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, int _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static GetTrainingApi.Function function(MemorySegment funcPtr) {
            return (_x0) -> invoke(funcPtr, _x0);
        }
    }

    private static final AddressLayout GetTrainingApi$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("GetTrainingApi"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * const OrtTrainingApi *(*GetTrainingApi)(uint32_t)
     * }
     */
    public static final AddressLayout GetTrainingApi$layout() {
        return GetTrainingApi$LAYOUT;
    }

    private static final long GetTrainingApi$OFFSET = 1752;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * const OrtTrainingApi *(*GetTrainingApi)(uint32_t)
     * }
     */
    public static final long GetTrainingApi$offset() {
        return GetTrainingApi$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * const OrtTrainingApi *(*GetTrainingApi)(uint32_t)
     * }
     */
    public static MemorySegment GetTrainingApi(MemorySegment struct) {
        return struct.get(GetTrainingApi$LAYOUT, GetTrainingApi$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * const OrtTrainingApi *(*GetTrainingApi)(uint32_t)
     * }
     */
    public static void GetTrainingApi(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetTrainingApi$LAYOUT, GetTrainingApi$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * const OrtTrainingApi *(*GetTrainingApi)(uint32_t)
     * }
     */
    public static GetTrainingApi.Function GetTrainingApiFunction(MemorySegment struct) {
        return GetTrainingApi.function(GetTrainingApi(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_CANN)(OrtSessionOptions *, const OrtCANNProviderOptions *)
     * }
     */
    public static class SessionOptionsAppendExecutionProvider_CANN {

        SessionOptionsAppendExecutionProvider_CANN() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_all_h.upcallHandle(
                SessionOptionsAppendExecutionProvider_CANN.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SessionOptionsAppendExecutionProvider_CANN.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static SessionOptionsAppendExecutionProvider_CANN.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout SessionOptionsAppendExecutionProvider_CANN$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("SessionOptionsAppendExecutionProvider_CANN"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_CANN)(OrtSessionOptions *, const OrtCANNProviderOptions *)
     * }
     */
    public static final AddressLayout SessionOptionsAppendExecutionProvider_CANN$layout() {
        return SessionOptionsAppendExecutionProvider_CANN$LAYOUT;
    }

    private static final long SessionOptionsAppendExecutionProvider_CANN$OFFSET = 1760;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_CANN)(OrtSessionOptions *, const OrtCANNProviderOptions *)
     * }
     */
    public static final long SessionOptionsAppendExecutionProvider_CANN$offset() {
        return SessionOptionsAppendExecutionProvider_CANN$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_CANN)(OrtSessionOptions *, const OrtCANNProviderOptions *)
     * }
     */
    public static MemorySegment SessionOptionsAppendExecutionProvider_CANN(MemorySegment struct) {
        return struct.get(
                SessionOptionsAppendExecutionProvider_CANN$LAYOUT, SessionOptionsAppendExecutionProvider_CANN$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_CANN)(OrtSessionOptions *, const OrtCANNProviderOptions *)
     * }
     */
    public static void SessionOptionsAppendExecutionProvider_CANN(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(
                SessionOptionsAppendExecutionProvider_CANN$LAYOUT,
                SessionOptionsAppendExecutionProvider_CANN$OFFSET,
                fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_CANN)(OrtSessionOptions *, const OrtCANNProviderOptions *)
     * }
     */
    public static SessionOptionsAppendExecutionProvider_CANN.Function
            SessionOptionsAppendExecutionProvider_CANNFunction(MemorySegment struct) {
        return SessionOptionsAppendExecutionProvider_CANN.function(SessionOptionsAppendExecutionProvider_CANN(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateCANNProviderOptions)(OrtCANNProviderOptions **)
     * }
     */
    public static class CreateCANNProviderOptions {

        CreateCANNProviderOptions() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC =
                FunctionDescriptor.of(onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(CreateCANNProviderOptions.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateCANNProviderOptions.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static CreateCANNProviderOptions.Function function(MemorySegment funcPtr) {
            return (_x0) -> invoke(funcPtr, _x0);
        }
    }

    private static final AddressLayout CreateCANNProviderOptions$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("CreateCANNProviderOptions"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateCANNProviderOptions)(OrtCANNProviderOptions **)
     * }
     */
    public static final AddressLayout CreateCANNProviderOptions$layout() {
        return CreateCANNProviderOptions$LAYOUT;
    }

    private static final long CreateCANNProviderOptions$OFFSET = 1768;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateCANNProviderOptions)(OrtCANNProviderOptions **)
     * }
     */
    public static final long CreateCANNProviderOptions$offset() {
        return CreateCANNProviderOptions$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateCANNProviderOptions)(OrtCANNProviderOptions **)
     * }
     */
    public static MemorySegment CreateCANNProviderOptions(MemorySegment struct) {
        return struct.get(CreateCANNProviderOptions$LAYOUT, CreateCANNProviderOptions$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateCANNProviderOptions)(OrtCANNProviderOptions **)
     * }
     */
    public static void CreateCANNProviderOptions(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateCANNProviderOptions$LAYOUT, CreateCANNProviderOptions$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateCANNProviderOptions)(OrtCANNProviderOptions **)
     * }
     */
    public static CreateCANNProviderOptions.Function CreateCANNProviderOptionsFunction(MemorySegment struct) {
        return CreateCANNProviderOptions.function(CreateCANNProviderOptions(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateCANNProviderOptions)(OrtCANNProviderOptions *, const char *const *, const char *const *, size_t)
     * }
     */
    public static class UpdateCANNProviderOptions {

        UpdateCANNProviderOptions() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_LONG);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(UpdateCANNProviderOptions.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(UpdateCANNProviderOptions.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static UpdateCANNProviderOptions.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2, _x3) -> invoke(funcPtr, _x0, _x1, _x2, _x3);
        }
    }

    private static final AddressLayout UpdateCANNProviderOptions$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("UpdateCANNProviderOptions"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateCANNProviderOptions)(OrtCANNProviderOptions *, const char *const *, const char *const *, size_t)
     * }
     */
    public static final AddressLayout UpdateCANNProviderOptions$layout() {
        return UpdateCANNProviderOptions$LAYOUT;
    }

    private static final long UpdateCANNProviderOptions$OFFSET = 1776;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateCANNProviderOptions)(OrtCANNProviderOptions *, const char *const *, const char *const *, size_t)
     * }
     */
    public static final long UpdateCANNProviderOptions$offset() {
        return UpdateCANNProviderOptions$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateCANNProviderOptions)(OrtCANNProviderOptions *, const char *const *, const char *const *, size_t)
     * }
     */
    public static MemorySegment UpdateCANNProviderOptions(MemorySegment struct) {
        return struct.get(UpdateCANNProviderOptions$LAYOUT, UpdateCANNProviderOptions$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateCANNProviderOptions)(OrtCANNProviderOptions *, const char *const *, const char *const *, size_t)
     * }
     */
    public static void UpdateCANNProviderOptions(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(UpdateCANNProviderOptions$LAYOUT, UpdateCANNProviderOptions$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateCANNProviderOptions)(OrtCANNProviderOptions *, const char *const *, const char *const *, size_t)
     * }
     */
    public static UpdateCANNProviderOptions.Function UpdateCANNProviderOptionsFunction(MemorySegment struct) {
        return UpdateCANNProviderOptions.function(UpdateCANNProviderOptions(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetCANNProviderOptionsAsString)(const OrtCANNProviderOptions *, OrtAllocator *, char **)
     * }
     */
    public static class GetCANNProviderOptionsAsString {

        GetCANNProviderOptionsAsString() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(GetCANNProviderOptionsAsString.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetCANNProviderOptionsAsString.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static GetCANNProviderOptionsAsString.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2) -> invoke(funcPtr, _x0, _x1, _x2);
        }
    }

    private static final AddressLayout GetCANNProviderOptionsAsString$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("GetCANNProviderOptionsAsString"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetCANNProviderOptionsAsString)(const OrtCANNProviderOptions *, OrtAllocator *, char **)
     * }
     */
    public static final AddressLayout GetCANNProviderOptionsAsString$layout() {
        return GetCANNProviderOptionsAsString$LAYOUT;
    }

    private static final long GetCANNProviderOptionsAsString$OFFSET = 1784;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetCANNProviderOptionsAsString)(const OrtCANNProviderOptions *, OrtAllocator *, char **)
     * }
     */
    public static final long GetCANNProviderOptionsAsString$offset() {
        return GetCANNProviderOptionsAsString$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetCANNProviderOptionsAsString)(const OrtCANNProviderOptions *, OrtAllocator *, char **)
     * }
     */
    public static MemorySegment GetCANNProviderOptionsAsString(MemorySegment struct) {
        return struct.get(GetCANNProviderOptionsAsString$LAYOUT, GetCANNProviderOptionsAsString$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetCANNProviderOptionsAsString)(const OrtCANNProviderOptions *, OrtAllocator *, char **)
     * }
     */
    public static void GetCANNProviderOptionsAsString(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetCANNProviderOptionsAsString$LAYOUT, GetCANNProviderOptionsAsString$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetCANNProviderOptionsAsString)(const OrtCANNProviderOptions *, OrtAllocator *, char **)
     * }
     */
    public static GetCANNProviderOptionsAsString.Function GetCANNProviderOptionsAsStringFunction(MemorySegment struct) {
        return GetCANNProviderOptionsAsString.function(GetCANNProviderOptionsAsString(struct));
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseCANNProviderOptions)(OrtCANNProviderOptions *)
     * }
     */
    public static class ReleaseCANNProviderOptions {

        ReleaseCANNProviderOptions() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(ReleaseCANNProviderOptions.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleaseCANNProviderOptions.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static ReleaseCANNProviderOptions.Function function(MemorySegment funcPtr) {
            return (_x0) -> invoke(funcPtr, _x0);
        }
    }

    private static final AddressLayout ReleaseCANNProviderOptions$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("ReleaseCANNProviderOptions"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ReleaseCANNProviderOptions)(OrtCANNProviderOptions *)
     * }
     */
    public static final AddressLayout ReleaseCANNProviderOptions$layout() {
        return ReleaseCANNProviderOptions$LAYOUT;
    }

    private static final long ReleaseCANNProviderOptions$OFFSET = 1792;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ReleaseCANNProviderOptions)(OrtCANNProviderOptions *)
     * }
     */
    public static final long ReleaseCANNProviderOptions$offset() {
        return ReleaseCANNProviderOptions$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ReleaseCANNProviderOptions)(OrtCANNProviderOptions *)
     * }
     */
    public static MemorySegment ReleaseCANNProviderOptions(MemorySegment struct) {
        return struct.get(ReleaseCANNProviderOptions$LAYOUT, ReleaseCANNProviderOptions$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ReleaseCANNProviderOptions)(OrtCANNProviderOptions *)
     * }
     */
    public static void ReleaseCANNProviderOptions(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleaseCANNProviderOptions$LAYOUT, ReleaseCANNProviderOptions$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * void (*ReleaseCANNProviderOptions)(OrtCANNProviderOptions *)
     * }
     */
    public static ReleaseCANNProviderOptions.Function ReleaseCANNProviderOptionsFunction(MemorySegment struct) {
        return ReleaseCANNProviderOptions.function(ReleaseCANNProviderOptions(struct));
    }

    /**
     * {@snippet lang=c :
     * void (*MemoryInfoGetDeviceType)(const OrtMemoryInfo *, OrtMemoryInfoDeviceType *)
     * }
     */
    public static class MemoryInfoGetDeviceType {

        MemoryInfoGetDeviceType() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC =
                FunctionDescriptor.ofVoid(onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(MemoryInfoGetDeviceType.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(MemoryInfoGetDeviceType.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static MemoryInfoGetDeviceType.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout MemoryInfoGetDeviceType$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("MemoryInfoGetDeviceType"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*MemoryInfoGetDeviceType)(const OrtMemoryInfo *, OrtMemoryInfoDeviceType *)
     * }
     */
    public static final AddressLayout MemoryInfoGetDeviceType$layout() {
        return MemoryInfoGetDeviceType$LAYOUT;
    }

    private static final long MemoryInfoGetDeviceType$OFFSET = 1800;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*MemoryInfoGetDeviceType)(const OrtMemoryInfo *, OrtMemoryInfoDeviceType *)
     * }
     */
    public static final long MemoryInfoGetDeviceType$offset() {
        return MemoryInfoGetDeviceType$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*MemoryInfoGetDeviceType)(const OrtMemoryInfo *, OrtMemoryInfoDeviceType *)
     * }
     */
    public static MemorySegment MemoryInfoGetDeviceType(MemorySegment struct) {
        return struct.get(MemoryInfoGetDeviceType$LAYOUT, MemoryInfoGetDeviceType$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*MemoryInfoGetDeviceType)(const OrtMemoryInfo *, OrtMemoryInfoDeviceType *)
     * }
     */
    public static void MemoryInfoGetDeviceType(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(MemoryInfoGetDeviceType$LAYOUT, MemoryInfoGetDeviceType$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * void (*MemoryInfoGetDeviceType)(const OrtMemoryInfo *, OrtMemoryInfoDeviceType *)
     * }
     */
    public static MemoryInfoGetDeviceType.Function MemoryInfoGetDeviceTypeFunction(MemorySegment struct) {
        return MemoryInfoGetDeviceType.function(MemoryInfoGetDeviceType(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateEnvWithCustomLogLevel)(OrtEnv *, OrtLoggingLevel)
     * }
     */
    public static class UpdateEnvWithCustomLogLevel {

        UpdateEnvWithCustomLogLevel() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, int _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_INT);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(UpdateEnvWithCustomLogLevel.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(UpdateEnvWithCustomLogLevel.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, int _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static UpdateEnvWithCustomLogLevel.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout UpdateEnvWithCustomLogLevel$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("UpdateEnvWithCustomLogLevel"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateEnvWithCustomLogLevel)(OrtEnv *, OrtLoggingLevel)
     * }
     */
    public static final AddressLayout UpdateEnvWithCustomLogLevel$layout() {
        return UpdateEnvWithCustomLogLevel$LAYOUT;
    }

    private static final long UpdateEnvWithCustomLogLevel$OFFSET = 1808;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateEnvWithCustomLogLevel)(OrtEnv *, OrtLoggingLevel)
     * }
     */
    public static final long UpdateEnvWithCustomLogLevel$offset() {
        return UpdateEnvWithCustomLogLevel$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateEnvWithCustomLogLevel)(OrtEnv *, OrtLoggingLevel)
     * }
     */
    public static MemorySegment UpdateEnvWithCustomLogLevel(MemorySegment struct) {
        return struct.get(UpdateEnvWithCustomLogLevel$LAYOUT, UpdateEnvWithCustomLogLevel$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateEnvWithCustomLogLevel)(OrtEnv *, OrtLoggingLevel)
     * }
     */
    public static void UpdateEnvWithCustomLogLevel(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(UpdateEnvWithCustomLogLevel$LAYOUT, UpdateEnvWithCustomLogLevel$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateEnvWithCustomLogLevel)(OrtEnv *, OrtLoggingLevel)
     * }
     */
    public static UpdateEnvWithCustomLogLevel.Function UpdateEnvWithCustomLogLevelFunction(MemorySegment struct) {
        return UpdateEnvWithCustomLogLevel.function(UpdateEnvWithCustomLogLevel(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalIntraOpThreadAffinity)(OrtThreadingOptions *, const char *)
     * }
     */
    public static class SetGlobalIntraOpThreadAffinity {

        SetGlobalIntraOpThreadAffinity() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(SetGlobalIntraOpThreadAffinity.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetGlobalIntraOpThreadAffinity.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static SetGlobalIntraOpThreadAffinity.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout SetGlobalIntraOpThreadAffinity$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("SetGlobalIntraOpThreadAffinity"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalIntraOpThreadAffinity)(OrtThreadingOptions *, const char *)
     * }
     */
    public static final AddressLayout SetGlobalIntraOpThreadAffinity$layout() {
        return SetGlobalIntraOpThreadAffinity$LAYOUT;
    }

    private static final long SetGlobalIntraOpThreadAffinity$OFFSET = 1816;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalIntraOpThreadAffinity)(OrtThreadingOptions *, const char *)
     * }
     */
    public static final long SetGlobalIntraOpThreadAffinity$offset() {
        return SetGlobalIntraOpThreadAffinity$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalIntraOpThreadAffinity)(OrtThreadingOptions *, const char *)
     * }
     */
    public static MemorySegment SetGlobalIntraOpThreadAffinity(MemorySegment struct) {
        return struct.get(SetGlobalIntraOpThreadAffinity$LAYOUT, SetGlobalIntraOpThreadAffinity$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalIntraOpThreadAffinity)(OrtThreadingOptions *, const char *)
     * }
     */
    public static void SetGlobalIntraOpThreadAffinity(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetGlobalIntraOpThreadAffinity$LAYOUT, SetGlobalIntraOpThreadAffinity$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetGlobalIntraOpThreadAffinity)(OrtThreadingOptions *, const char *)
     * }
     */
    public static SetGlobalIntraOpThreadAffinity.Function SetGlobalIntraOpThreadAffinityFunction(MemorySegment struct) {
        return SetGlobalIntraOpThreadAffinity.function(SetGlobalIntraOpThreadAffinity(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*RegisterCustomOpsLibrary_V2)(OrtSessionOptions *, const char *)
     * }
     */
    public static class RegisterCustomOpsLibrary_V2 {

        RegisterCustomOpsLibrary_V2() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(RegisterCustomOpsLibrary_V2.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(RegisterCustomOpsLibrary_V2.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static RegisterCustomOpsLibrary_V2.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout RegisterCustomOpsLibrary_V2$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("RegisterCustomOpsLibrary_V2"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RegisterCustomOpsLibrary_V2)(OrtSessionOptions *, const char *)
     * }
     */
    public static final AddressLayout RegisterCustomOpsLibrary_V2$layout() {
        return RegisterCustomOpsLibrary_V2$LAYOUT;
    }

    private static final long RegisterCustomOpsLibrary_V2$OFFSET = 1824;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RegisterCustomOpsLibrary_V2)(OrtSessionOptions *, const char *)
     * }
     */
    public static final long RegisterCustomOpsLibrary_V2$offset() {
        return RegisterCustomOpsLibrary_V2$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RegisterCustomOpsLibrary_V2)(OrtSessionOptions *, const char *)
     * }
     */
    public static MemorySegment RegisterCustomOpsLibrary_V2(MemorySegment struct) {
        return struct.get(RegisterCustomOpsLibrary_V2$LAYOUT, RegisterCustomOpsLibrary_V2$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RegisterCustomOpsLibrary_V2)(OrtSessionOptions *, const char *)
     * }
     */
    public static void RegisterCustomOpsLibrary_V2(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(RegisterCustomOpsLibrary_V2$LAYOUT, RegisterCustomOpsLibrary_V2$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RegisterCustomOpsLibrary_V2)(OrtSessionOptions *, const char *)
     * }
     */
    public static RegisterCustomOpsLibrary_V2.Function RegisterCustomOpsLibrary_V2Function(MemorySegment struct) {
        return RegisterCustomOpsLibrary_V2.function(RegisterCustomOpsLibrary_V2(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*RegisterCustomOpsUsingFunction)(OrtSessionOptions *, const char *)
     * }
     */
    public static class RegisterCustomOpsUsingFunction {

        RegisterCustomOpsUsingFunction() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(RegisterCustomOpsUsingFunction.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(RegisterCustomOpsUsingFunction.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static RegisterCustomOpsUsingFunction.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout RegisterCustomOpsUsingFunction$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("RegisterCustomOpsUsingFunction"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RegisterCustomOpsUsingFunction)(OrtSessionOptions *, const char *)
     * }
     */
    public static final AddressLayout RegisterCustomOpsUsingFunction$layout() {
        return RegisterCustomOpsUsingFunction$LAYOUT;
    }

    private static final long RegisterCustomOpsUsingFunction$OFFSET = 1832;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RegisterCustomOpsUsingFunction)(OrtSessionOptions *, const char *)
     * }
     */
    public static final long RegisterCustomOpsUsingFunction$offset() {
        return RegisterCustomOpsUsingFunction$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RegisterCustomOpsUsingFunction)(OrtSessionOptions *, const char *)
     * }
     */
    public static MemorySegment RegisterCustomOpsUsingFunction(MemorySegment struct) {
        return struct.get(RegisterCustomOpsUsingFunction$LAYOUT, RegisterCustomOpsUsingFunction$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RegisterCustomOpsUsingFunction)(OrtSessionOptions *, const char *)
     * }
     */
    public static void RegisterCustomOpsUsingFunction(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(RegisterCustomOpsUsingFunction$LAYOUT, RegisterCustomOpsUsingFunction$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RegisterCustomOpsUsingFunction)(OrtSessionOptions *, const char *)
     * }
     */
    public static RegisterCustomOpsUsingFunction.Function RegisterCustomOpsUsingFunctionFunction(MemorySegment struct) {
        return RegisterCustomOpsUsingFunction.function(RegisterCustomOpsUsingFunction(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetInputCount)(const OrtKernelInfo *, size_t *)
     * }
     */
    public static class KernelInfo_GetInputCount {

        KernelInfo_GetInputCount() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(KernelInfo_GetInputCount.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(KernelInfo_GetInputCount.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static KernelInfo_GetInputCount.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout KernelInfo_GetInputCount$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("KernelInfo_GetInputCount"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetInputCount)(const OrtKernelInfo *, size_t *)
     * }
     */
    public static final AddressLayout KernelInfo_GetInputCount$layout() {
        return KernelInfo_GetInputCount$LAYOUT;
    }

    private static final long KernelInfo_GetInputCount$OFFSET = 1840;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetInputCount)(const OrtKernelInfo *, size_t *)
     * }
     */
    public static final long KernelInfo_GetInputCount$offset() {
        return KernelInfo_GetInputCount$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetInputCount)(const OrtKernelInfo *, size_t *)
     * }
     */
    public static MemorySegment KernelInfo_GetInputCount(MemorySegment struct) {
        return struct.get(KernelInfo_GetInputCount$LAYOUT, KernelInfo_GetInputCount$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetInputCount)(const OrtKernelInfo *, size_t *)
     * }
     */
    public static void KernelInfo_GetInputCount(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(KernelInfo_GetInputCount$LAYOUT, KernelInfo_GetInputCount$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetInputCount)(const OrtKernelInfo *, size_t *)
     * }
     */
    public static KernelInfo_GetInputCount.Function KernelInfo_GetInputCountFunction(MemorySegment struct) {
        return KernelInfo_GetInputCount.function(KernelInfo_GetInputCount(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetOutputCount)(const OrtKernelInfo *, size_t *)
     * }
     */
    public static class KernelInfo_GetOutputCount {

        KernelInfo_GetOutputCount() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(KernelInfo_GetOutputCount.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(KernelInfo_GetOutputCount.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static KernelInfo_GetOutputCount.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout KernelInfo_GetOutputCount$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("KernelInfo_GetOutputCount"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetOutputCount)(const OrtKernelInfo *, size_t *)
     * }
     */
    public static final AddressLayout KernelInfo_GetOutputCount$layout() {
        return KernelInfo_GetOutputCount$LAYOUT;
    }

    private static final long KernelInfo_GetOutputCount$OFFSET = 1848;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetOutputCount)(const OrtKernelInfo *, size_t *)
     * }
     */
    public static final long KernelInfo_GetOutputCount$offset() {
        return KernelInfo_GetOutputCount$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetOutputCount)(const OrtKernelInfo *, size_t *)
     * }
     */
    public static MemorySegment KernelInfo_GetOutputCount(MemorySegment struct) {
        return struct.get(KernelInfo_GetOutputCount$LAYOUT, KernelInfo_GetOutputCount$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetOutputCount)(const OrtKernelInfo *, size_t *)
     * }
     */
    public static void KernelInfo_GetOutputCount(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(KernelInfo_GetOutputCount$LAYOUT, KernelInfo_GetOutputCount$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetOutputCount)(const OrtKernelInfo *, size_t *)
     * }
     */
    public static KernelInfo_GetOutputCount.Function KernelInfo_GetOutputCountFunction(MemorySegment struct) {
        return KernelInfo_GetOutputCount.function(KernelInfo_GetOutputCount(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetInputName)(const OrtKernelInfo *, size_t, char *, size_t *)
     * }
     */
    public static class KernelInfo_GetInputName {

        KernelInfo_GetInputName() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_LONG,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(KernelInfo_GetInputName.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(KernelInfo_GetInputName.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr, MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static KernelInfo_GetInputName.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2, _x3) -> invoke(funcPtr, _x0, _x1, _x2, _x3);
        }
    }

    private static final AddressLayout KernelInfo_GetInputName$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("KernelInfo_GetInputName"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetInputName)(const OrtKernelInfo *, size_t, char *, size_t *)
     * }
     */
    public static final AddressLayout KernelInfo_GetInputName$layout() {
        return KernelInfo_GetInputName$LAYOUT;
    }

    private static final long KernelInfo_GetInputName$OFFSET = 1856;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetInputName)(const OrtKernelInfo *, size_t, char *, size_t *)
     * }
     */
    public static final long KernelInfo_GetInputName$offset() {
        return KernelInfo_GetInputName$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetInputName)(const OrtKernelInfo *, size_t, char *, size_t *)
     * }
     */
    public static MemorySegment KernelInfo_GetInputName(MemorySegment struct) {
        return struct.get(KernelInfo_GetInputName$LAYOUT, KernelInfo_GetInputName$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetInputName)(const OrtKernelInfo *, size_t, char *, size_t *)
     * }
     */
    public static void KernelInfo_GetInputName(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(KernelInfo_GetInputName$LAYOUT, KernelInfo_GetInputName$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetInputName)(const OrtKernelInfo *, size_t, char *, size_t *)
     * }
     */
    public static KernelInfo_GetInputName.Function KernelInfo_GetInputNameFunction(MemorySegment struct) {
        return KernelInfo_GetInputName.function(KernelInfo_GetInputName(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetOutputName)(const OrtKernelInfo *, size_t, char *, size_t *)
     * }
     */
    public static class KernelInfo_GetOutputName {

        KernelInfo_GetOutputName() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_LONG,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(KernelInfo_GetOutputName.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(KernelInfo_GetOutputName.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr, MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static KernelInfo_GetOutputName.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2, _x3) -> invoke(funcPtr, _x0, _x1, _x2, _x3);
        }
    }

    private static final AddressLayout KernelInfo_GetOutputName$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("KernelInfo_GetOutputName"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetOutputName)(const OrtKernelInfo *, size_t, char *, size_t *)
     * }
     */
    public static final AddressLayout KernelInfo_GetOutputName$layout() {
        return KernelInfo_GetOutputName$LAYOUT;
    }

    private static final long KernelInfo_GetOutputName$OFFSET = 1864;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetOutputName)(const OrtKernelInfo *, size_t, char *, size_t *)
     * }
     */
    public static final long KernelInfo_GetOutputName$offset() {
        return KernelInfo_GetOutputName$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetOutputName)(const OrtKernelInfo *, size_t, char *, size_t *)
     * }
     */
    public static MemorySegment KernelInfo_GetOutputName(MemorySegment struct) {
        return struct.get(KernelInfo_GetOutputName$LAYOUT, KernelInfo_GetOutputName$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetOutputName)(const OrtKernelInfo *, size_t, char *, size_t *)
     * }
     */
    public static void KernelInfo_GetOutputName(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(KernelInfo_GetOutputName$LAYOUT, KernelInfo_GetOutputName$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetOutputName)(const OrtKernelInfo *, size_t, char *, size_t *)
     * }
     */
    public static KernelInfo_GetOutputName.Function KernelInfo_GetOutputNameFunction(MemorySegment struct) {
        return KernelInfo_GetOutputName.function(KernelInfo_GetOutputName(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetInputTypeInfo)(const OrtKernelInfo *, size_t, OrtTypeInfo **)
     * }
     */
    public static class KernelInfo_GetInputTypeInfo {

        KernelInfo_GetInputTypeInfo() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, long _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_LONG,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(KernelInfo_GetInputTypeInfo.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(KernelInfo_GetInputTypeInfo.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, long _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static KernelInfo_GetInputTypeInfo.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2) -> invoke(funcPtr, _x0, _x1, _x2);
        }
    }

    private static final AddressLayout KernelInfo_GetInputTypeInfo$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("KernelInfo_GetInputTypeInfo"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetInputTypeInfo)(const OrtKernelInfo *, size_t, OrtTypeInfo **)
     * }
     */
    public static final AddressLayout KernelInfo_GetInputTypeInfo$layout() {
        return KernelInfo_GetInputTypeInfo$LAYOUT;
    }

    private static final long KernelInfo_GetInputTypeInfo$OFFSET = 1872;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetInputTypeInfo)(const OrtKernelInfo *, size_t, OrtTypeInfo **)
     * }
     */
    public static final long KernelInfo_GetInputTypeInfo$offset() {
        return KernelInfo_GetInputTypeInfo$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetInputTypeInfo)(const OrtKernelInfo *, size_t, OrtTypeInfo **)
     * }
     */
    public static MemorySegment KernelInfo_GetInputTypeInfo(MemorySegment struct) {
        return struct.get(KernelInfo_GetInputTypeInfo$LAYOUT, KernelInfo_GetInputTypeInfo$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetInputTypeInfo)(const OrtKernelInfo *, size_t, OrtTypeInfo **)
     * }
     */
    public static void KernelInfo_GetInputTypeInfo(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(KernelInfo_GetInputTypeInfo$LAYOUT, KernelInfo_GetInputTypeInfo$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetInputTypeInfo)(const OrtKernelInfo *, size_t, OrtTypeInfo **)
     * }
     */
    public static KernelInfo_GetInputTypeInfo.Function KernelInfo_GetInputTypeInfoFunction(MemorySegment struct) {
        return KernelInfo_GetInputTypeInfo.function(KernelInfo_GetInputTypeInfo(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetOutputTypeInfo)(const OrtKernelInfo *, size_t, OrtTypeInfo **)
     * }
     */
    public static class KernelInfo_GetOutputTypeInfo {

        KernelInfo_GetOutputTypeInfo() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, long _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_LONG,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(KernelInfo_GetOutputTypeInfo.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(KernelInfo_GetOutputTypeInfo.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, long _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static KernelInfo_GetOutputTypeInfo.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2) -> invoke(funcPtr, _x0, _x1, _x2);
        }
    }

    private static final AddressLayout KernelInfo_GetOutputTypeInfo$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("KernelInfo_GetOutputTypeInfo"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetOutputTypeInfo)(const OrtKernelInfo *, size_t, OrtTypeInfo **)
     * }
     */
    public static final AddressLayout KernelInfo_GetOutputTypeInfo$layout() {
        return KernelInfo_GetOutputTypeInfo$LAYOUT;
    }

    private static final long KernelInfo_GetOutputTypeInfo$OFFSET = 1880;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetOutputTypeInfo)(const OrtKernelInfo *, size_t, OrtTypeInfo **)
     * }
     */
    public static final long KernelInfo_GetOutputTypeInfo$offset() {
        return KernelInfo_GetOutputTypeInfo$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetOutputTypeInfo)(const OrtKernelInfo *, size_t, OrtTypeInfo **)
     * }
     */
    public static MemorySegment KernelInfo_GetOutputTypeInfo(MemorySegment struct) {
        return struct.get(KernelInfo_GetOutputTypeInfo$LAYOUT, KernelInfo_GetOutputTypeInfo$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetOutputTypeInfo)(const OrtKernelInfo *, size_t, OrtTypeInfo **)
     * }
     */
    public static void KernelInfo_GetOutputTypeInfo(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(KernelInfo_GetOutputTypeInfo$LAYOUT, KernelInfo_GetOutputTypeInfo$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetOutputTypeInfo)(const OrtKernelInfo *, size_t, OrtTypeInfo **)
     * }
     */
    public static KernelInfo_GetOutputTypeInfo.Function KernelInfo_GetOutputTypeInfoFunction(MemorySegment struct) {
        return KernelInfo_GetOutputTypeInfo.function(KernelInfo_GetOutputTypeInfo(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAttribute_tensor)(const OrtKernelInfo *, const char *, OrtAllocator *, OrtValue **)
     * }
     */
    public static class KernelInfoGetAttribute_tensor {

        KernelInfoGetAttribute_tensor() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(KernelInfoGetAttribute_tensor.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(KernelInfoGetAttribute_tensor.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static KernelInfoGetAttribute_tensor.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2, _x3) -> invoke(funcPtr, _x0, _x1, _x2, _x3);
        }
    }

    private static final AddressLayout KernelInfoGetAttribute_tensor$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("KernelInfoGetAttribute_tensor"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAttribute_tensor)(const OrtKernelInfo *, const char *, OrtAllocator *, OrtValue **)
     * }
     */
    public static final AddressLayout KernelInfoGetAttribute_tensor$layout() {
        return KernelInfoGetAttribute_tensor$LAYOUT;
    }

    private static final long KernelInfoGetAttribute_tensor$OFFSET = 1888;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAttribute_tensor)(const OrtKernelInfo *, const char *, OrtAllocator *, OrtValue **)
     * }
     */
    public static final long KernelInfoGetAttribute_tensor$offset() {
        return KernelInfoGetAttribute_tensor$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAttribute_tensor)(const OrtKernelInfo *, const char *, OrtAllocator *, OrtValue **)
     * }
     */
    public static MemorySegment KernelInfoGetAttribute_tensor(MemorySegment struct) {
        return struct.get(KernelInfoGetAttribute_tensor$LAYOUT, KernelInfoGetAttribute_tensor$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAttribute_tensor)(const OrtKernelInfo *, const char *, OrtAllocator *, OrtValue **)
     * }
     */
    public static void KernelInfoGetAttribute_tensor(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(KernelInfoGetAttribute_tensor$LAYOUT, KernelInfoGetAttribute_tensor$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAttribute_tensor)(const OrtKernelInfo *, const char *, OrtAllocator *, OrtValue **)
     * }
     */
    public static KernelInfoGetAttribute_tensor.Function KernelInfoGetAttribute_tensorFunction(MemorySegment struct) {
        return KernelInfoGetAttribute_tensor.function(KernelInfoGetAttribute_tensor(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*HasSessionConfigEntry)(const OrtSessionOptions *, const char *, int *)
     * }
     */
    public static class HasSessionConfigEntry {

        HasSessionConfigEntry() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(HasSessionConfigEntry.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(HasSessionConfigEntry.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static HasSessionConfigEntry.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2) -> invoke(funcPtr, _x0, _x1, _x2);
        }
    }

    private static final AddressLayout HasSessionConfigEntry$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("HasSessionConfigEntry"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*HasSessionConfigEntry)(const OrtSessionOptions *, const char *, int *)
     * }
     */
    public static final AddressLayout HasSessionConfigEntry$layout() {
        return HasSessionConfigEntry$LAYOUT;
    }

    private static final long HasSessionConfigEntry$OFFSET = 1896;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*HasSessionConfigEntry)(const OrtSessionOptions *, const char *, int *)
     * }
     */
    public static final long HasSessionConfigEntry$offset() {
        return HasSessionConfigEntry$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*HasSessionConfigEntry)(const OrtSessionOptions *, const char *, int *)
     * }
     */
    public static MemorySegment HasSessionConfigEntry(MemorySegment struct) {
        return struct.get(HasSessionConfigEntry$LAYOUT, HasSessionConfigEntry$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*HasSessionConfigEntry)(const OrtSessionOptions *, const char *, int *)
     * }
     */
    public static void HasSessionConfigEntry(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(HasSessionConfigEntry$LAYOUT, HasSessionConfigEntry$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*HasSessionConfigEntry)(const OrtSessionOptions *, const char *, int *)
     * }
     */
    public static HasSessionConfigEntry.Function HasSessionConfigEntryFunction(MemorySegment struct) {
        return HasSessionConfigEntry.function(HasSessionConfigEntry(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSessionConfigEntry)(const OrtSessionOptions *, const char *, char *, size_t *)
     * }
     */
    public static class GetSessionConfigEntry {

        GetSessionConfigEntry() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(GetSessionConfigEntry.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetSessionConfigEntry.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static GetSessionConfigEntry.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2, _x3) -> invoke(funcPtr, _x0, _x1, _x2, _x3);
        }
    }

    private static final AddressLayout GetSessionConfigEntry$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("GetSessionConfigEntry"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSessionConfigEntry)(const OrtSessionOptions *, const char *, char *, size_t *)
     * }
     */
    public static final AddressLayout GetSessionConfigEntry$layout() {
        return GetSessionConfigEntry$LAYOUT;
    }

    private static final long GetSessionConfigEntry$OFFSET = 1904;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSessionConfigEntry)(const OrtSessionOptions *, const char *, char *, size_t *)
     * }
     */
    public static final long GetSessionConfigEntry$offset() {
        return GetSessionConfigEntry$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSessionConfigEntry)(const OrtSessionOptions *, const char *, char *, size_t *)
     * }
     */
    public static MemorySegment GetSessionConfigEntry(MemorySegment struct) {
        return struct.get(GetSessionConfigEntry$LAYOUT, GetSessionConfigEntry$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSessionConfigEntry)(const OrtSessionOptions *, const char *, char *, size_t *)
     * }
     */
    public static void GetSessionConfigEntry(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetSessionConfigEntry$LAYOUT, GetSessionConfigEntry$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetSessionConfigEntry)(const OrtSessionOptions *, const char *, char *, size_t *)
     * }
     */
    public static GetSessionConfigEntry.Function GetSessionConfigEntryFunction(MemorySegment struct) {
        return GetSessionConfigEntry.function(GetSessionConfigEntry(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_Dnnl)(OrtSessionOptions *, const OrtDnnlProviderOptions *)
     * }
     */
    public static class SessionOptionsAppendExecutionProvider_Dnnl {

        SessionOptionsAppendExecutionProvider_Dnnl() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_all_h.upcallHandle(
                SessionOptionsAppendExecutionProvider_Dnnl.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SessionOptionsAppendExecutionProvider_Dnnl.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static SessionOptionsAppendExecutionProvider_Dnnl.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout SessionOptionsAppendExecutionProvider_Dnnl$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("SessionOptionsAppendExecutionProvider_Dnnl"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_Dnnl)(OrtSessionOptions *, const OrtDnnlProviderOptions *)
     * }
     */
    public static final AddressLayout SessionOptionsAppendExecutionProvider_Dnnl$layout() {
        return SessionOptionsAppendExecutionProvider_Dnnl$LAYOUT;
    }

    private static final long SessionOptionsAppendExecutionProvider_Dnnl$OFFSET = 1912;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_Dnnl)(OrtSessionOptions *, const OrtDnnlProviderOptions *)
     * }
     */
    public static final long SessionOptionsAppendExecutionProvider_Dnnl$offset() {
        return SessionOptionsAppendExecutionProvider_Dnnl$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_Dnnl)(OrtSessionOptions *, const OrtDnnlProviderOptions *)
     * }
     */
    public static MemorySegment SessionOptionsAppendExecutionProvider_Dnnl(MemorySegment struct) {
        return struct.get(
                SessionOptionsAppendExecutionProvider_Dnnl$LAYOUT, SessionOptionsAppendExecutionProvider_Dnnl$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_Dnnl)(OrtSessionOptions *, const OrtDnnlProviderOptions *)
     * }
     */
    public static void SessionOptionsAppendExecutionProvider_Dnnl(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(
                SessionOptionsAppendExecutionProvider_Dnnl$LAYOUT,
                SessionOptionsAppendExecutionProvider_Dnnl$OFFSET,
                fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_Dnnl)(OrtSessionOptions *, const OrtDnnlProviderOptions *)
     * }
     */
    public static SessionOptionsAppendExecutionProvider_Dnnl.Function
            SessionOptionsAppendExecutionProvider_DnnlFunction(MemorySegment struct) {
        return SessionOptionsAppendExecutionProvider_Dnnl.function(SessionOptionsAppendExecutionProvider_Dnnl(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateDnnlProviderOptions)(OrtDnnlProviderOptions **)
     * }
     */
    public static class CreateDnnlProviderOptions {

        CreateDnnlProviderOptions() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC =
                FunctionDescriptor.of(onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(CreateDnnlProviderOptions.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateDnnlProviderOptions.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static CreateDnnlProviderOptions.Function function(MemorySegment funcPtr) {
            return (_x0) -> invoke(funcPtr, _x0);
        }
    }

    private static final AddressLayout CreateDnnlProviderOptions$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("CreateDnnlProviderOptions"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateDnnlProviderOptions)(OrtDnnlProviderOptions **)
     * }
     */
    public static final AddressLayout CreateDnnlProviderOptions$layout() {
        return CreateDnnlProviderOptions$LAYOUT;
    }

    private static final long CreateDnnlProviderOptions$OFFSET = 1920;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateDnnlProviderOptions)(OrtDnnlProviderOptions **)
     * }
     */
    public static final long CreateDnnlProviderOptions$offset() {
        return CreateDnnlProviderOptions$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateDnnlProviderOptions)(OrtDnnlProviderOptions **)
     * }
     */
    public static MemorySegment CreateDnnlProviderOptions(MemorySegment struct) {
        return struct.get(CreateDnnlProviderOptions$LAYOUT, CreateDnnlProviderOptions$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateDnnlProviderOptions)(OrtDnnlProviderOptions **)
     * }
     */
    public static void CreateDnnlProviderOptions(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateDnnlProviderOptions$LAYOUT, CreateDnnlProviderOptions$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateDnnlProviderOptions)(OrtDnnlProviderOptions **)
     * }
     */
    public static CreateDnnlProviderOptions.Function CreateDnnlProviderOptionsFunction(MemorySegment struct) {
        return CreateDnnlProviderOptions.function(CreateDnnlProviderOptions(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateDnnlProviderOptions)(OrtDnnlProviderOptions *, const char *const *, const char *const *, size_t)
     * }
     */
    public static class UpdateDnnlProviderOptions {

        UpdateDnnlProviderOptions() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_LONG);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(UpdateDnnlProviderOptions.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(UpdateDnnlProviderOptions.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static UpdateDnnlProviderOptions.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2, _x3) -> invoke(funcPtr, _x0, _x1, _x2, _x3);
        }
    }

    private static final AddressLayout UpdateDnnlProviderOptions$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("UpdateDnnlProviderOptions"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateDnnlProviderOptions)(OrtDnnlProviderOptions *, const char *const *, const char *const *, size_t)
     * }
     */
    public static final AddressLayout UpdateDnnlProviderOptions$layout() {
        return UpdateDnnlProviderOptions$LAYOUT;
    }

    private static final long UpdateDnnlProviderOptions$OFFSET = 1928;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateDnnlProviderOptions)(OrtDnnlProviderOptions *, const char *const *, const char *const *, size_t)
     * }
     */
    public static final long UpdateDnnlProviderOptions$offset() {
        return UpdateDnnlProviderOptions$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateDnnlProviderOptions)(OrtDnnlProviderOptions *, const char *const *, const char *const *, size_t)
     * }
     */
    public static MemorySegment UpdateDnnlProviderOptions(MemorySegment struct) {
        return struct.get(UpdateDnnlProviderOptions$LAYOUT, UpdateDnnlProviderOptions$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateDnnlProviderOptions)(OrtDnnlProviderOptions *, const char *const *, const char *const *, size_t)
     * }
     */
    public static void UpdateDnnlProviderOptions(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(UpdateDnnlProviderOptions$LAYOUT, UpdateDnnlProviderOptions$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateDnnlProviderOptions)(OrtDnnlProviderOptions *, const char *const *, const char *const *, size_t)
     * }
     */
    public static UpdateDnnlProviderOptions.Function UpdateDnnlProviderOptionsFunction(MemorySegment struct) {
        return UpdateDnnlProviderOptions.function(UpdateDnnlProviderOptions(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetDnnlProviderOptionsAsString)(const OrtDnnlProviderOptions *, OrtAllocator *, char **)
     * }
     */
    public static class GetDnnlProviderOptionsAsString {

        GetDnnlProviderOptionsAsString() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(GetDnnlProviderOptionsAsString.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetDnnlProviderOptionsAsString.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static GetDnnlProviderOptionsAsString.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2) -> invoke(funcPtr, _x0, _x1, _x2);
        }
    }

    private static final AddressLayout GetDnnlProviderOptionsAsString$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("GetDnnlProviderOptionsAsString"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetDnnlProviderOptionsAsString)(const OrtDnnlProviderOptions *, OrtAllocator *, char **)
     * }
     */
    public static final AddressLayout GetDnnlProviderOptionsAsString$layout() {
        return GetDnnlProviderOptionsAsString$LAYOUT;
    }

    private static final long GetDnnlProviderOptionsAsString$OFFSET = 1936;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetDnnlProviderOptionsAsString)(const OrtDnnlProviderOptions *, OrtAllocator *, char **)
     * }
     */
    public static final long GetDnnlProviderOptionsAsString$offset() {
        return GetDnnlProviderOptionsAsString$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetDnnlProviderOptionsAsString)(const OrtDnnlProviderOptions *, OrtAllocator *, char **)
     * }
     */
    public static MemorySegment GetDnnlProviderOptionsAsString(MemorySegment struct) {
        return struct.get(GetDnnlProviderOptionsAsString$LAYOUT, GetDnnlProviderOptionsAsString$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetDnnlProviderOptionsAsString)(const OrtDnnlProviderOptions *, OrtAllocator *, char **)
     * }
     */
    public static void GetDnnlProviderOptionsAsString(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetDnnlProviderOptionsAsString$LAYOUT, GetDnnlProviderOptionsAsString$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetDnnlProviderOptionsAsString)(const OrtDnnlProviderOptions *, OrtAllocator *, char **)
     * }
     */
    public static GetDnnlProviderOptionsAsString.Function GetDnnlProviderOptionsAsStringFunction(MemorySegment struct) {
        return GetDnnlProviderOptionsAsString.function(GetDnnlProviderOptionsAsString(struct));
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseDnnlProviderOptions)(OrtDnnlProviderOptions *)
     * }
     */
    public static class ReleaseDnnlProviderOptions {

        ReleaseDnnlProviderOptions() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(ReleaseDnnlProviderOptions.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleaseDnnlProviderOptions.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static ReleaseDnnlProviderOptions.Function function(MemorySegment funcPtr) {
            return (_x0) -> invoke(funcPtr, _x0);
        }
    }

    private static final AddressLayout ReleaseDnnlProviderOptions$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("ReleaseDnnlProviderOptions"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ReleaseDnnlProviderOptions)(OrtDnnlProviderOptions *)
     * }
     */
    public static final AddressLayout ReleaseDnnlProviderOptions$layout() {
        return ReleaseDnnlProviderOptions$LAYOUT;
    }

    private static final long ReleaseDnnlProviderOptions$OFFSET = 1944;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ReleaseDnnlProviderOptions)(OrtDnnlProviderOptions *)
     * }
     */
    public static final long ReleaseDnnlProviderOptions$offset() {
        return ReleaseDnnlProviderOptions$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ReleaseDnnlProviderOptions)(OrtDnnlProviderOptions *)
     * }
     */
    public static MemorySegment ReleaseDnnlProviderOptions(MemorySegment struct) {
        return struct.get(ReleaseDnnlProviderOptions$LAYOUT, ReleaseDnnlProviderOptions$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ReleaseDnnlProviderOptions)(OrtDnnlProviderOptions *)
     * }
     */
    public static void ReleaseDnnlProviderOptions(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleaseDnnlProviderOptions$LAYOUT, ReleaseDnnlProviderOptions$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * void (*ReleaseDnnlProviderOptions)(OrtDnnlProviderOptions *)
     * }
     */
    public static ReleaseDnnlProviderOptions.Function ReleaseDnnlProviderOptionsFunction(MemorySegment struct) {
        return ReleaseDnnlProviderOptions.function(ReleaseDnnlProviderOptions(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetNodeName)(const OrtKernelInfo *, char *, size_t *)
     * }
     */
    public static class KernelInfo_GetNodeName {

        KernelInfo_GetNodeName() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(KernelInfo_GetNodeName.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(KernelInfo_GetNodeName.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static KernelInfo_GetNodeName.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2) -> invoke(funcPtr, _x0, _x1, _x2);
        }
    }

    private static final AddressLayout KernelInfo_GetNodeName$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("KernelInfo_GetNodeName"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetNodeName)(const OrtKernelInfo *, char *, size_t *)
     * }
     */
    public static final AddressLayout KernelInfo_GetNodeName$layout() {
        return KernelInfo_GetNodeName$LAYOUT;
    }

    private static final long KernelInfo_GetNodeName$OFFSET = 1952;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetNodeName)(const OrtKernelInfo *, char *, size_t *)
     * }
     */
    public static final long KernelInfo_GetNodeName$offset() {
        return KernelInfo_GetNodeName$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetNodeName)(const OrtKernelInfo *, char *, size_t *)
     * }
     */
    public static MemorySegment KernelInfo_GetNodeName(MemorySegment struct) {
        return struct.get(KernelInfo_GetNodeName$LAYOUT, KernelInfo_GetNodeName$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetNodeName)(const OrtKernelInfo *, char *, size_t *)
     * }
     */
    public static void KernelInfo_GetNodeName(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(KernelInfo_GetNodeName$LAYOUT, KernelInfo_GetNodeName$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetNodeName)(const OrtKernelInfo *, char *, size_t *)
     * }
     */
    public static KernelInfo_GetNodeName.Function KernelInfo_GetNodeNameFunction(MemorySegment struct) {
        return KernelInfo_GetNodeName.function(KernelInfo_GetNodeName(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetLogger)(const OrtKernelInfo *, const OrtLogger **)
     * }
     */
    public static class KernelInfo_GetLogger {

        KernelInfo_GetLogger() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(KernelInfo_GetLogger.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(KernelInfo_GetLogger.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static KernelInfo_GetLogger.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout KernelInfo_GetLogger$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("KernelInfo_GetLogger"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetLogger)(const OrtKernelInfo *, const OrtLogger **)
     * }
     */
    public static final AddressLayout KernelInfo_GetLogger$layout() {
        return KernelInfo_GetLogger$LAYOUT;
    }

    private static final long KernelInfo_GetLogger$OFFSET = 1960;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetLogger)(const OrtKernelInfo *, const OrtLogger **)
     * }
     */
    public static final long KernelInfo_GetLogger$offset() {
        return KernelInfo_GetLogger$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetLogger)(const OrtKernelInfo *, const OrtLogger **)
     * }
     */
    public static MemorySegment KernelInfo_GetLogger(MemorySegment struct) {
        return struct.get(KernelInfo_GetLogger$LAYOUT, KernelInfo_GetLogger$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetLogger)(const OrtKernelInfo *, const OrtLogger **)
     * }
     */
    public static void KernelInfo_GetLogger(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(KernelInfo_GetLogger$LAYOUT, KernelInfo_GetLogger$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfo_GetLogger)(const OrtKernelInfo *, const OrtLogger **)
     * }
     */
    public static KernelInfo_GetLogger.Function KernelInfo_GetLoggerFunction(MemorySegment struct) {
        return KernelInfo_GetLogger.function(KernelInfo_GetLogger(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetLogger)(const OrtKernelContext *, const OrtLogger **)
     * }
     */
    public static class KernelContext_GetLogger {

        KernelContext_GetLogger() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(KernelContext_GetLogger.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(KernelContext_GetLogger.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static KernelContext_GetLogger.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout KernelContext_GetLogger$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("KernelContext_GetLogger"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetLogger)(const OrtKernelContext *, const OrtLogger **)
     * }
     */
    public static final AddressLayout KernelContext_GetLogger$layout() {
        return KernelContext_GetLogger$LAYOUT;
    }

    private static final long KernelContext_GetLogger$OFFSET = 1968;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetLogger)(const OrtKernelContext *, const OrtLogger **)
     * }
     */
    public static final long KernelContext_GetLogger$offset() {
        return KernelContext_GetLogger$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetLogger)(const OrtKernelContext *, const OrtLogger **)
     * }
     */
    public static MemorySegment KernelContext_GetLogger(MemorySegment struct) {
        return struct.get(KernelContext_GetLogger$LAYOUT, KernelContext_GetLogger$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetLogger)(const OrtKernelContext *, const OrtLogger **)
     * }
     */
    public static void KernelContext_GetLogger(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(KernelContext_GetLogger$LAYOUT, KernelContext_GetLogger$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetLogger)(const OrtKernelContext *, const OrtLogger **)
     * }
     */
    public static KernelContext_GetLogger.Function KernelContext_GetLoggerFunction(MemorySegment struct) {
        return KernelContext_GetLogger.function(KernelContext_GetLogger(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*Logger_LogMessage)(const OrtLogger *, OrtLoggingLevel, const char *, const char *, int, const char *)
     * }
     */
    public static class Logger_LogMessage {

        Logger_LogMessage() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(
                    MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3, int _x4, MemorySegment _x5);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_INT,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_INT,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(Logger_LogMessage.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Logger_LogMessage.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr,
                MemorySegment _x0,
                int _x1,
                MemorySegment _x2,
                MemorySegment _x3,
                int _x4,
                MemorySegment _x5) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static Logger_LogMessage.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2, _x3, _x4, _x5) -> invoke(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);
        }
    }

    private static final AddressLayout Logger_LogMessage$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("Logger_LogMessage"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Logger_LogMessage)(const OrtLogger *, OrtLoggingLevel, const char *, const char *, int, const char *)
     * }
     */
    public static final AddressLayout Logger_LogMessage$layout() {
        return Logger_LogMessage$LAYOUT;
    }

    private static final long Logger_LogMessage$OFFSET = 1976;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Logger_LogMessage)(const OrtLogger *, OrtLoggingLevel, const char *, const char *, int, const char *)
     * }
     */
    public static final long Logger_LogMessage$offset() {
        return Logger_LogMessage$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Logger_LogMessage)(const OrtLogger *, OrtLoggingLevel, const char *, const char *, int, const char *)
     * }
     */
    public static MemorySegment Logger_LogMessage(MemorySegment struct) {
        return struct.get(Logger_LogMessage$LAYOUT, Logger_LogMessage$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Logger_LogMessage)(const OrtLogger *, OrtLoggingLevel, const char *, const char *, int, const char *)
     * }
     */
    public static void Logger_LogMessage(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(Logger_LogMessage$LAYOUT, Logger_LogMessage$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Logger_LogMessage)(const OrtLogger *, OrtLoggingLevel, const char *, const char *, int, const char *)
     * }
     */
    public static Logger_LogMessage.Function Logger_LogMessageFunction(MemorySegment struct) {
        return Logger_LogMessage.function(Logger_LogMessage(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*Logger_GetLoggingSeverityLevel)(const OrtLogger *, OrtLoggingLevel *)
     * }
     */
    public static class Logger_GetLoggingSeverityLevel {

        Logger_GetLoggingSeverityLevel() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(Logger_GetLoggingSeverityLevel.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(Logger_GetLoggingSeverityLevel.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static Logger_GetLoggingSeverityLevel.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout Logger_GetLoggingSeverityLevel$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("Logger_GetLoggingSeverityLevel"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Logger_GetLoggingSeverityLevel)(const OrtLogger *, OrtLoggingLevel *)
     * }
     */
    public static final AddressLayout Logger_GetLoggingSeverityLevel$layout() {
        return Logger_GetLoggingSeverityLevel$LAYOUT;
    }

    private static final long Logger_GetLoggingSeverityLevel$OFFSET = 1984;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Logger_GetLoggingSeverityLevel)(const OrtLogger *, OrtLoggingLevel *)
     * }
     */
    public static final long Logger_GetLoggingSeverityLevel$offset() {
        return Logger_GetLoggingSeverityLevel$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Logger_GetLoggingSeverityLevel)(const OrtLogger *, OrtLoggingLevel *)
     * }
     */
    public static MemorySegment Logger_GetLoggingSeverityLevel(MemorySegment struct) {
        return struct.get(Logger_GetLoggingSeverityLevel$LAYOUT, Logger_GetLoggingSeverityLevel$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Logger_GetLoggingSeverityLevel)(const OrtLogger *, OrtLoggingLevel *)
     * }
     */
    public static void Logger_GetLoggingSeverityLevel(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(Logger_GetLoggingSeverityLevel$LAYOUT, Logger_GetLoggingSeverityLevel$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*Logger_GetLoggingSeverityLevel)(const OrtLogger *, OrtLoggingLevel *)
     * }
     */
    public static Logger_GetLoggingSeverityLevel.Function Logger_GetLoggingSeverityLevelFunction(MemorySegment struct) {
        return Logger_GetLoggingSeverityLevel.function(Logger_GetLoggingSeverityLevel(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetConstantInput_tensor)(const OrtKernelInfo *, size_t, int *, const OrtValue **)
     * }
     */
    public static class KernelInfoGetConstantInput_tensor {

        KernelInfoGetConstantInput_tensor() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_LONG,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(KernelInfoGetConstantInput_tensor.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(KernelInfoGetConstantInput_tensor.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr, MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static KernelInfoGetConstantInput_tensor.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2, _x3) -> invoke(funcPtr, _x0, _x1, _x2, _x3);
        }
    }

    private static final AddressLayout KernelInfoGetConstantInput_tensor$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("KernelInfoGetConstantInput_tensor"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetConstantInput_tensor)(const OrtKernelInfo *, size_t, int *, const OrtValue **)
     * }
     */
    public static final AddressLayout KernelInfoGetConstantInput_tensor$layout() {
        return KernelInfoGetConstantInput_tensor$LAYOUT;
    }

    private static final long KernelInfoGetConstantInput_tensor$OFFSET = 1992;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetConstantInput_tensor)(const OrtKernelInfo *, size_t, int *, const OrtValue **)
     * }
     */
    public static final long KernelInfoGetConstantInput_tensor$offset() {
        return KernelInfoGetConstantInput_tensor$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetConstantInput_tensor)(const OrtKernelInfo *, size_t, int *, const OrtValue **)
     * }
     */
    public static MemorySegment KernelInfoGetConstantInput_tensor(MemorySegment struct) {
        return struct.get(KernelInfoGetConstantInput_tensor$LAYOUT, KernelInfoGetConstantInput_tensor$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetConstantInput_tensor)(const OrtKernelInfo *, size_t, int *, const OrtValue **)
     * }
     */
    public static void KernelInfoGetConstantInput_tensor(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(KernelInfoGetConstantInput_tensor$LAYOUT, KernelInfoGetConstantInput_tensor$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetConstantInput_tensor)(const OrtKernelInfo *, size_t, int *, const OrtValue **)
     * }
     */
    public static KernelInfoGetConstantInput_tensor.Function KernelInfoGetConstantInput_tensorFunction(
            MemorySegment struct) {
        return KernelInfoGetConstantInput_tensor.function(KernelInfoGetConstantInput_tensor(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CastTypeInfoToOptionalTypeInfo)(const OrtTypeInfo *, const OrtOptionalTypeInfo **)
     * }
     */
    public static class CastTypeInfoToOptionalTypeInfo {

        CastTypeInfoToOptionalTypeInfo() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(CastTypeInfoToOptionalTypeInfo.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CastTypeInfoToOptionalTypeInfo.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static CastTypeInfoToOptionalTypeInfo.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout CastTypeInfoToOptionalTypeInfo$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("CastTypeInfoToOptionalTypeInfo"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CastTypeInfoToOptionalTypeInfo)(const OrtTypeInfo *, const OrtOptionalTypeInfo **)
     * }
     */
    public static final AddressLayout CastTypeInfoToOptionalTypeInfo$layout() {
        return CastTypeInfoToOptionalTypeInfo$LAYOUT;
    }

    private static final long CastTypeInfoToOptionalTypeInfo$OFFSET = 2000;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CastTypeInfoToOptionalTypeInfo)(const OrtTypeInfo *, const OrtOptionalTypeInfo **)
     * }
     */
    public static final long CastTypeInfoToOptionalTypeInfo$offset() {
        return CastTypeInfoToOptionalTypeInfo$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CastTypeInfoToOptionalTypeInfo)(const OrtTypeInfo *, const OrtOptionalTypeInfo **)
     * }
     */
    public static MemorySegment CastTypeInfoToOptionalTypeInfo(MemorySegment struct) {
        return struct.get(CastTypeInfoToOptionalTypeInfo$LAYOUT, CastTypeInfoToOptionalTypeInfo$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CastTypeInfoToOptionalTypeInfo)(const OrtTypeInfo *, const OrtOptionalTypeInfo **)
     * }
     */
    public static void CastTypeInfoToOptionalTypeInfo(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CastTypeInfoToOptionalTypeInfo$LAYOUT, CastTypeInfoToOptionalTypeInfo$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CastTypeInfoToOptionalTypeInfo)(const OrtTypeInfo *, const OrtOptionalTypeInfo **)
     * }
     */
    public static CastTypeInfoToOptionalTypeInfo.Function CastTypeInfoToOptionalTypeInfoFunction(MemorySegment struct) {
        return CastTypeInfoToOptionalTypeInfo.function(CastTypeInfoToOptionalTypeInfo(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetOptionalContainedTypeInfo)(const OrtOptionalTypeInfo *, OrtTypeInfo **)
     * }
     */
    public static class GetOptionalContainedTypeInfo {

        GetOptionalContainedTypeInfo() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(GetOptionalContainedTypeInfo.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetOptionalContainedTypeInfo.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static GetOptionalContainedTypeInfo.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout GetOptionalContainedTypeInfo$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("GetOptionalContainedTypeInfo"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetOptionalContainedTypeInfo)(const OrtOptionalTypeInfo *, OrtTypeInfo **)
     * }
     */
    public static final AddressLayout GetOptionalContainedTypeInfo$layout() {
        return GetOptionalContainedTypeInfo$LAYOUT;
    }

    private static final long GetOptionalContainedTypeInfo$OFFSET = 2008;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetOptionalContainedTypeInfo)(const OrtOptionalTypeInfo *, OrtTypeInfo **)
     * }
     */
    public static final long GetOptionalContainedTypeInfo$offset() {
        return GetOptionalContainedTypeInfo$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetOptionalContainedTypeInfo)(const OrtOptionalTypeInfo *, OrtTypeInfo **)
     * }
     */
    public static MemorySegment GetOptionalContainedTypeInfo(MemorySegment struct) {
        return struct.get(GetOptionalContainedTypeInfo$LAYOUT, GetOptionalContainedTypeInfo$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetOptionalContainedTypeInfo)(const OrtOptionalTypeInfo *, OrtTypeInfo **)
     * }
     */
    public static void GetOptionalContainedTypeInfo(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetOptionalContainedTypeInfo$LAYOUT, GetOptionalContainedTypeInfo$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetOptionalContainedTypeInfo)(const OrtOptionalTypeInfo *, OrtTypeInfo **)
     * }
     */
    public static GetOptionalContainedTypeInfo.Function GetOptionalContainedTypeInfoFunction(MemorySegment struct) {
        return GetOptionalContainedTypeInfo.function(GetOptionalContainedTypeInfo(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetResizedStringTensorElementBuffer)(OrtValue *, size_t, size_t, char **)
     * }
     */
    public static class GetResizedStringTensorElementBuffer {

        GetResizedStringTensorElementBuffer() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, long _x1, long _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_LONG,
                onnxruntime_all_h.C_LONG,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(GetResizedStringTensorElementBuffer.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetResizedStringTensorElementBuffer.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr, MemorySegment _x0, long _x1, long _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static GetResizedStringTensorElementBuffer.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2, _x3) -> invoke(funcPtr, _x0, _x1, _x2, _x3);
        }
    }

    private static final AddressLayout GetResizedStringTensorElementBuffer$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("GetResizedStringTensorElementBuffer"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetResizedStringTensorElementBuffer)(OrtValue *, size_t, size_t, char **)
     * }
     */
    public static final AddressLayout GetResizedStringTensorElementBuffer$layout() {
        return GetResizedStringTensorElementBuffer$LAYOUT;
    }

    private static final long GetResizedStringTensorElementBuffer$OFFSET = 2016;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetResizedStringTensorElementBuffer)(OrtValue *, size_t, size_t, char **)
     * }
     */
    public static final long GetResizedStringTensorElementBuffer$offset() {
        return GetResizedStringTensorElementBuffer$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetResizedStringTensorElementBuffer)(OrtValue *, size_t, size_t, char **)
     * }
     */
    public static MemorySegment GetResizedStringTensorElementBuffer(MemorySegment struct) {
        return struct.get(GetResizedStringTensorElementBuffer$LAYOUT, GetResizedStringTensorElementBuffer$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetResizedStringTensorElementBuffer)(OrtValue *, size_t, size_t, char **)
     * }
     */
    public static void GetResizedStringTensorElementBuffer(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetResizedStringTensorElementBuffer$LAYOUT, GetResizedStringTensorElementBuffer$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetResizedStringTensorElementBuffer)(OrtValue *, size_t, size_t, char **)
     * }
     */
    public static GetResizedStringTensorElementBuffer.Function GetResizedStringTensorElementBufferFunction(
            MemorySegment struct) {
        return GetResizedStringTensorElementBuffer.function(GetResizedStringTensorElementBuffer(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetAllocator)(const OrtKernelContext *, const OrtMemoryInfo *, OrtAllocator **)
     * }
     */
    public static class KernelContext_GetAllocator {

        KernelContext_GetAllocator() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(KernelContext_GetAllocator.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(KernelContext_GetAllocator.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static KernelContext_GetAllocator.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2) -> invoke(funcPtr, _x0, _x1, _x2);
        }
    }

    private static final AddressLayout KernelContext_GetAllocator$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("KernelContext_GetAllocator"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetAllocator)(const OrtKernelContext *, const OrtMemoryInfo *, OrtAllocator **)
     * }
     */
    public static final AddressLayout KernelContext_GetAllocator$layout() {
        return KernelContext_GetAllocator$LAYOUT;
    }

    private static final long KernelContext_GetAllocator$OFFSET = 2024;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetAllocator)(const OrtKernelContext *, const OrtMemoryInfo *, OrtAllocator **)
     * }
     */
    public static final long KernelContext_GetAllocator$offset() {
        return KernelContext_GetAllocator$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetAllocator)(const OrtKernelContext *, const OrtMemoryInfo *, OrtAllocator **)
     * }
     */
    public static MemorySegment KernelContext_GetAllocator(MemorySegment struct) {
        return struct.get(KernelContext_GetAllocator$LAYOUT, KernelContext_GetAllocator$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetAllocator)(const OrtKernelContext *, const OrtMemoryInfo *, OrtAllocator **)
     * }
     */
    public static void KernelContext_GetAllocator(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(KernelContext_GetAllocator$LAYOUT, KernelContext_GetAllocator$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetAllocator)(const OrtKernelContext *, const OrtMemoryInfo *, OrtAllocator **)
     * }
     */
    public static KernelContext_GetAllocator.Function KernelContext_GetAllocatorFunction(MemorySegment struct) {
        return KernelContext_GetAllocator.function(KernelContext_GetAllocator(struct));
    }

    /**
     * {@snippet lang=c :
     * const char *(*GetBuildInfoString)(void)
     * }
     */
    public static class GetBuildInfoString {

        GetBuildInfoString() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply();
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(GetBuildInfoString.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetBuildInfoString.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static GetBuildInfoString.Function function(MemorySegment funcPtr) {
            return () -> invoke(funcPtr);
        }
    }

    private static final AddressLayout GetBuildInfoString$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("GetBuildInfoString"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * const char *(*GetBuildInfoString)(void)
     * }
     */
    public static final AddressLayout GetBuildInfoString$layout() {
        return GetBuildInfoString$LAYOUT;
    }

    private static final long GetBuildInfoString$OFFSET = 2032;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * const char *(*GetBuildInfoString)(void)
     * }
     */
    public static final long GetBuildInfoString$offset() {
        return GetBuildInfoString$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * const char *(*GetBuildInfoString)(void)
     * }
     */
    public static MemorySegment GetBuildInfoString(MemorySegment struct) {
        return struct.get(GetBuildInfoString$LAYOUT, GetBuildInfoString$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * const char *(*GetBuildInfoString)(void)
     * }
     */
    public static void GetBuildInfoString(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetBuildInfoString$LAYOUT, GetBuildInfoString$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * const char *(*GetBuildInfoString)(void)
     * }
     */
    public static GetBuildInfoString.Function GetBuildInfoStringFunction(MemorySegment struct) {
        return GetBuildInfoString.function(GetBuildInfoString(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateROCMProviderOptions)(OrtROCMProviderOptions **)
     * }
     */
    public static class CreateROCMProviderOptions {

        CreateROCMProviderOptions() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC =
                FunctionDescriptor.of(onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(CreateROCMProviderOptions.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateROCMProviderOptions.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static CreateROCMProviderOptions.Function function(MemorySegment funcPtr) {
            return (_x0) -> invoke(funcPtr, _x0);
        }
    }

    private static final AddressLayout CreateROCMProviderOptions$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("CreateROCMProviderOptions"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateROCMProviderOptions)(OrtROCMProviderOptions **)
     * }
     */
    public static final AddressLayout CreateROCMProviderOptions$layout() {
        return CreateROCMProviderOptions$LAYOUT;
    }

    private static final long CreateROCMProviderOptions$OFFSET = 2040;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateROCMProviderOptions)(OrtROCMProviderOptions **)
     * }
     */
    public static final long CreateROCMProviderOptions$offset() {
        return CreateROCMProviderOptions$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateROCMProviderOptions)(OrtROCMProviderOptions **)
     * }
     */
    public static MemorySegment CreateROCMProviderOptions(MemorySegment struct) {
        return struct.get(CreateROCMProviderOptions$LAYOUT, CreateROCMProviderOptions$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateROCMProviderOptions)(OrtROCMProviderOptions **)
     * }
     */
    public static void CreateROCMProviderOptions(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateROCMProviderOptions$LAYOUT, CreateROCMProviderOptions$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateROCMProviderOptions)(OrtROCMProviderOptions **)
     * }
     */
    public static CreateROCMProviderOptions.Function CreateROCMProviderOptionsFunction(MemorySegment struct) {
        return CreateROCMProviderOptions.function(CreateROCMProviderOptions(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateROCMProviderOptions)(OrtROCMProviderOptions *, const char *const *, const char *const *, size_t)
     * }
     */
    public static class UpdateROCMProviderOptions {

        UpdateROCMProviderOptions() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_LONG);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(UpdateROCMProviderOptions.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(UpdateROCMProviderOptions.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static UpdateROCMProviderOptions.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2, _x3) -> invoke(funcPtr, _x0, _x1, _x2, _x3);
        }
    }

    private static final AddressLayout UpdateROCMProviderOptions$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("UpdateROCMProviderOptions"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateROCMProviderOptions)(OrtROCMProviderOptions *, const char *const *, const char *const *, size_t)
     * }
     */
    public static final AddressLayout UpdateROCMProviderOptions$layout() {
        return UpdateROCMProviderOptions$LAYOUT;
    }

    private static final long UpdateROCMProviderOptions$OFFSET = 2048;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateROCMProviderOptions)(OrtROCMProviderOptions *, const char *const *, const char *const *, size_t)
     * }
     */
    public static final long UpdateROCMProviderOptions$offset() {
        return UpdateROCMProviderOptions$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateROCMProviderOptions)(OrtROCMProviderOptions *, const char *const *, const char *const *, size_t)
     * }
     */
    public static MemorySegment UpdateROCMProviderOptions(MemorySegment struct) {
        return struct.get(UpdateROCMProviderOptions$LAYOUT, UpdateROCMProviderOptions$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateROCMProviderOptions)(OrtROCMProviderOptions *, const char *const *, const char *const *, size_t)
     * }
     */
    public static void UpdateROCMProviderOptions(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(UpdateROCMProviderOptions$LAYOUT, UpdateROCMProviderOptions$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateROCMProviderOptions)(OrtROCMProviderOptions *, const char *const *, const char *const *, size_t)
     * }
     */
    public static UpdateROCMProviderOptions.Function UpdateROCMProviderOptionsFunction(MemorySegment struct) {
        return UpdateROCMProviderOptions.function(UpdateROCMProviderOptions(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetROCMProviderOptionsAsString)(const OrtROCMProviderOptions *, OrtAllocator *, char **)
     * }
     */
    public static class GetROCMProviderOptionsAsString {

        GetROCMProviderOptionsAsString() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(GetROCMProviderOptionsAsString.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetROCMProviderOptionsAsString.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static GetROCMProviderOptionsAsString.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2) -> invoke(funcPtr, _x0, _x1, _x2);
        }
    }

    private static final AddressLayout GetROCMProviderOptionsAsString$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("GetROCMProviderOptionsAsString"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetROCMProviderOptionsAsString)(const OrtROCMProviderOptions *, OrtAllocator *, char **)
     * }
     */
    public static final AddressLayout GetROCMProviderOptionsAsString$layout() {
        return GetROCMProviderOptionsAsString$LAYOUT;
    }

    private static final long GetROCMProviderOptionsAsString$OFFSET = 2056;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetROCMProviderOptionsAsString)(const OrtROCMProviderOptions *, OrtAllocator *, char **)
     * }
     */
    public static final long GetROCMProviderOptionsAsString$offset() {
        return GetROCMProviderOptionsAsString$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetROCMProviderOptionsAsString)(const OrtROCMProviderOptions *, OrtAllocator *, char **)
     * }
     */
    public static MemorySegment GetROCMProviderOptionsAsString(MemorySegment struct) {
        return struct.get(GetROCMProviderOptionsAsString$LAYOUT, GetROCMProviderOptionsAsString$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetROCMProviderOptionsAsString)(const OrtROCMProviderOptions *, OrtAllocator *, char **)
     * }
     */
    public static void GetROCMProviderOptionsAsString(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetROCMProviderOptionsAsString$LAYOUT, GetROCMProviderOptionsAsString$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetROCMProviderOptionsAsString)(const OrtROCMProviderOptions *, OrtAllocator *, char **)
     * }
     */
    public static GetROCMProviderOptionsAsString.Function GetROCMProviderOptionsAsStringFunction(MemorySegment struct) {
        return GetROCMProviderOptionsAsString.function(GetROCMProviderOptionsAsString(struct));
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseROCMProviderOptions)(OrtROCMProviderOptions *)
     * }
     */
    public static class ReleaseROCMProviderOptions {

        ReleaseROCMProviderOptions() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(ReleaseROCMProviderOptions.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleaseROCMProviderOptions.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static ReleaseROCMProviderOptions.Function function(MemorySegment funcPtr) {
            return (_x0) -> invoke(funcPtr, _x0);
        }
    }

    private static final AddressLayout ReleaseROCMProviderOptions$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("ReleaseROCMProviderOptions"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ReleaseROCMProviderOptions)(OrtROCMProviderOptions *)
     * }
     */
    public static final AddressLayout ReleaseROCMProviderOptions$layout() {
        return ReleaseROCMProviderOptions$LAYOUT;
    }

    private static final long ReleaseROCMProviderOptions$OFFSET = 2064;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ReleaseROCMProviderOptions)(OrtROCMProviderOptions *)
     * }
     */
    public static final long ReleaseROCMProviderOptions$offset() {
        return ReleaseROCMProviderOptions$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ReleaseROCMProviderOptions)(OrtROCMProviderOptions *)
     * }
     */
    public static MemorySegment ReleaseROCMProviderOptions(MemorySegment struct) {
        return struct.get(ReleaseROCMProviderOptions$LAYOUT, ReleaseROCMProviderOptions$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ReleaseROCMProviderOptions)(OrtROCMProviderOptions *)
     * }
     */
    public static void ReleaseROCMProviderOptions(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleaseROCMProviderOptions$LAYOUT, ReleaseROCMProviderOptions$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * void (*ReleaseROCMProviderOptions)(OrtROCMProviderOptions *)
     * }
     */
    public static ReleaseROCMProviderOptions.Function ReleaseROCMProviderOptionsFunction(MemorySegment struct) {
        return ReleaseROCMProviderOptions.function(ReleaseROCMProviderOptions(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateAndRegisterAllocatorV2)(OrtEnv *, const char *, const OrtMemoryInfo *, const OrtArenaCfg *, const char *const *, const char *const *, size_t)
     * }
     */
    public static class CreateAndRegisterAllocatorV2 {

        CreateAndRegisterAllocatorV2() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(
                    MemorySegment _x0,
                    MemorySegment _x1,
                    MemorySegment _x2,
                    MemorySegment _x3,
                    MemorySegment _x4,
                    MemorySegment _x5,
                    long _x6);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_LONG);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(CreateAndRegisterAllocatorV2.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateAndRegisterAllocatorV2.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr,
                MemorySegment _x0,
                MemorySegment _x1,
                MemorySegment _x2,
                MemorySegment _x3,
                MemorySegment _x4,
                MemorySegment _x5,
                long _x6) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static CreateAndRegisterAllocatorV2.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2, _x3, _x4, _x5, _x6) -> invoke(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6);
        }
    }

    private static final AddressLayout CreateAndRegisterAllocatorV2$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("CreateAndRegisterAllocatorV2"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateAndRegisterAllocatorV2)(OrtEnv *, const char *, const OrtMemoryInfo *, const OrtArenaCfg *, const char *const *, const char *const *, size_t)
     * }
     */
    public static final AddressLayout CreateAndRegisterAllocatorV2$layout() {
        return CreateAndRegisterAllocatorV2$LAYOUT;
    }

    private static final long CreateAndRegisterAllocatorV2$OFFSET = 2072;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateAndRegisterAllocatorV2)(OrtEnv *, const char *, const OrtMemoryInfo *, const OrtArenaCfg *, const char *const *, const char *const *, size_t)
     * }
     */
    public static final long CreateAndRegisterAllocatorV2$offset() {
        return CreateAndRegisterAllocatorV2$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateAndRegisterAllocatorV2)(OrtEnv *, const char *, const OrtMemoryInfo *, const OrtArenaCfg *, const char *const *, const char *const *, size_t)
     * }
     */
    public static MemorySegment CreateAndRegisterAllocatorV2(MemorySegment struct) {
        return struct.get(CreateAndRegisterAllocatorV2$LAYOUT, CreateAndRegisterAllocatorV2$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateAndRegisterAllocatorV2)(OrtEnv *, const char *, const OrtMemoryInfo *, const OrtArenaCfg *, const char *const *, const char *const *, size_t)
     * }
     */
    public static void CreateAndRegisterAllocatorV2(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateAndRegisterAllocatorV2$LAYOUT, CreateAndRegisterAllocatorV2$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateAndRegisterAllocatorV2)(OrtEnv *, const char *, const OrtMemoryInfo *, const OrtArenaCfg *, const char *const *, const char *const *, size_t)
     * }
     */
    public static CreateAndRegisterAllocatorV2.Function CreateAndRegisterAllocatorV2Function(MemorySegment struct) {
        return CreateAndRegisterAllocatorV2.function(CreateAndRegisterAllocatorV2(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*RunAsync)(OrtSession *, const OrtRunOptions *, const char *const *, const OrtValue *const *, size_t, const char *const *, size_t, OrtValue **, RunAsyncCallbackFn, void *)
     * }
     */
    public static class RunAsync {

        RunAsync() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(
                    MemorySegment _x0,
                    MemorySegment _x1,
                    MemorySegment _x2,
                    MemorySegment _x3,
                    long _x4,
                    MemorySegment _x5,
                    long _x6,
                    MemorySegment _x7,
                    MemorySegment _x8,
                    MemorySegment _x9);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_LONG,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_LONG,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(RunAsync.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(RunAsync.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr,
                MemorySegment _x0,
                MemorySegment _x1,
                MemorySegment _x2,
                MemorySegment _x3,
                long _x4,
                MemorySegment _x5,
                long _x6,
                MemorySegment _x7,
                MemorySegment _x8,
                MemorySegment _x9) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7, _x8, _x9);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static RunAsync.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7, _x8, _x9) ->
                    invoke(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7, _x8, _x9);
        }
    }

    private static final AddressLayout RunAsync$LAYOUT = (AddressLayout) $LAYOUT.select(groupElement("RunAsync"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunAsync)(OrtSession *, const OrtRunOptions *, const char *const *, const OrtValue *const *, size_t, const char *const *, size_t, OrtValue **, RunAsyncCallbackFn, void *)
     * }
     */
    public static final AddressLayout RunAsync$layout() {
        return RunAsync$LAYOUT;
    }

    private static final long RunAsync$OFFSET = 2080;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunAsync)(OrtSession *, const OrtRunOptions *, const char *const *, const OrtValue *const *, size_t, const char *const *, size_t, OrtValue **, RunAsyncCallbackFn, void *)
     * }
     */
    public static final long RunAsync$offset() {
        return RunAsync$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunAsync)(OrtSession *, const OrtRunOptions *, const char *const *, const OrtValue *const *, size_t, const char *const *, size_t, OrtValue **, RunAsyncCallbackFn, void *)
     * }
     */
    public static MemorySegment RunAsync(MemorySegment struct) {
        return struct.get(RunAsync$LAYOUT, RunAsync$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunAsync)(OrtSession *, const OrtRunOptions *, const char *const *, const OrtValue *const *, size_t, const char *const *, size_t, OrtValue **, RunAsyncCallbackFn, void *)
     * }
     */
    public static void RunAsync(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(RunAsync$LAYOUT, RunAsync$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunAsync)(OrtSession *, const OrtRunOptions *, const char *const *, const OrtValue *const *, size_t, const char *const *, size_t, OrtValue **, RunAsyncCallbackFn, void *)
     * }
     */
    public static RunAsync.Function RunAsyncFunction(MemorySegment struct) {
        return RunAsync.function(RunAsync(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateTensorRTProviderOptionsWithValue)(OrtTensorRTProviderOptionsV2 *, const char *, void *)
     * }
     */
    public static class UpdateTensorRTProviderOptionsWithValue {

        UpdateTensorRTProviderOptionsWithValue() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(UpdateTensorRTProviderOptionsWithValue.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(UpdateTensorRTProviderOptionsWithValue.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static UpdateTensorRTProviderOptionsWithValue.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2) -> invoke(funcPtr, _x0, _x1, _x2);
        }
    }

    private static final AddressLayout UpdateTensorRTProviderOptionsWithValue$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("UpdateTensorRTProviderOptionsWithValue"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateTensorRTProviderOptionsWithValue)(OrtTensorRTProviderOptionsV2 *, const char *, void *)
     * }
     */
    public static final AddressLayout UpdateTensorRTProviderOptionsWithValue$layout() {
        return UpdateTensorRTProviderOptionsWithValue$LAYOUT;
    }

    private static final long UpdateTensorRTProviderOptionsWithValue$OFFSET = 2088;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateTensorRTProviderOptionsWithValue)(OrtTensorRTProviderOptionsV2 *, const char *, void *)
     * }
     */
    public static final long UpdateTensorRTProviderOptionsWithValue$offset() {
        return UpdateTensorRTProviderOptionsWithValue$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateTensorRTProviderOptionsWithValue)(OrtTensorRTProviderOptionsV2 *, const char *, void *)
     * }
     */
    public static MemorySegment UpdateTensorRTProviderOptionsWithValue(MemorySegment struct) {
        return struct.get(UpdateTensorRTProviderOptionsWithValue$LAYOUT, UpdateTensorRTProviderOptionsWithValue$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateTensorRTProviderOptionsWithValue)(OrtTensorRTProviderOptionsV2 *, const char *, void *)
     * }
     */
    public static void UpdateTensorRTProviderOptionsWithValue(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(
                UpdateTensorRTProviderOptionsWithValue$LAYOUT,
                UpdateTensorRTProviderOptionsWithValue$OFFSET,
                fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateTensorRTProviderOptionsWithValue)(OrtTensorRTProviderOptionsV2 *, const char *, void *)
     * }
     */
    public static UpdateTensorRTProviderOptionsWithValue.Function UpdateTensorRTProviderOptionsWithValueFunction(
            MemorySegment struct) {
        return UpdateTensorRTProviderOptionsWithValue.function(UpdateTensorRTProviderOptionsWithValue(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorRTProviderOptionsByName)(const OrtTensorRTProviderOptionsV2 *, const char *, void **)
     * }
     */
    public static class GetTensorRTProviderOptionsByName {

        GetTensorRTProviderOptionsByName() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(GetTensorRTProviderOptionsByName.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetTensorRTProviderOptionsByName.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static GetTensorRTProviderOptionsByName.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2) -> invoke(funcPtr, _x0, _x1, _x2);
        }
    }

    private static final AddressLayout GetTensorRTProviderOptionsByName$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("GetTensorRTProviderOptionsByName"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorRTProviderOptionsByName)(const OrtTensorRTProviderOptionsV2 *, const char *, void **)
     * }
     */
    public static final AddressLayout GetTensorRTProviderOptionsByName$layout() {
        return GetTensorRTProviderOptionsByName$LAYOUT;
    }

    private static final long GetTensorRTProviderOptionsByName$OFFSET = 2096;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorRTProviderOptionsByName)(const OrtTensorRTProviderOptionsV2 *, const char *, void **)
     * }
     */
    public static final long GetTensorRTProviderOptionsByName$offset() {
        return GetTensorRTProviderOptionsByName$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorRTProviderOptionsByName)(const OrtTensorRTProviderOptionsV2 *, const char *, void **)
     * }
     */
    public static MemorySegment GetTensorRTProviderOptionsByName(MemorySegment struct) {
        return struct.get(GetTensorRTProviderOptionsByName$LAYOUT, GetTensorRTProviderOptionsByName$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorRTProviderOptionsByName)(const OrtTensorRTProviderOptionsV2 *, const char *, void **)
     * }
     */
    public static void GetTensorRTProviderOptionsByName(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetTensorRTProviderOptionsByName$LAYOUT, GetTensorRTProviderOptionsByName$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetTensorRTProviderOptionsByName)(const OrtTensorRTProviderOptionsV2 *, const char *, void **)
     * }
     */
    public static GetTensorRTProviderOptionsByName.Function GetTensorRTProviderOptionsByNameFunction(
            MemorySegment struct) {
        return GetTensorRTProviderOptionsByName.function(GetTensorRTProviderOptionsByName(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateCUDAProviderOptionsWithValue)(OrtCUDAProviderOptionsV2 *, const char *, void *)
     * }
     */
    public static class UpdateCUDAProviderOptionsWithValue {

        UpdateCUDAProviderOptionsWithValue() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(UpdateCUDAProviderOptionsWithValue.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(UpdateCUDAProviderOptionsWithValue.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static UpdateCUDAProviderOptionsWithValue.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2) -> invoke(funcPtr, _x0, _x1, _x2);
        }
    }

    private static final AddressLayout UpdateCUDAProviderOptionsWithValue$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("UpdateCUDAProviderOptionsWithValue"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateCUDAProviderOptionsWithValue)(OrtCUDAProviderOptionsV2 *, const char *, void *)
     * }
     */
    public static final AddressLayout UpdateCUDAProviderOptionsWithValue$layout() {
        return UpdateCUDAProviderOptionsWithValue$LAYOUT;
    }

    private static final long UpdateCUDAProviderOptionsWithValue$OFFSET = 2104;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateCUDAProviderOptionsWithValue)(OrtCUDAProviderOptionsV2 *, const char *, void *)
     * }
     */
    public static final long UpdateCUDAProviderOptionsWithValue$offset() {
        return UpdateCUDAProviderOptionsWithValue$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateCUDAProviderOptionsWithValue)(OrtCUDAProviderOptionsV2 *, const char *, void *)
     * }
     */
    public static MemorySegment UpdateCUDAProviderOptionsWithValue(MemorySegment struct) {
        return struct.get(UpdateCUDAProviderOptionsWithValue$LAYOUT, UpdateCUDAProviderOptionsWithValue$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateCUDAProviderOptionsWithValue)(OrtCUDAProviderOptionsV2 *, const char *, void *)
     * }
     */
    public static void UpdateCUDAProviderOptionsWithValue(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(UpdateCUDAProviderOptionsWithValue$LAYOUT, UpdateCUDAProviderOptionsWithValue$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*UpdateCUDAProviderOptionsWithValue)(OrtCUDAProviderOptionsV2 *, const char *, void *)
     * }
     */
    public static UpdateCUDAProviderOptionsWithValue.Function UpdateCUDAProviderOptionsWithValueFunction(
            MemorySegment struct) {
        return UpdateCUDAProviderOptionsWithValue.function(UpdateCUDAProviderOptionsWithValue(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*GetCUDAProviderOptionsByName)(const OrtCUDAProviderOptionsV2 *, const char *, void **)
     * }
     */
    public static class GetCUDAProviderOptionsByName {

        GetCUDAProviderOptionsByName() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(GetCUDAProviderOptionsByName.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(GetCUDAProviderOptionsByName.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static GetCUDAProviderOptionsByName.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2) -> invoke(funcPtr, _x0, _x1, _x2);
        }
    }

    private static final AddressLayout GetCUDAProviderOptionsByName$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("GetCUDAProviderOptionsByName"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetCUDAProviderOptionsByName)(const OrtCUDAProviderOptionsV2 *, const char *, void **)
     * }
     */
    public static final AddressLayout GetCUDAProviderOptionsByName$layout() {
        return GetCUDAProviderOptionsByName$LAYOUT;
    }

    private static final long GetCUDAProviderOptionsByName$OFFSET = 2112;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetCUDAProviderOptionsByName)(const OrtCUDAProviderOptionsV2 *, const char *, void **)
     * }
     */
    public static final long GetCUDAProviderOptionsByName$offset() {
        return GetCUDAProviderOptionsByName$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetCUDAProviderOptionsByName)(const OrtCUDAProviderOptionsV2 *, const char *, void **)
     * }
     */
    public static MemorySegment GetCUDAProviderOptionsByName(MemorySegment struct) {
        return struct.get(GetCUDAProviderOptionsByName$LAYOUT, GetCUDAProviderOptionsByName$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetCUDAProviderOptionsByName)(const OrtCUDAProviderOptionsV2 *, const char *, void **)
     * }
     */
    public static void GetCUDAProviderOptionsByName(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(GetCUDAProviderOptionsByName$LAYOUT, GetCUDAProviderOptionsByName$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*GetCUDAProviderOptionsByName)(const OrtCUDAProviderOptionsV2 *, const char *, void **)
     * }
     */
    public static GetCUDAProviderOptionsByName.Function GetCUDAProviderOptionsByNameFunction(MemorySegment struct) {
        return GetCUDAProviderOptionsByName.function(GetCUDAProviderOptionsByName(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetResource)(const OrtKernelContext *, int, int, void **)
     * }
     */
    public static class KernelContext_GetResource {

        KernelContext_GetResource() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, int _x1, int _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_INT,
                onnxruntime_all_h.C_INT,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(KernelContext_GetResource.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(KernelContext_GetResource.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr, MemorySegment _x0, int _x1, int _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static KernelContext_GetResource.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2, _x3) -> invoke(funcPtr, _x0, _x1, _x2, _x3);
        }
    }

    private static final AddressLayout KernelContext_GetResource$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("KernelContext_GetResource"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetResource)(const OrtKernelContext *, int, int, void **)
     * }
     */
    public static final AddressLayout KernelContext_GetResource$layout() {
        return KernelContext_GetResource$LAYOUT;
    }

    private static final long KernelContext_GetResource$OFFSET = 2120;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetResource)(const OrtKernelContext *, int, int, void **)
     * }
     */
    public static final long KernelContext_GetResource$offset() {
        return KernelContext_GetResource$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetResource)(const OrtKernelContext *, int, int, void **)
     * }
     */
    public static MemorySegment KernelContext_GetResource(MemorySegment struct) {
        return struct.get(KernelContext_GetResource$LAYOUT, KernelContext_GetResource$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetResource)(const OrtKernelContext *, int, int, void **)
     * }
     */
    public static void KernelContext_GetResource(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(KernelContext_GetResource$LAYOUT, KernelContext_GetResource$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetResource)(const OrtKernelContext *, int, int, void **)
     * }
     */
    public static KernelContext_GetResource.Function KernelContext_GetResourceFunction(MemorySegment struct) {
        return KernelContext_GetResource.function(KernelContext_GetResource(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SetUserLoggingFunction)(OrtSessionOptions *, OrtLoggingFunction, void *)
     * }
     */
    public static class SetUserLoggingFunction {

        SetUserLoggingFunction() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(SetUserLoggingFunction.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetUserLoggingFunction.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static SetUserLoggingFunction.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2) -> invoke(funcPtr, _x0, _x1, _x2);
        }
    }

    private static final AddressLayout SetUserLoggingFunction$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("SetUserLoggingFunction"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetUserLoggingFunction)(OrtSessionOptions *, OrtLoggingFunction, void *)
     * }
     */
    public static final AddressLayout SetUserLoggingFunction$layout() {
        return SetUserLoggingFunction$LAYOUT;
    }

    private static final long SetUserLoggingFunction$OFFSET = 2128;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetUserLoggingFunction)(OrtSessionOptions *, OrtLoggingFunction, void *)
     * }
     */
    public static final long SetUserLoggingFunction$offset() {
        return SetUserLoggingFunction$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetUserLoggingFunction)(OrtSessionOptions *, OrtLoggingFunction, void *)
     * }
     */
    public static MemorySegment SetUserLoggingFunction(MemorySegment struct) {
        return struct.get(SetUserLoggingFunction$LAYOUT, SetUserLoggingFunction$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetUserLoggingFunction)(OrtSessionOptions *, OrtLoggingFunction, void *)
     * }
     */
    public static void SetUserLoggingFunction(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetUserLoggingFunction$LAYOUT, SetUserLoggingFunction$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetUserLoggingFunction)(OrtSessionOptions *, OrtLoggingFunction, void *)
     * }
     */
    public static SetUserLoggingFunction.Function SetUserLoggingFunctionFunction(MemorySegment struct) {
        return SetUserLoggingFunction.function(SetUserLoggingFunction(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*ShapeInferContext_GetInputCount)(const OrtShapeInferContext *, size_t *)
     * }
     */
    public static class ShapeInferContext_GetInputCount {

        ShapeInferContext_GetInputCount() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(ShapeInferContext_GetInputCount.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ShapeInferContext_GetInputCount.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static ShapeInferContext_GetInputCount.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout ShapeInferContext_GetInputCount$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("ShapeInferContext_GetInputCount"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ShapeInferContext_GetInputCount)(const OrtShapeInferContext *, size_t *)
     * }
     */
    public static final AddressLayout ShapeInferContext_GetInputCount$layout() {
        return ShapeInferContext_GetInputCount$LAYOUT;
    }

    private static final long ShapeInferContext_GetInputCount$OFFSET = 2136;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ShapeInferContext_GetInputCount)(const OrtShapeInferContext *, size_t *)
     * }
     */
    public static final long ShapeInferContext_GetInputCount$offset() {
        return ShapeInferContext_GetInputCount$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ShapeInferContext_GetInputCount)(const OrtShapeInferContext *, size_t *)
     * }
     */
    public static MemorySegment ShapeInferContext_GetInputCount(MemorySegment struct) {
        return struct.get(ShapeInferContext_GetInputCount$LAYOUT, ShapeInferContext_GetInputCount$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ShapeInferContext_GetInputCount)(const OrtShapeInferContext *, size_t *)
     * }
     */
    public static void ShapeInferContext_GetInputCount(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ShapeInferContext_GetInputCount$LAYOUT, ShapeInferContext_GetInputCount$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ShapeInferContext_GetInputCount)(const OrtShapeInferContext *, size_t *)
     * }
     */
    public static ShapeInferContext_GetInputCount.Function ShapeInferContext_GetInputCountFunction(
            MemorySegment struct) {
        return ShapeInferContext_GetInputCount.function(ShapeInferContext_GetInputCount(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*ShapeInferContext_GetInputTypeShape)(const OrtShapeInferContext *, size_t, OrtTensorTypeAndShapeInfo **)
     * }
     */
    public static class ShapeInferContext_GetInputTypeShape {

        ShapeInferContext_GetInputTypeShape() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, long _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_LONG,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(ShapeInferContext_GetInputTypeShape.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ShapeInferContext_GetInputTypeShape.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, long _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static ShapeInferContext_GetInputTypeShape.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2) -> invoke(funcPtr, _x0, _x1, _x2);
        }
    }

    private static final AddressLayout ShapeInferContext_GetInputTypeShape$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("ShapeInferContext_GetInputTypeShape"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ShapeInferContext_GetInputTypeShape)(const OrtShapeInferContext *, size_t, OrtTensorTypeAndShapeInfo **)
     * }
     */
    public static final AddressLayout ShapeInferContext_GetInputTypeShape$layout() {
        return ShapeInferContext_GetInputTypeShape$LAYOUT;
    }

    private static final long ShapeInferContext_GetInputTypeShape$OFFSET = 2144;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ShapeInferContext_GetInputTypeShape)(const OrtShapeInferContext *, size_t, OrtTensorTypeAndShapeInfo **)
     * }
     */
    public static final long ShapeInferContext_GetInputTypeShape$offset() {
        return ShapeInferContext_GetInputTypeShape$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ShapeInferContext_GetInputTypeShape)(const OrtShapeInferContext *, size_t, OrtTensorTypeAndShapeInfo **)
     * }
     */
    public static MemorySegment ShapeInferContext_GetInputTypeShape(MemorySegment struct) {
        return struct.get(ShapeInferContext_GetInputTypeShape$LAYOUT, ShapeInferContext_GetInputTypeShape$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ShapeInferContext_GetInputTypeShape)(const OrtShapeInferContext *, size_t, OrtTensorTypeAndShapeInfo **)
     * }
     */
    public static void ShapeInferContext_GetInputTypeShape(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ShapeInferContext_GetInputTypeShape$LAYOUT, ShapeInferContext_GetInputTypeShape$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ShapeInferContext_GetInputTypeShape)(const OrtShapeInferContext *, size_t, OrtTensorTypeAndShapeInfo **)
     * }
     */
    public static ShapeInferContext_GetInputTypeShape.Function ShapeInferContext_GetInputTypeShapeFunction(
            MemorySegment struct) {
        return ShapeInferContext_GetInputTypeShape.function(ShapeInferContext_GetInputTypeShape(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*ShapeInferContext_GetAttribute)(const OrtShapeInferContext *, const char *, const OrtOpAttr **)
     * }
     */
    public static class ShapeInferContext_GetAttribute {

        ShapeInferContext_GetAttribute() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(ShapeInferContext_GetAttribute.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ShapeInferContext_GetAttribute.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static ShapeInferContext_GetAttribute.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2) -> invoke(funcPtr, _x0, _x1, _x2);
        }
    }

    private static final AddressLayout ShapeInferContext_GetAttribute$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("ShapeInferContext_GetAttribute"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ShapeInferContext_GetAttribute)(const OrtShapeInferContext *, const char *, const OrtOpAttr **)
     * }
     */
    public static final AddressLayout ShapeInferContext_GetAttribute$layout() {
        return ShapeInferContext_GetAttribute$LAYOUT;
    }

    private static final long ShapeInferContext_GetAttribute$OFFSET = 2152;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ShapeInferContext_GetAttribute)(const OrtShapeInferContext *, const char *, const OrtOpAttr **)
     * }
     */
    public static final long ShapeInferContext_GetAttribute$offset() {
        return ShapeInferContext_GetAttribute$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ShapeInferContext_GetAttribute)(const OrtShapeInferContext *, const char *, const OrtOpAttr **)
     * }
     */
    public static MemorySegment ShapeInferContext_GetAttribute(MemorySegment struct) {
        return struct.get(ShapeInferContext_GetAttribute$LAYOUT, ShapeInferContext_GetAttribute$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ShapeInferContext_GetAttribute)(const OrtShapeInferContext *, const char *, const OrtOpAttr **)
     * }
     */
    public static void ShapeInferContext_GetAttribute(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ShapeInferContext_GetAttribute$LAYOUT, ShapeInferContext_GetAttribute$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ShapeInferContext_GetAttribute)(const OrtShapeInferContext *, const char *, const OrtOpAttr **)
     * }
     */
    public static ShapeInferContext_GetAttribute.Function ShapeInferContext_GetAttributeFunction(MemorySegment struct) {
        return ShapeInferContext_GetAttribute.function(ShapeInferContext_GetAttribute(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*ShapeInferContext_SetOutputTypeShape)(const OrtShapeInferContext *, size_t, const OrtTensorTypeAndShapeInfo *)
     * }
     */
    public static class ShapeInferContext_SetOutputTypeShape {

        ShapeInferContext_SetOutputTypeShape() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, long _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_LONG,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(ShapeInferContext_SetOutputTypeShape.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ShapeInferContext_SetOutputTypeShape.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, long _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static ShapeInferContext_SetOutputTypeShape.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2) -> invoke(funcPtr, _x0, _x1, _x2);
        }
    }

    private static final AddressLayout ShapeInferContext_SetOutputTypeShape$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("ShapeInferContext_SetOutputTypeShape"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ShapeInferContext_SetOutputTypeShape)(const OrtShapeInferContext *, size_t, const OrtTensorTypeAndShapeInfo *)
     * }
     */
    public static final AddressLayout ShapeInferContext_SetOutputTypeShape$layout() {
        return ShapeInferContext_SetOutputTypeShape$LAYOUT;
    }

    private static final long ShapeInferContext_SetOutputTypeShape$OFFSET = 2160;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ShapeInferContext_SetOutputTypeShape)(const OrtShapeInferContext *, size_t, const OrtTensorTypeAndShapeInfo *)
     * }
     */
    public static final long ShapeInferContext_SetOutputTypeShape$offset() {
        return ShapeInferContext_SetOutputTypeShape$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ShapeInferContext_SetOutputTypeShape)(const OrtShapeInferContext *, size_t, const OrtTensorTypeAndShapeInfo *)
     * }
     */
    public static MemorySegment ShapeInferContext_SetOutputTypeShape(MemorySegment struct) {
        return struct.get(ShapeInferContext_SetOutputTypeShape$LAYOUT, ShapeInferContext_SetOutputTypeShape$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ShapeInferContext_SetOutputTypeShape)(const OrtShapeInferContext *, size_t, const OrtTensorTypeAndShapeInfo *)
     * }
     */
    public static void ShapeInferContext_SetOutputTypeShape(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(
                ShapeInferContext_SetOutputTypeShape$LAYOUT, ShapeInferContext_SetOutputTypeShape$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ShapeInferContext_SetOutputTypeShape)(const OrtShapeInferContext *, size_t, const OrtTensorTypeAndShapeInfo *)
     * }
     */
    public static ShapeInferContext_SetOutputTypeShape.Function ShapeInferContext_SetOutputTypeShapeFunction(
            MemorySegment struct) {
        return ShapeInferContext_SetOutputTypeShape.function(ShapeInferContext_SetOutputTypeShape(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SetSymbolicDimensions)(OrtTensorTypeAndShapeInfo *, const char **, size_t)
     * }
     */
    public static class SetSymbolicDimensions {

        SetSymbolicDimensions() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_LONG);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(SetSymbolicDimensions.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetSymbolicDimensions.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, long _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static SetSymbolicDimensions.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2) -> invoke(funcPtr, _x0, _x1, _x2);
        }
    }

    private static final AddressLayout SetSymbolicDimensions$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("SetSymbolicDimensions"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetSymbolicDimensions)(OrtTensorTypeAndShapeInfo *, const char **, size_t)
     * }
     */
    public static final AddressLayout SetSymbolicDimensions$layout() {
        return SetSymbolicDimensions$LAYOUT;
    }

    private static final long SetSymbolicDimensions$OFFSET = 2168;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetSymbolicDimensions)(OrtTensorTypeAndShapeInfo *, const char **, size_t)
     * }
     */
    public static final long SetSymbolicDimensions$offset() {
        return SetSymbolicDimensions$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetSymbolicDimensions)(OrtTensorTypeAndShapeInfo *, const char **, size_t)
     * }
     */
    public static MemorySegment SetSymbolicDimensions(MemorySegment struct) {
        return struct.get(SetSymbolicDimensions$LAYOUT, SetSymbolicDimensions$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetSymbolicDimensions)(OrtTensorTypeAndShapeInfo *, const char **, size_t)
     * }
     */
    public static void SetSymbolicDimensions(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetSymbolicDimensions$LAYOUT, SetSymbolicDimensions$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetSymbolicDimensions)(OrtTensorTypeAndShapeInfo *, const char **, size_t)
     * }
     */
    public static SetSymbolicDimensions.Function SetSymbolicDimensionsFunction(MemorySegment struct) {
        return SetSymbolicDimensions.function(SetSymbolicDimensions(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*ReadOpAttr)(const OrtOpAttr *, OrtOpAttrType, void *, size_t, size_t *)
     * }
     */
    public static class ReadOpAttr {

        ReadOpAttr() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, int _x1, MemorySegment _x2, long _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_INT,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_LONG,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(ReadOpAttr.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReadOpAttr.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr, MemorySegment _x0, int _x1, MemorySegment _x2, long _x3, MemorySegment _x4) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static ReadOpAttr.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2, _x3, _x4) -> invoke(funcPtr, _x0, _x1, _x2, _x3, _x4);
        }
    }

    private static final AddressLayout ReadOpAttr$LAYOUT = (AddressLayout) $LAYOUT.select(groupElement("ReadOpAttr"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ReadOpAttr)(const OrtOpAttr *, OrtOpAttrType, void *, size_t, size_t *)
     * }
     */
    public static final AddressLayout ReadOpAttr$layout() {
        return ReadOpAttr$LAYOUT;
    }

    private static final long ReadOpAttr$OFFSET = 2176;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ReadOpAttr)(const OrtOpAttr *, OrtOpAttrType, void *, size_t, size_t *)
     * }
     */
    public static final long ReadOpAttr$offset() {
        return ReadOpAttr$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ReadOpAttr)(const OrtOpAttr *, OrtOpAttrType, void *, size_t, size_t *)
     * }
     */
    public static MemorySegment ReadOpAttr(MemorySegment struct) {
        return struct.get(ReadOpAttr$LAYOUT, ReadOpAttr$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ReadOpAttr)(const OrtOpAttr *, OrtOpAttrType, void *, size_t, size_t *)
     * }
     */
    public static void ReadOpAttr(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReadOpAttr$LAYOUT, ReadOpAttr$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*ReadOpAttr)(const OrtOpAttr *, OrtOpAttrType, void *, size_t, size_t *)
     * }
     */
    public static ReadOpAttr.Function ReadOpAttrFunction(MemorySegment struct) {
        return ReadOpAttr.function(ReadOpAttr(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SetDeterministicCompute)(OrtSessionOptions *, bool)
     * }
     */
    public static class SetDeterministicCompute {

        SetDeterministicCompute() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, boolean _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_BOOL);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(SetDeterministicCompute.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetDeterministicCompute.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, boolean _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static SetDeterministicCompute.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout SetDeterministicCompute$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("SetDeterministicCompute"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetDeterministicCompute)(OrtSessionOptions *, bool)
     * }
     */
    public static final AddressLayout SetDeterministicCompute$layout() {
        return SetDeterministicCompute$LAYOUT;
    }

    private static final long SetDeterministicCompute$OFFSET = 2184;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetDeterministicCompute)(OrtSessionOptions *, bool)
     * }
     */
    public static final long SetDeterministicCompute$offset() {
        return SetDeterministicCompute$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetDeterministicCompute)(OrtSessionOptions *, bool)
     * }
     */
    public static MemorySegment SetDeterministicCompute(MemorySegment struct) {
        return struct.get(SetDeterministicCompute$LAYOUT, SetDeterministicCompute$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetDeterministicCompute)(OrtSessionOptions *, bool)
     * }
     */
    public static void SetDeterministicCompute(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetDeterministicCompute$LAYOUT, SetDeterministicCompute$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetDeterministicCompute)(OrtSessionOptions *, bool)
     * }
     */
    public static SetDeterministicCompute.Function SetDeterministicComputeFunction(MemorySegment struct) {
        return SetDeterministicCompute.function(SetDeterministicCompute(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_ParallelFor)(const OrtKernelContext *, void (*)(void *, size_t), size_t, size_t, void *)
     * }
     */
    public static class KernelContext_ParallelFor {

        KernelContext_ParallelFor() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2, long _x3, MemorySegment _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_LONG,
                onnxruntime_all_h.C_LONG,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(KernelContext_ParallelFor.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(KernelContext_ParallelFor.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, long _x2, long _x3, MemorySegment _x4) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static KernelContext_ParallelFor.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2, _x3, _x4) -> invoke(funcPtr, _x0, _x1, _x2, _x3, _x4);
        }
    }

    private static final AddressLayout KernelContext_ParallelFor$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("KernelContext_ParallelFor"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_ParallelFor)(const OrtKernelContext *, void (*)(void *, size_t), size_t, size_t, void *)
     * }
     */
    public static final AddressLayout KernelContext_ParallelFor$layout() {
        return KernelContext_ParallelFor$LAYOUT;
    }

    private static final long KernelContext_ParallelFor$OFFSET = 2192;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_ParallelFor)(const OrtKernelContext *, void (*)(void *, size_t), size_t, size_t, void *)
     * }
     */
    public static final long KernelContext_ParallelFor$offset() {
        return KernelContext_ParallelFor$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_ParallelFor)(const OrtKernelContext *, void (*)(void *, size_t), size_t, size_t, void *)
     * }
     */
    public static MemorySegment KernelContext_ParallelFor(MemorySegment struct) {
        return struct.get(KernelContext_ParallelFor$LAYOUT, KernelContext_ParallelFor$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_ParallelFor)(const OrtKernelContext *, void (*)(void *, size_t), size_t, size_t, void *)
     * }
     */
    public static void KernelContext_ParallelFor(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(KernelContext_ParallelFor$LAYOUT, KernelContext_ParallelFor$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_ParallelFor)(const OrtKernelContext *, void (*)(void *, size_t), size_t, size_t, void *)
     * }
     */
    public static KernelContext_ParallelFor.Function KernelContext_ParallelForFunction(MemorySegment struct) {
        return KernelContext_ParallelFor.function(KernelContext_ParallelFor(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_OpenVINO_V2)(OrtSessionOptions *, const char *const *, const char *const *, size_t)
     * }
     */
    public static class SessionOptionsAppendExecutionProvider_OpenVINO_V2 {

        SessionOptionsAppendExecutionProvider_OpenVINO_V2() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_LONG);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_all_h.upcallHandle(
                SessionOptionsAppendExecutionProvider_OpenVINO_V2.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(
                SessionOptionsAppendExecutionProvider_OpenVINO_V2.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static SessionOptionsAppendExecutionProvider_OpenVINO_V2.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2, _x3) -> invoke(funcPtr, _x0, _x1, _x2, _x3);
        }
    }

    private static final AddressLayout SessionOptionsAppendExecutionProvider_OpenVINO_V2$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("SessionOptionsAppendExecutionProvider_OpenVINO_V2"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_OpenVINO_V2)(OrtSessionOptions *, const char *const *, const char *const *, size_t)
     * }
     */
    public static final AddressLayout SessionOptionsAppendExecutionProvider_OpenVINO_V2$layout() {
        return SessionOptionsAppendExecutionProvider_OpenVINO_V2$LAYOUT;
    }

    private static final long SessionOptionsAppendExecutionProvider_OpenVINO_V2$OFFSET = 2200;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_OpenVINO_V2)(OrtSessionOptions *, const char *const *, const char *const *, size_t)
     * }
     */
    public static final long SessionOptionsAppendExecutionProvider_OpenVINO_V2$offset() {
        return SessionOptionsAppendExecutionProvider_OpenVINO_V2$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_OpenVINO_V2)(OrtSessionOptions *, const char *const *, const char *const *, size_t)
     * }
     */
    public static MemorySegment SessionOptionsAppendExecutionProvider_OpenVINO_V2(MemorySegment struct) {
        return struct.get(
                SessionOptionsAppendExecutionProvider_OpenVINO_V2$LAYOUT,
                SessionOptionsAppendExecutionProvider_OpenVINO_V2$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_OpenVINO_V2)(OrtSessionOptions *, const char *const *, const char *const *, size_t)
     * }
     */
    public static void SessionOptionsAppendExecutionProvider_OpenVINO_V2(
            MemorySegment struct, MemorySegment fieldValue) {
        struct.set(
                SessionOptionsAppendExecutionProvider_OpenVINO_V2$LAYOUT,
                SessionOptionsAppendExecutionProvider_OpenVINO_V2$OFFSET,
                fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_OpenVINO_V2)(OrtSessionOptions *, const char *const *, const char *const *, size_t)
     * }
     */
    public static SessionOptionsAppendExecutionProvider_OpenVINO_V2.Function
            SessionOptionsAppendExecutionProvider_OpenVINO_V2Function(MemorySegment struct) {
        return SessionOptionsAppendExecutionProvider_OpenVINO_V2.function(
                SessionOptionsAppendExecutionProvider_OpenVINO_V2(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_VitisAI)(OrtSessionOptions *, const char *const *, const char *const *, size_t)
     * }
     */
    public static class SessionOptionsAppendExecutionProvider_VitisAI {

        SessionOptionsAppendExecutionProvider_VitisAI() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_LONG);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = onnxruntime_all_h.upcallHandle(
                SessionOptionsAppendExecutionProvider_VitisAI.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SessionOptionsAppendExecutionProvider_VitisAI.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static SessionOptionsAppendExecutionProvider_VitisAI.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2, _x3) -> invoke(funcPtr, _x0, _x1, _x2, _x3);
        }
    }

    private static final AddressLayout SessionOptionsAppendExecutionProvider_VitisAI$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("SessionOptionsAppendExecutionProvider_VitisAI"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_VitisAI)(OrtSessionOptions *, const char *const *, const char *const *, size_t)
     * }
     */
    public static final AddressLayout SessionOptionsAppendExecutionProvider_VitisAI$layout() {
        return SessionOptionsAppendExecutionProvider_VitisAI$LAYOUT;
    }

    private static final long SessionOptionsAppendExecutionProvider_VitisAI$OFFSET = 2208;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_VitisAI)(OrtSessionOptions *, const char *const *, const char *const *, size_t)
     * }
     */
    public static final long SessionOptionsAppendExecutionProvider_VitisAI$offset() {
        return SessionOptionsAppendExecutionProvider_VitisAI$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_VitisAI)(OrtSessionOptions *, const char *const *, const char *const *, size_t)
     * }
     */
    public static MemorySegment SessionOptionsAppendExecutionProvider_VitisAI(MemorySegment struct) {
        return struct.get(
                SessionOptionsAppendExecutionProvider_VitisAI$LAYOUT,
                SessionOptionsAppendExecutionProvider_VitisAI$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_VitisAI)(OrtSessionOptions *, const char *const *, const char *const *, size_t)
     * }
     */
    public static void SessionOptionsAppendExecutionProvider_VitisAI(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(
                SessionOptionsAppendExecutionProvider_VitisAI$LAYOUT,
                SessionOptionsAppendExecutionProvider_VitisAI$OFFSET,
                fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_VitisAI)(OrtSessionOptions *, const char *const *, const char *const *, size_t)
     * }
     */
    public static SessionOptionsAppendExecutionProvider_VitisAI.Function
            SessionOptionsAppendExecutionProvider_VitisAIFunction(MemorySegment struct) {
        return SessionOptionsAppendExecutionProvider_VitisAI.function(
                SessionOptionsAppendExecutionProvider_VitisAI(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetScratchBuffer)(const OrtKernelContext *, const OrtMemoryInfo *, size_t, void **)
     * }
     */
    public static class KernelContext_GetScratchBuffer {

        KernelContext_GetScratchBuffer() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_LONG,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(KernelContext_GetScratchBuffer.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(KernelContext_GetScratchBuffer.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static KernelContext_GetScratchBuffer.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2, _x3) -> invoke(funcPtr, _x0, _x1, _x2, _x3);
        }
    }

    private static final AddressLayout KernelContext_GetScratchBuffer$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("KernelContext_GetScratchBuffer"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetScratchBuffer)(const OrtKernelContext *, const OrtMemoryInfo *, size_t, void **)
     * }
     */
    public static final AddressLayout KernelContext_GetScratchBuffer$layout() {
        return KernelContext_GetScratchBuffer$LAYOUT;
    }

    private static final long KernelContext_GetScratchBuffer$OFFSET = 2216;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetScratchBuffer)(const OrtKernelContext *, const OrtMemoryInfo *, size_t, void **)
     * }
     */
    public static final long KernelContext_GetScratchBuffer$offset() {
        return KernelContext_GetScratchBuffer$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetScratchBuffer)(const OrtKernelContext *, const OrtMemoryInfo *, size_t, void **)
     * }
     */
    public static MemorySegment KernelContext_GetScratchBuffer(MemorySegment struct) {
        return struct.get(KernelContext_GetScratchBuffer$LAYOUT, KernelContext_GetScratchBuffer$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetScratchBuffer)(const OrtKernelContext *, const OrtMemoryInfo *, size_t, void **)
     * }
     */
    public static void KernelContext_GetScratchBuffer(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(KernelContext_GetScratchBuffer$LAYOUT, KernelContext_GetScratchBuffer$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelContext_GetScratchBuffer)(const OrtKernelContext *, const OrtMemoryInfo *, size_t, void **)
     * }
     */
    public static KernelContext_GetScratchBuffer.Function KernelContext_GetScratchBufferFunction(MemorySegment struct) {
        return KernelContext_GetScratchBuffer.function(KernelContext_GetScratchBuffer(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAllocator)(const OrtKernelInfo *, OrtMemType, OrtAllocator **)
     * }
     */
    public static class KernelInfoGetAllocator {

        KernelInfoGetAllocator() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, int _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_INT,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(KernelInfoGetAllocator.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(KernelInfoGetAllocator.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, int _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static KernelInfoGetAllocator.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2) -> invoke(funcPtr, _x0, _x1, _x2);
        }
    }

    private static final AddressLayout KernelInfoGetAllocator$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("KernelInfoGetAllocator"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAllocator)(const OrtKernelInfo *, OrtMemType, OrtAllocator **)
     * }
     */
    public static final AddressLayout KernelInfoGetAllocator$layout() {
        return KernelInfoGetAllocator$LAYOUT;
    }

    private static final long KernelInfoGetAllocator$OFFSET = 2224;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAllocator)(const OrtKernelInfo *, OrtMemType, OrtAllocator **)
     * }
     */
    public static final long KernelInfoGetAllocator$offset() {
        return KernelInfoGetAllocator$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAllocator)(const OrtKernelInfo *, OrtMemType, OrtAllocator **)
     * }
     */
    public static MemorySegment KernelInfoGetAllocator(MemorySegment struct) {
        return struct.get(KernelInfoGetAllocator$LAYOUT, KernelInfoGetAllocator$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAllocator)(const OrtKernelInfo *, OrtMemType, OrtAllocator **)
     * }
     */
    public static void KernelInfoGetAllocator(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(KernelInfoGetAllocator$LAYOUT, KernelInfoGetAllocator$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*KernelInfoGetAllocator)(const OrtKernelInfo *, OrtMemType, OrtAllocator **)
     * }
     */
    public static KernelInfoGetAllocator.Function KernelInfoGetAllocatorFunction(MemorySegment struct) {
        return KernelInfoGetAllocator.function(KernelInfoGetAllocator(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*AddExternalInitializersFromFilesInMemory)(OrtSessionOptions *, const char *const *, char *const *, const size_t *, size_t)
     * }
     */
    public static class AddExternalInitializersFromFilesInMemory {

        AddExternalInitializersFromFilesInMemory() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, long _x4);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_LONG);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(AddExternalInitializersFromFilesInMemory.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(AddExternalInitializersFromFilesInMemory.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr,
                MemorySegment _x0,
                MemorySegment _x1,
                MemorySegment _x2,
                MemorySegment _x3,
                long _x4) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static AddExternalInitializersFromFilesInMemory.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2, _x3, _x4) -> invoke(funcPtr, _x0, _x1, _x2, _x3, _x4);
        }
    }

    private static final AddressLayout AddExternalInitializersFromFilesInMemory$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("AddExternalInitializersFromFilesInMemory"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddExternalInitializersFromFilesInMemory)(OrtSessionOptions *, const char *const *, char *const *, const size_t *, size_t)
     * }
     */
    public static final AddressLayout AddExternalInitializersFromFilesInMemory$layout() {
        return AddExternalInitializersFromFilesInMemory$LAYOUT;
    }

    private static final long AddExternalInitializersFromFilesInMemory$OFFSET = 2232;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddExternalInitializersFromFilesInMemory)(OrtSessionOptions *, const char *const *, char *const *, const size_t *, size_t)
     * }
     */
    public static final long AddExternalInitializersFromFilesInMemory$offset() {
        return AddExternalInitializersFromFilesInMemory$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddExternalInitializersFromFilesInMemory)(OrtSessionOptions *, const char *const *, char *const *, const size_t *, size_t)
     * }
     */
    public static MemorySegment AddExternalInitializersFromFilesInMemory(MemorySegment struct) {
        return struct.get(
                AddExternalInitializersFromFilesInMemory$LAYOUT, AddExternalInitializersFromFilesInMemory$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddExternalInitializersFromFilesInMemory)(OrtSessionOptions *, const char *const *, char *const *, const size_t *, size_t)
     * }
     */
    public static void AddExternalInitializersFromFilesInMemory(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(
                AddExternalInitializersFromFilesInMemory$LAYOUT,
                AddExternalInitializersFromFilesInMemory$OFFSET,
                fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*AddExternalInitializersFromFilesInMemory)(OrtSessionOptions *, const char *const *, char *const *, const size_t *, size_t)
     * }
     */
    public static AddExternalInitializersFromFilesInMemory.Function AddExternalInitializersFromFilesInMemoryFunction(
            MemorySegment struct) {
        return AddExternalInitializersFromFilesInMemory.function(AddExternalInitializersFromFilesInMemory(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateLoraAdapter)(const char *, OrtAllocator *, OrtLoraAdapter **)
     * }
     */
    public static class CreateLoraAdapter {

        CreateLoraAdapter() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(CreateLoraAdapter.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateLoraAdapter.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static CreateLoraAdapter.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2) -> invoke(funcPtr, _x0, _x1, _x2);
        }
    }

    private static final AddressLayout CreateLoraAdapter$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("CreateLoraAdapter"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateLoraAdapter)(const char *, OrtAllocator *, OrtLoraAdapter **)
     * }
     */
    public static final AddressLayout CreateLoraAdapter$layout() {
        return CreateLoraAdapter$LAYOUT;
    }

    private static final long CreateLoraAdapter$OFFSET = 2240;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateLoraAdapter)(const char *, OrtAllocator *, OrtLoraAdapter **)
     * }
     */
    public static final long CreateLoraAdapter$offset() {
        return CreateLoraAdapter$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateLoraAdapter)(const char *, OrtAllocator *, OrtLoraAdapter **)
     * }
     */
    public static MemorySegment CreateLoraAdapter(MemorySegment struct) {
        return struct.get(CreateLoraAdapter$LAYOUT, CreateLoraAdapter$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateLoraAdapter)(const char *, OrtAllocator *, OrtLoraAdapter **)
     * }
     */
    public static void CreateLoraAdapter(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateLoraAdapter$LAYOUT, CreateLoraAdapter$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateLoraAdapter)(const char *, OrtAllocator *, OrtLoraAdapter **)
     * }
     */
    public static CreateLoraAdapter.Function CreateLoraAdapterFunction(MemorySegment struct) {
        return CreateLoraAdapter.function(CreateLoraAdapter(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateLoraAdapterFromArray)(const void *, size_t, OrtAllocator *, OrtLoraAdapter **)
     * }
     */
    public static class CreateLoraAdapterFromArray {

        CreateLoraAdapterFromArray() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_LONG,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(CreateLoraAdapterFromArray.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(CreateLoraAdapterFromArray.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr, MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static CreateLoraAdapterFromArray.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2, _x3) -> invoke(funcPtr, _x0, _x1, _x2, _x3);
        }
    }

    private static final AddressLayout CreateLoraAdapterFromArray$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("CreateLoraAdapterFromArray"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateLoraAdapterFromArray)(const void *, size_t, OrtAllocator *, OrtLoraAdapter **)
     * }
     */
    public static final AddressLayout CreateLoraAdapterFromArray$layout() {
        return CreateLoraAdapterFromArray$LAYOUT;
    }

    private static final long CreateLoraAdapterFromArray$OFFSET = 2248;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateLoraAdapterFromArray)(const void *, size_t, OrtAllocator *, OrtLoraAdapter **)
     * }
     */
    public static final long CreateLoraAdapterFromArray$offset() {
        return CreateLoraAdapterFromArray$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateLoraAdapterFromArray)(const void *, size_t, OrtAllocator *, OrtLoraAdapter **)
     * }
     */
    public static MemorySegment CreateLoraAdapterFromArray(MemorySegment struct) {
        return struct.get(CreateLoraAdapterFromArray$LAYOUT, CreateLoraAdapterFromArray$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateLoraAdapterFromArray)(const void *, size_t, OrtAllocator *, OrtLoraAdapter **)
     * }
     */
    public static void CreateLoraAdapterFromArray(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(CreateLoraAdapterFromArray$LAYOUT, CreateLoraAdapterFromArray$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*CreateLoraAdapterFromArray)(const void *, size_t, OrtAllocator *, OrtLoraAdapter **)
     * }
     */
    public static CreateLoraAdapterFromArray.Function CreateLoraAdapterFromArrayFunction(MemorySegment struct) {
        return CreateLoraAdapterFromArray.function(CreateLoraAdapterFromArray(struct));
    }

    /**
     * {@snippet lang=c :
     * void (*ReleaseLoraAdapter)(OrtLoraAdapter *)
     * }
     */
    public static class ReleaseLoraAdapter {

        ReleaseLoraAdapter() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            void apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(ReleaseLoraAdapter.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(ReleaseLoraAdapter.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static void invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static ReleaseLoraAdapter.Function function(MemorySegment funcPtr) {
            return (_x0) -> invoke(funcPtr, _x0);
        }
    }

    private static final AddressLayout ReleaseLoraAdapter$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("ReleaseLoraAdapter"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void (*ReleaseLoraAdapter)(OrtLoraAdapter *)
     * }
     */
    public static final AddressLayout ReleaseLoraAdapter$layout() {
        return ReleaseLoraAdapter$LAYOUT;
    }

    private static final long ReleaseLoraAdapter$OFFSET = 2256;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void (*ReleaseLoraAdapter)(OrtLoraAdapter *)
     * }
     */
    public static final long ReleaseLoraAdapter$offset() {
        return ReleaseLoraAdapter$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void (*ReleaseLoraAdapter)(OrtLoraAdapter *)
     * }
     */
    public static MemorySegment ReleaseLoraAdapter(MemorySegment struct) {
        return struct.get(ReleaseLoraAdapter$LAYOUT, ReleaseLoraAdapter$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void (*ReleaseLoraAdapter)(OrtLoraAdapter *)
     * }
     */
    public static void ReleaseLoraAdapter(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(ReleaseLoraAdapter$LAYOUT, ReleaseLoraAdapter$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * void (*ReleaseLoraAdapter)(OrtLoraAdapter *)
     * }
     */
    public static ReleaseLoraAdapter.Function ReleaseLoraAdapterFunction(MemorySegment struct) {
        return ReleaseLoraAdapter.function(ReleaseLoraAdapter(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsAddActiveLoraAdapter)(OrtRunOptions *, const OrtLoraAdapter *)
     * }
     */
    public static class RunOptionsAddActiveLoraAdapter {

        RunOptionsAddActiveLoraAdapter() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER, onnxruntime_all_h.C_POINTER);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(RunOptionsAddActiveLoraAdapter.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(RunOptionsAddActiveLoraAdapter.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static RunOptionsAddActiveLoraAdapter.Function function(MemorySegment funcPtr) {
            return (_x0, _x1) -> invoke(funcPtr, _x0, _x1);
        }
    }

    private static final AddressLayout RunOptionsAddActiveLoraAdapter$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("RunOptionsAddActiveLoraAdapter"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsAddActiveLoraAdapter)(OrtRunOptions *, const OrtLoraAdapter *)
     * }
     */
    public static final AddressLayout RunOptionsAddActiveLoraAdapter$layout() {
        return RunOptionsAddActiveLoraAdapter$LAYOUT;
    }

    private static final long RunOptionsAddActiveLoraAdapter$OFFSET = 2264;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsAddActiveLoraAdapter)(OrtRunOptions *, const OrtLoraAdapter *)
     * }
     */
    public static final long RunOptionsAddActiveLoraAdapter$offset() {
        return RunOptionsAddActiveLoraAdapter$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsAddActiveLoraAdapter)(OrtRunOptions *, const OrtLoraAdapter *)
     * }
     */
    public static MemorySegment RunOptionsAddActiveLoraAdapter(MemorySegment struct) {
        return struct.get(RunOptionsAddActiveLoraAdapter$LAYOUT, RunOptionsAddActiveLoraAdapter$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsAddActiveLoraAdapter)(OrtRunOptions *, const OrtLoraAdapter *)
     * }
     */
    public static void RunOptionsAddActiveLoraAdapter(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(RunOptionsAddActiveLoraAdapter$LAYOUT, RunOptionsAddActiveLoraAdapter$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*RunOptionsAddActiveLoraAdapter)(OrtRunOptions *, const OrtLoraAdapter *)
     * }
     */
    public static RunOptionsAddActiveLoraAdapter.Function RunOptionsAddActiveLoraAdapterFunction(MemorySegment struct) {
        return RunOptionsAddActiveLoraAdapter.function(RunOptionsAddActiveLoraAdapter(struct));
    }

    /**
     * {@snippet lang=c :
     * OrtStatusPtr (*SetEpDynamicOptions)(OrtSession *, const char *const *, const char *const *, size_t)
     * }
     */
    public static class SetEpDynamicOptions {

        SetEpDynamicOptions() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_POINTER,
                onnxruntime_all_h.C_LONG);

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH =
                onnxruntime_all_h.upcallHandle(SetEpDynamicOptions.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(SetEpDynamicOptions.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static MemorySegment invoke(
                MemorySegment funcPtr, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {
            try {
                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }

        /**
         * Get an implementation of the function interface from a function pointer.
         */
        public static SetEpDynamicOptions.Function function(MemorySegment funcPtr) {
            return (_x0, _x1, _x2, _x3) -> invoke(funcPtr, _x0, _x1, _x2, _x3);
        }
    }

    private static final AddressLayout SetEpDynamicOptions$LAYOUT =
            (AddressLayout) $LAYOUT.select(groupElement("SetEpDynamicOptions"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetEpDynamicOptions)(OrtSession *, const char *const *, const char *const *, size_t)
     * }
     */
    public static final AddressLayout SetEpDynamicOptions$layout() {
        return SetEpDynamicOptions$LAYOUT;
    }

    private static final long SetEpDynamicOptions$OFFSET = 2272;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetEpDynamicOptions)(OrtSession *, const char *const *, const char *const *, size_t)
     * }
     */
    public static final long SetEpDynamicOptions$offset() {
        return SetEpDynamicOptions$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetEpDynamicOptions)(OrtSession *, const char *const *, const char *const *, size_t)
     * }
     */
    public static MemorySegment SetEpDynamicOptions(MemorySegment struct) {
        return struct.get(SetEpDynamicOptions$LAYOUT, SetEpDynamicOptions$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetEpDynamicOptions)(OrtSession *, const char *const *, const char *const *, size_t)
     * }
     */
    public static void SetEpDynamicOptions(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(SetEpDynamicOptions$LAYOUT, SetEpDynamicOptions$OFFSET, fieldValue);
    }

    /**
     * Functional interface getter for field:
     * {@snippet lang=c :
     * OrtStatusPtr (*SetEpDynamicOptions)(OrtSession *, const char *const *, const char *const *, size_t)
     * }
     */
    public static SetEpDynamicOptions.Function SetEpDynamicOptionsFunction(MemorySegment struct) {
        return SetEpDynamicOptions.function(SetEpDynamicOptions(struct));
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() {
        return layout().byteSize();
    }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(
            MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}
